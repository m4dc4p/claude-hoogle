<repomix><file_summary>This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been formatted for parsing in xml style.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style
- Files are sorted by Git change count (files with more changes are at the bottom)</notes></file_summary><directory_structure>.github/
  workflows/
    ci.yml
cbits/
  include.h
  text_search.bat
  text_search.c
  text_search.hs
docs/
  API.md
  Haskell.org.md
  Install.md
  TypeSearch.md
html/
  plugin/
    chosen-jquery.js
    chosen-sprite.png
    chosen-sprite@2x.png
    chosen.css
    jquery-cookie.js
  embed-demo.htm
  favicon.png
  favicon57.png
  favicon64.png
  hoogle.css
  hoogle.js
  hoogle.png
  index.html
  less_blue.png
  less_gray.png
  less_small.png
  log.html
  log.js
  more_blue.png
  more_gray.png
  more_small.png
  search.xml
  spinner.gif
  welcome.html
misc/
  sample-data/
    emily-1.11/
      emily.txt
    emily-1.2/
      emily.txt
    henry.txt
  Keywords.hs
  logo.svg
  settings.txt
  Upgrade.hs
src/
  Action/
    CmdLine.hs
    Generate.hs
    Search.hs
    Server.hs
    Test.hs
  General/
    Conduit.hs
    IString.hs
    Log.hs
    Store.hs
    Str.hs
    Template.hs
    Timing.hs
    Util.hs
    Web.hs
  Input/
    Cabal.hs
    Download.hs
    Haddock.hs
    Item.hs
    ParseDecl.hs
    Reorder.hs
    Set.hs
    Settings.hs
  Output/
    Items.hs
    Names.hs
    Tags.hs
    Types.hs
  Hoogle.hs
  Main.hs
  Paths.hs
  Query.hs
.ghci
.gitignore
.hlint.yaml
.stylish-haskell.yaml
.weeder.yaml
CHANGES.txt
ghci.bat
hoogle.cabal
LICENSE
PULL_REQUEST_TEMPLATE.md
README.md
Setup.hs
todo.txt
todo2.txt</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".github/workflows/ci.yml">name: ci
on:
  push:
  pull_request:
  schedule:
  - cron:  &apos;0 3 * * 6&apos; # 3am Saturday
jobs:
  test:
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest]
        ghc: [&apos;9.8&apos;, &apos;9.6&apos;, &apos;9.4&apos;]
        include:
        - os: windows-latest
          ghc: 9.12
        - os: macOS-latest
          ghc: 9.12

    steps:
    - run: git config --global core.autocrlf false
    - uses: actions/checkout@v2
    - uses: haskell-actions/setup@v2
      id: setup-haskell
      with:
        ghc-version: ${{ matrix.ghc }}
    - run: cabal v2-freeze --enable-tests
    - uses: actions/cache@v4
      with:
        path: ${{ steps.setup-haskell.outputs.cabal-store }}
        key: ${{ runner.os }}-${{ matrix.ghc }}-${{ hashFiles(&apos;cabal.project.freeze&apos;) }}
        restore-keys: ${{ runner.os }}-${{ matrix.ghc }}-
    - uses: ndmitchell/neil@master</file><file path="cbits/include.h">int text_search(char* haystack, char** needles, int exact, int* results);
int text_search_bound(char* xs);</file><file path="cbits/text_search.bat">gcc -c text_search.c -std=c99 -O2 -Wall -Wextra -Werror &amp;&amp; ghci text_search.o text_search.hs</file><file path="cbits/text_search.c">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


int min_int(int a, int b){return a &gt; b ? b : a;}
int max_int(int a, int b){return a &lt; b ? b : a;}

int maximum_int(int xs[], int n)
{
    int mx = 0;
    for (int i = 0; i &lt; n; i++)
        mx = max_int(mx, xs[i]);
    return mx;
}


// Given a list of words, separated by 0 and ending with two 0
// Find the character that occurs in most words, and return the count of it
int text_search_bound(char* xs)
{
    int counts[256];         // number of words I&apos;ve seen each char in
    int poss[256];           // position I saw last char at
    int pos = 0;             // the current position I am at

    for (int i = 0; i &lt; 256; i++)
    {
        counts[i] = 0;
        poss[i] = -1;
    }

    for (char* cs = xs; ; cs++)
    {
        unsigned char c = *cs;
        if (c == 0)
        {
            if (cs[1] == 0) break;
            pos++;
        }
        else if (poss[c] != pos)
        {
            poss[c] = pos;
            counts[c]++;
        }
    }
    return maximum_int(counts, 256);
}


int count_pointers(char** xs)
{
    int i;
    for (i = 0; xs[i] != NULL; i++)
        ;
    return i;
}

int compare_int(const void *a, const void *b)
{
  const int *da = (const int*) a;
  const int *db = (const int*) b;

  return (*da &gt; *db) - (*da &lt; *db);
}


// Taken from http://stackoverflow.com/questions/23999797/implementing-strnstr/24000056#24000056
char* memmem_(char* haystack, size_t hlen, char* needle, size_t nlen)
{
    if (nlen == 0) return haystack; // degenerate edge case
    if (hlen &lt; nlen) return 0; // another degenerate edge case
    char *hlimit = haystack + hlen - nlen + 1;
    while ((haystack = memchr(haystack, needle[0], hlimit-haystack)))
    {
        if (!memcmp(haystack, needle, nlen)) return haystack;
        haystack++;
    }
    return 0;
}


// haystack is \0 (space if leading upper) (lowercase string), ends with two \0
// needles are a NULL terminated list of lowercase strings, with a leading space if upper
int text_search(char* haystack, char** needles, int exact, int* results)
{
    // information about the needles
    int n = count_pointers(needles);
    int uppers[n];        // is this needle uppercase prefix
    int lengths[n];       // length of this needle
    char* strings[n];     // actual text of this needle

    for (int i = 0; i &lt; n; i++)
    {
        uppers[i] = needles[i][0] == &apos; &apos;;
        strings[i] = uppers[i] ? &amp;needles[i][1] : needles[i];
        lengths[i] = strlen(strings[i]);
    }

    int index = 0;          // Number of \n&apos;s I&apos;ve already seen in haystack
    int found = 0;          // Number I&apos;ve written to results

    for (index = 0; ; index++)
    {
        int upper = haystack[0] == &apos; &apos;;
        if (upper) haystack++;
        int length = strlen(haystack);
        if (length == 0) break;
        char* string = haystack;
        haystack = &amp;haystack[length+1];

        int score = 4;
        for (int i = 0; i &lt; n; i++)
        {
            char* pos = strstr(string, strings[i]); // length, strings[i], lengths[i]);
            if (pos == NULL)
            {
                score = -1;
                break;
            }
            else if (pos == string)
            {
                int complete = lengths[i] == length;
                int cased = uppers[i] == upper;
                score = min_int(score, (!complete ? 2 : 0) + (!cased ? 1 : 0));
            }
        }
        if (score &gt;= 0 &amp;&amp; (!exact || score == 0))
            results[found++] = (score &lt;&lt; 24) | index;
    }
    qsort(results, found, sizeof(int), compare_int);
    for (int i = 0; i &lt; found; i++)
        results[i] = results[i] &amp; 0xffffff;
    return found;
}</file><file path="cbits/text_search.hs">import Foreign
import Foreign.C.Types
import Foreign.C.String
import Control.Exception
import Control.Monad
import Control.Applicative
import System.IO


foreign import ccall text_search_bound :: CString -&gt; IO CInt

foreign import ccall text_search :: CString -&gt; Ptr CString -&gt; CInt -&gt; Ptr CInt -&gt; IO CInt

withs :: Monad m =&gt; [(a -&gt; m r) -&gt; m r] -&gt; ([a] -&gt; m r) -&gt; m r
withs [] act = act []
withs (f:fs) act = f $ \a -&gt; withs fs $ \as -&gt; act $ a:as

text_search_bound_ :: String -&gt; IO Int
text_search_bound_ s = withCString s $ fmap fromIntegral . text_search_bound

text_search_ :: String -&gt; [String] -&gt; Bool -&gt; IO [Int]
text_search_ haystack needles exact =
    let n = length $ filter (== &apos;\0&apos;) haystack in
    withCString haystack $ \haystack -&gt;
    withs (map withCString needles) $ \needles -&gt; withArray0 nullPtr needles $ \needles -&gt;
    withArray (replicate n 0) $ \result -&gt; do
        found &lt;- text_search haystack needles (if exact then 1 else 0) result
        map fromIntegral &lt;$&gt; peekArray (fromIntegral found) result


(===) :: (Show a, Eq a) =&gt; IO a -&gt; a -&gt; IO ()
(===) x y = do x &lt;- x; if x == y then putChar &apos;.&apos; else error $ show (&quot;Mismatch&quot;,x,y)


main :: IO ()
main = do
    hSetBuffering stdout NoBuffering
    text_search_bound_ &quot;Test\0abcccccccc\0new\0&quot; === 2
    text_search_ &quot; test\0more\0tex\0xtee\0&quot; [&quot;te&quot;] False === [2,0,3]
    text_search_ &quot; base\0base\0&quot; [&quot;base&quot;] False === [1,0]
    text_search_ &quot; base\0base\0&quot; [] False === [0,1]
    text_search_ &quot; base\0base\0&quot; [&quot;&quot;] False === [1,0]
    putStrLn &quot;&quot;</file><file path="docs/API.md">Hoogle can be integrated into other projects in several ways.

----------

**This page describes how Hoogle 5 might work, and has not yet been fully implemented.** 

----------

# Embedded Hoogle

Embedded Hoogle lets you include a small interactive Hoogle search box on your web page. As an example:

&lt;form action=&quot;https://hoogle.haskell.org&quot; method=&quot;get&quot;&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;https://hoogle.haskell.org/hoogle.js&quot;&gt;&lt;/script&gt;
  &lt;input type=&quot;text&quot;   name=&quot;hoogle&quot; id=&quot;hoogle&quot; accesskey=&quot;1&quot; /&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Search&quot; /&gt;
&lt;/form&gt;

Try entering searches into the box above, for example &quot;filter&quot;. As you type, the search box should perform Hoogle searches, and display the results. Selecting a result will visit the associated documentation. Pressing the Search button will perform the search at the Hoogle website.

To use Embedded Hoogle on your page add:

    &lt;form action=&quot;https://hoogle.haskell.org&quot; method=&quot;get&quot;&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;https://hoogle.haskell.org/hoogle.js&quot;&gt;&lt;/script&gt;
        &lt;input type=&quot;text&quot;   name=&quot;hoogle&quot; id=&quot;hoogle&quot; accesskey=&quot;1&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Search&quot; /&gt;
    &lt;/form&gt;

Embedded Hoogle degrades gracefully without Javascript, and works on all common browsers. If you are using IE 7 or below you may not see results unless the page being displayed is on the same server as the Hoogle instance (i.e. haskell.org), due to restrictions on cross domain AJAX requests.

To use a different Hoogle server change the action field of the form. To specify a prefix/suffix for all searches add an input field with the name prefix/suffix. For example, to search only the base package add:

    &lt;input type=&quot;hidden&quot; name=&quot;prefix&quot; value=&quot;+base&quot; /&gt;


# Haskell API

Hoogle is available as a standard Haskell library, whose documentation is available at http://hackage.haskell.org/packages/archive/hoogle/latest/doc/html/Hoogle.html. The web version and command-line tools are both built on the Hoogle library.


# JSON API

The Hoogle website provides JSON output using the parameter `?mode=json`. As an example:

    $ curl -sS &quot;https://hoogle.haskell.org?mode=json&amp;hoogle=map&amp;start=1&amp;count=2&quot;
    [
      {
        &quot;url&quot;: &quot;https://hackage.haskell.org/package/base/docs/Prelude.html#v:map&quot;,
        &quot;module&quot;: {
          &quot;url&quot;: &quot;https://hackage.haskell.org/package/base/docs/Prelude.html&quot;,
          &quot;name&quot;: &quot;Prelude&quot;
        },
        &quot;package&quot;: {
          &quot;url&quot;: &quot;https://hackage.haskell.org/package/base&quot;,
          &quot;name&quot;: &quot;base&quot;
        },
        &quot;item&quot;: &quot;&lt;span class=name&gt;&lt;s0&gt;map&lt;/s0&gt;&lt;/span&gt; :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&quot;,
        &quot;type&quot;: &quot;&quot;,
        &quot;docs&quot;: &quot;&lt;a&gt;map&lt;/a&gt; &lt;tt&gt;f xs&lt;/tt&gt; is the list obtained by applying &lt;tt&gt;f&lt;/tt&gt;\nto each element of &lt;tt&gt;xs&lt;/tt&gt;, i.e.,\n\n&lt;pre&gt;\nmap f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]\nmap f [x1, x2, ...] == [f x1, f x2, ...]\n&lt;/pre&gt;\n&quot;
      },
      {
        &quot;url&quot;: &quot;https://hackage.haskell.org/package/base/docs/Data-List.html#v:map&quot;,
        &quot;module&quot;: {
          &quot;url&quot;: &quot;https://hackage.haskell.org/package/base/docs/Data-List.html&quot;,
          &quot;name&quot;: &quot;Data.List&quot;
        },
        &quot;package&quot;: {
          &quot;url&quot;: &quot;https://hackage.haskell.org/package/base&quot;,
          &quot;name&quot;: &quot;base&quot;
        },
        &quot;item&quot;: &quot;&lt;span class=name&gt;&lt;s0&gt;map&lt;/s0&gt;&lt;/span&gt; :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&quot;,
        &quot;type&quot;: &quot;&quot;,
        &quot;docs&quot;: &quot;&lt;a&gt;map&lt;/a&gt; &lt;tt&gt;f xs&lt;/tt&gt; is the list obtained by applying &lt;tt&gt;f&lt;/tt&gt;\nto each element of &lt;tt&gt;xs&lt;/tt&gt;, i.e.,\n\n&lt;pre&gt;\nmap f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]\nmap f [x1, x2, ...] == [f x1, f x2, ...]\n&lt;/pre&gt;\n&quot;
      }
    ]

Another possible option is to set the `?format` query parameter to `text` (only current possible value), to remove the HTML tags from the `item` and `docs` properties of the output.

    $ curl -sS &quot;https://hoogle.haskell.org?mode=json&amp;format=text&amp;hoogle=map&amp;start=1&amp;count=2&quot;
    [
      {
        &quot;url&quot;: &quot;https://hackage.haskell.org/package/base/docs/Prelude.html#v:map&quot;,
        &quot;module&quot;: {
          &quot;url&quot;: &quot;https://hackage.haskell.org/package/base/docs/Prelude.html&quot;,
          &quot;name&quot;: &quot;Prelude&quot;
        },
        &quot;package&quot;: {
          &quot;url&quot;: &quot;https://hackage.haskell.org/package/base&quot;,
          &quot;name&quot;: &quot;base&quot;
        },
        &quot;item&quot;: &quot;map :: (a -&gt; b) -&gt; [a] -&gt; [b]&quot;,
        &quot;type&quot;: &quot;&quot;,
        &quot;docs&quot;: &quot;map f xs is the list obtained by applying f\nto each element of xs, i.e.,\n\n\nmap f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]\nmap f [x1, x2, ...] == [f x1, f x2, ...]\n\n&quot;
      },
      {
        &quot;url&quot;: &quot;https://hackage.haskell.org/package/base/docs/Data-List.html#v:map&quot;,
        &quot;module&quot;: {
          &quot;url&quot;: &quot;https://hackage.haskell.org/package/base/docs/Data-List.html&quot;,
          &quot;name&quot;: &quot;Data.List&quot;
        },
        &quot;package&quot;: {
          &quot;url&quot;: &quot;https://hackage.haskell.org/package/base&quot;,
          &quot;name&quot;: &quot;base&quot;
        },
        &quot;item&quot;: &quot;map :: (a -&gt; b) -&gt; [a] -&gt; [b]&quot;,
        &quot;type&quot;: &quot;&quot;,
        &quot;docs&quot;: &quot;map f xs is the list obtained by applying f\nto each element of xs, i.e.,\n\n\nmap f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]\nmap f [x1, x2, ...] == [f x1, f x2, ...]\n\n&quot;
      }
    ]
    
These JSON outputs have been reformatted to better fit the screen. Future versions of Hoogle may produce different JSON output.</file><file path="docs/Haskell.org.md"># Steps to setup Hoogle on haskell.org

The machine `hoogle.haskell.org` is located at `104.130.162.85` and runs the Hoogle instance. These instructions set up the machine for automatic updates 8pm every day.

## Initial setup

### As `root`

Install `ghc`, `git` and `zlib` (a required library).

    add-apt-repository -y ppa:hvr/ghc
    apt-get update
    apt-get install ghc-8.6.3 cabal-install-1.24 happy-1.19.4 alex-3.1.3
    apt-get install git
    apt-get install zlib1g-dev

Create a swap file using the instructions [originally from here](https://tecadmin.net/enable-swap-on-ubuntu/):

    fallocate -l 4G /swapfile
    chmod 600 /swapfile
    mkswap /swapfile
    swapon /swapfile

Remap port 80 to 8080 so non-privileged processes can talk on port 80, using the instructions [originally from here](http://unix.stackexchange.com/questions/10735/linux-allowing-an-user-to-listen-to-a-port-below-1024/10791#10791):

    modprobe ip_tables
    echo &apos;ip_tables&apos; &gt;&gt; /etc/modules
    iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080
    iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443

Create the user `www` configured for SSH access.

### As `www`

Add the GHC/Cabal binaries to the `$PATH` in the `~/.profile`.

    export PATH=/home/www/.cabal/bin:/opt/ghc/8.6.3/bin:/opt/cabal/1.18/bin:/opt/happy/1.19.4/bin:/opt/alex/3.1.3/bin:$PATH

Create a shell script `update.sh`:

    cd /home/www
    wget https://raw.githubusercontent.com/ndmitchell/hoogle/master/misc/Upgrade.hs -O - --quiet | runhaskell

Then configure updating every day at 8pm. Add a Cron job by using `crontab -e` and adding the line:

    0 20 * * * bash -l /home/www/update.sh &gt; /home/www/update.txt 2&gt;&amp;1

## Monitoring

* `df -h`, check there is sufficient disk space, `ncdu` to clean it up.
* `top`, see what is running.

Currently monitored with [uptimerobot.com](http://uptimerobot.com/).

## SSH

To renew the certificates do (will result in ~15 minutes downtime):

    pkill hoogle
    pkill rdr2tls
    sudo certbot certonly -d hoogle.haskell.org --standalone --preferred-challenges http --http-01-port 8080
    sh update.sh

The sudo command should be run from the `root` login, the rest from the `www` login. The resulting files live at:

* `/etc/letsencrypt/live/hoogle.haskell.org/fullchain.pem`
* `/etc/letsencrypt/live/hoogle.haskell.org/privkey.pem`

## Alternatives and notes

At some point I added the line `/swapfile none swap sw 0 0` to the bottom of `/etc/fstab`. Not sure if that is required or not.

To run on port 80, as root do (as per [here](http://stackoverflow.com/questions/413807/is-there-a-way-for-non-root-processes-to-bind-to-privileged-ports-1024-on-l#414258)):

    setcap &apos;cap_net_bind_service=+ep&apos; /home/www/.cabal/bin/hoogle

`relrod` on IRC says for port 80 usually we&apos;ve been doing this (or at least I have for hl): Have the app server run and listen on localhost, then throw nginx front of it as a proxy. Let nginx handle things like SSL and caching (and binding to port 80 and 443). Not really a guide, but you can see the config in the ansible repo..</file><file path="docs/Install.md"># Installing Hoogle locally

The server at [hoogle.haskell.org](https://hoogle.haskell.org) provides a version of Hoogle updated daily that searches all the packages available on [Stackage](https://stackage.org). This document describes how to install and setup your own copy of Hoogle, which is useful if you want to search different packages, use the command line, or use Hoogle offline.

The first step is to obtain Hoogle, currently from the Git repo, then install it using `cabal` or `stack`.

A Hoogle database is a prebuilt index of a set of packages. A database is a single binary file (usually with extension `.hoo`) which is generated once then searched in a read-only manner. By default, Hoogle will generate the default database at `~/.hoogle/default.hoo`, but this can be configured with the `--database` flag. If you pass a custom `--database` flag, make sure to pass a similar flag when running `search` or `server`.

The remainder of this document covers generating Hoogle databases, then searching Hoogle databases.


## Generate a Hoogle database

There are several different use cases for generating databases. All ultimately take text files (usually with extension `.txt`) which are a list of functions and their types, along with information about type synonyms, instances etc. The textual database files can be generated by [Cabal](https://haskell.org/cabal/) with `cabal haddock --haddock-hoogle`.

### Index all of Stackage

Run `hoogle generate` to generate an index for the current version of Stackage LTS. This command downloads the necessary inputs from the web as required and caches them (in the same directory as the database). To force redownloading pass `--download`. To demand no downloading, failing if the data cannot be found, pass `--download=no`. Links to the results will point at Hackage.

### Index specific packages

Run `hoogle generate base filepath` to generate an index for only the `base` and `filepath` libraries. Using this command you can chose to index packages not in Stackage. Links to the results will point at Hackage.

### Index all ghc-pkg installed packages

Run `hoogle generate --local` to query `ghc-pkg` and generate links for all packages which have documentation and Hoogle input files generated. By editing your Cabal config file you can have Cabal automatically generate such files when packages are installed. Links to the results will point at your local file system.

### Index a directory

Run `hoogle generate --local=mydir` to generate an index for the packages in `mydir`, which must contain `foo.txt` Hoogle input files. Links to the results will default to Hackage, but if `@url` directives are in the `.txt` files they can override the link destination.

## Searching a Hoogle database

You can run searches on the command line or by spawning a web server.

### Command line

Just be careful not to redirect your output by doing `a -&gt; b` and producing a file called `b`.

### Server

If your database points at the local file system pass `--local` to reserve `file://` links over `http://`, so the documentation works.

## Old usage notes

### GHCi Integration

Ever feel like having access to hoogle whilst messing around in GHCi? It&apos;s relatively easy to integrate the two. 

The following will install hoogle as a shell command, and configure GHCi to have a command &quot;:hoogle&quot;:

* &lt;tt&gt;cabal install hoogle&lt;/tt&gt;
* &lt;tt&gt;echo &gt;&gt; ~/.ghci &apos;:def hoogle \x -&gt; return $ &quot;:!hoogle &quot; ++ x&apos;&lt;/tt&gt;

NB. the above wraps the argument in quotes before passing to the shell command, so there is no need to supply quotes; eg.

    :hoogle map
    :hoogle (a -&gt; b) -&gt; [a] -&gt; [b]

Done!

On Windows you should add the same line
 :def hoogle \x -&gt; return $ &quot;:!hoogle \&quot;&quot; ++ x ++ &quot;\&quot;&quot;
to file (XP/2003):
 C:\Documents and Settings\[your windows account]\Application Data\ghc\ghci.conf 
or(Windows Vista/7):
 C:\users\[your windows account]\Application Data\ghc\ghci.conf 

#### How it works

Next, we need to integrate it into GHCi. We can execute shell commands with GHCi via &lt;code&gt;:def&lt;/code&gt;. Load up GHCi, and type the following:

 :def hoogle \x -&gt; return $ &quot;:!hoogle &quot; ++ x

If this executes cleanly, you should be able to run hoogle commands from GHCi via &lt;code&gt;:hoogle&lt;/code&gt;, i.e. &lt;code&gt;:hoogle map&lt;/code&gt; or &lt;code&gt;:hoogle &quot;(a -&gt; b) -&gt; [a] -&gt; [b]&quot;&lt;/code&gt;. Be careful: you need the extra quotes when hoogling types, at least on my system. &lt;code&gt;:ho&lt;/code&gt; works as an abbreviation of &lt;code&gt;:hoogle&lt;/code&gt; (just &lt;code&gt;:h&lt;/code&gt; clashes with &lt;code&gt;:help&lt;/code&gt;).

Finally, we want to make this persist across GHCi sessions. GHCi loads a file called ~/.ghci before running, so simply stick the above &lt;code&gt;:def&lt;/code&gt; in that file and all should work.

Contributed by [[User:DavidHouse|DavidHouse]]

### Emacs Integration
[[Haskell_mode_for_Emacs|haskell-mode]] from versions 2.4 onwards have the function haskell-hoogle, which will hoogle the identifier at point. Setup:

```
(require &apos;haskell-mode)
(define-key haskell-mode-map &quot;\C-ch&quot; &apos;haskell-hoogle)
;(setq haskell-hoogle-command &quot;hoogle&quot;)
```

You will need a web browser configured for best results. Here&apos;s an example setup for Safari:

```
(setq browse-url-browser-function &apos;browse-url-safari)
 (defun browse-url-safari (url &amp;optional new-window)
  &quot;Open URL in a new Safari window.&quot;
  (interactive (browse-url-interactive-arg &quot;URL: &quot;))
  (unless
      (string= &quot;&quot;
               (shell-command-to-string
                (concat &quot;open -a Safari &quot; url)))
    (message &quot;Starting Safari...&quot;)
    (start-process (concat &quot;open -a Safari &quot; url) nil &quot;open -a Safari &quot; url)
    (message &quot;Starting Safari... done&quot;)))
```

Alternately, you can build the command-line hoogle (darcs repo below) and uncomment the third line above, then results will appear in a buffer.</file><file path="docs/TypeSearch.md"># TypeSearch algorithm

This document outlines the type search algorithm used in Hoogle.

The basic question is:

    (?) :: TypeQ -&gt; TypeA -&gt; Maybe Cost

Where `TypeQ` is the user query, `TypeA` is drawn from the database, `Nothing` is no match, and `Just i` is a cost of `i` (`Cost` is probably a synonym for `Double`).

## Rewrites

Given `a ? b`, we answer with a cost by applying rewrites until we get to equal values. If we never get to equal values we say `Nothing`, if we arrive at equal values we say `Just` with a cost based on the rewrites applied. The rewrites are:

* **Both:** _[Arg reorder]_ `x -&gt; y -&gt; z ~&gt; y -&gt; x -&gt; z`.
* **Both:** _[Arg delete]_ `x -&gt; y -&gt; z ~&gt; y -&gt; z`, at most once per side.
* **Both:** _[Freevar rename]_ `x ~&gt; y`.
* **LHS only:** _[Alias follow]_ `type X = Y` provides a rewrite `X ~&gt; Y`.
* **LHS only:** _[Instance subtype]_ `instance C X` provides a rewrite `X ~&gt; forall z . C z`.
* **RHS only:** _[Context delete]_ `C x =&gt; y ~&gt; y`.
* **Both:** _[Special]_ `Maybe a ~&gt; a` can be applied, along with a few other special rules.

## Optimisation

We optimise the rewrites by providing some operations like `?` but which work on precomputed information and can be applied cheaply. In general, we define:

    (??) :: TypeQ? -&gt; TypeA? -&gt; Bool

Where `False` predicts that `?` will return `Nothing`, but cheaper.

### Arity

Compute `TypeQ#` and `TypeA#` by taking the arity of the type.

    (?#) :: TypeQ# -&gt; TypeA# -&gt; Bool
    i ?# j = if i == 0 || j = 0 then i == j else abs (j - i) &lt;= 1

Works because we can only apply _[Arg delete]_ at most once. For the special case where either side is arity 0 (a CAF) we demand equality.

### Rarity

Compute `TypeQ!` and `TypeA!` by taking the number of packages/modules/signatures each constructor or context occurs in, and finding the lowest (rarest) value. For `TypeA!` also consider following all instance and alias rules.

    (?!) :: TypeQ! -&gt; TypeA! -&gt; Bool
    i ?! j = i &gt;= j * 3

The rationale is that if you search for a common search string like `Monad m =&gt; m a -&gt; IO a` (all symbols found in almost all packages) then anything containing a rare value like `ShakeOptions` should be excluded, even if it happens to match.

Do not follow instances that are considered to be &quot;uninteresting&quot;, such as `Eq`, `Data`, `Typeable` etc (otherwise very rare types get marked as very common).

### Names

Compute `TypeA~` as the list of constructors and contexts that occur, tagging the contexts with a leading `#` to ensure they do not clash with constructors. Sort the list of names.

Compute `TypeQ~` as a decision tree of names that must occur to match, relying on the fact that the only &quot;LHS only&quot; rules can introduce new names. As some examples:

* If constructor `Foo` (no alias or instances) is mentioned it must be literally present.
* If constructor `FilePath` (`type FilePath = String`) is mentioned either `FilePath` must be present or `String` must be satisfied.
* If `String` (`type String = [Char]`) is mentioned either `String` must be present or `[]` and `Char`.
* If `[]` (`instance Functor []`) is mentioned either `[]` must be present or `Functor` must be satisfied.

Compute `?~` by generating a state machine from the tree of `TypeQ~` and applying it to `TypeA~`.


# Examples

* `a -&gt; b` should only look at things with very rare constructors - perhaps a bit of `()` and `Eq`, but nothing more.
* `ShakeOptions -&gt; ()` can look at very rare things, as long as they contain `ShakeOptions` in them.
* `ShakeOptions -&gt; ()` has a `Data` instance, so `{Data} -&gt; ()` is fine to search for, but then you are restricted to things that have a very common things in them, since `Data` is so common.

# Random notes

## Model

The model is we have concrete types, type variables, and properties over type variables (roughly contexts).

    Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b

Here `Functor` is a property of some type variable. We can reduce that with the equations `{} =&gt; Functor []`. We also have rules such as `{Ord a} =&gt; Ord [a]`.

There are also aliases, e.g. `String =&gt; FilePath`.

In some ways, this is just proof search?

* **LHS only:** _[Alias follow]_ `type X = Y` provides a rewrite `X ~&gt; Y`.
* **LHS only:** _[Instance subtype]_ `instance C X` provides a rewrite `X ~&gt; forall z . C z`.

Given a concrete type, which aliases can you follow?

**Not satisfying...**

Semantically...


A generic instaniable proof system, where:

How close are two proofs?

Do they talk about the same things? Are the things easily convertable?

apply some rules, which rules got used. can i do bulk apply? things that are only one rule apart? can i start small and evolve upwards?

classifiers?

ShakeOptions is a pretty unique classifier, only 26 odd have it.

IO () return type is a poor classifier, very common.


## Properties

For any type T present in the result, searching for it should give that result first.

# More thoughts

Just need to get something working - anything really!

Aliases have a great problem with matching too much...

Names that clash really screw things up...

Monad =&gt; IO ...


    (a -&gt; b) -&gt; [a] -&gt; [b]

    Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b

If I ask for Functor f ... - I probably really want to have some functor context.

If I ask for [], I can probably generalise it

A virtual machine for matching? Precompute a _program_ that makes the decision.

This set of functions all require you to have written `Functor` as a context.


Given:

&gt; ShakeOptions -&gt; Action a -&gt; IO a

Searching:

&gt; Action a -&gt; IO a

The rarest thing in the first is ShakeOptions. The second rarest is Action.

Add a characteristic function on each thing?

44K functions. Can do a moderate amount of computation on each one.
vs 252K names.

Best thing to do is get down to 100 or so plausible ones, then go from there.

Arity filters.</file><file path="html/plugin/chosen-jquery.js">/*!
Chosen, a Select Box Enhancer for jQuery and Prototype
by Patrick Filler for Harvest, http://getharvest.com

Version 1.3.0
Full source at https://github.com/harvesthq/chosen
Copyright (c) 2011-2014 Harvest http://getharvest.com

MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
This file is generated by `grunt build`, do not edit it by hand.
*/

(function() {
  var $, AbstractChosen, Chosen, SelectParser, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  SelectParser = (function() {
    function SelectParser() {
      this.options_index = 0;
      this.parsed = [];
    }

    SelectParser.prototype.add_node = function(child) {
      if (child.nodeName.toUpperCase() === &quot;OPTGROUP&quot;) {
        return this.add_group(child);
      } else {
        return this.add_option(child);
      }
    };

    SelectParser.prototype.add_group = function(group) {
      var group_position, option, _i, _len, _ref, _results;
      group_position = this.parsed.length;
      this.parsed.push({
        array_index: group_position,
        group: true,
        label: this.escapeExpression(group.label),
        children: 0,
        disabled: group.disabled,
        classes: group.className
      });
      _ref = group.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        option = _ref[_i];
        _results.push(this.add_option(option, group_position, group.disabled));
      }
      return _results;
    };

    SelectParser.prototype.add_option = function(option, group_position, group_disabled) {
      if (option.nodeName.toUpperCase() === &quot;OPTION&quot;) {
        if (option.text !== &quot;&quot;) {
          if (group_position != null) {
            this.parsed[group_position].children += 1;
          }
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            value: option.value,
            text: option.text,
            html: option.innerHTML,
            selected: option.selected,
            disabled: group_disabled === true ? group_disabled : option.disabled,
            group_array_index: group_position,
            classes: option.className,
            style: option.style.cssText
          });
        } else {
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            empty: true
          });
        }
        return this.options_index += 1;
      }
    };

    SelectParser.prototype.escapeExpression = function(text) {
      var map, unsafe_chars;
      if ((text == null) || text === false) {
        return &quot;&quot;;
      }
      if (!/[\&amp;\&lt;\&gt;\&quot;\&apos;\`]/.test(text)) {
        return text;
      }
      map = {
        &quot;&lt;&quot;: &quot;&amp;lt;&quot;,
        &quot;&gt;&quot;: &quot;&amp;gt;&quot;,
        &apos;&quot;&apos;: &quot;&amp;quot;&quot;,
        &quot;&apos;&quot;: &quot;&amp;#x27;&quot;,
        &quot;`&quot;: &quot;&amp;#x60;&quot;
      };
      unsafe_chars = /&amp;(?!\w+;)|[\&lt;\&gt;\&quot;\&apos;\`]/g;
      return text.replace(unsafe_chars, function(chr) {
        return map[chr] || &quot;&amp;amp;&quot;;
      });
    };

    return SelectParser;

  })();

  SelectParser.select_to_array = function(select) {
    var child, parser, _i, _len, _ref;
    parser = new SelectParser();
    _ref = select.childNodes;
    for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
      child = _ref[_i];
      parser.add_node(child);
    }
    return parser.parsed;
  };

  AbstractChosen = (function() {
    function AbstractChosen(form_field, options) {
      this.form_field = form_field;
      this.options = options != null ? options : {};
      if (!AbstractChosen.browser_is_supported()) {
        return;
      }
      this.is_multiple = this.form_field.multiple;
      this.set_default_text();
      this.set_default_values();
      this.setup();
      this.set_up_html();
      this.register_observers();
      this.on_ready();
    }

    AbstractChosen.prototype.set_default_values = function() {
      var _this = this;
      this.click_test_action = function(evt) {
        return _this.test_active_click(evt);
      };
      this.activate_action = function(evt) {
        return _this.activate_field(evt);
      };
      this.active_field = false;
      this.mouse_on_container = false;
      this.results_showing = false;
      this.result_highlighted = null;
      this.allow_single_deselect = (this.options.allow_single_deselect != null) &amp;&amp; (this.form_field.options[0] != null) &amp;&amp; this.form_field.options[0].text === &quot;&quot; ? this.options.allow_single_deselect : false;
      this.disable_search_threshold = this.options.disable_search_threshold || 0;
      this.disable_search = this.options.disable_search || false;
      this.enable_split_word_search = this.options.enable_split_word_search != null ? this.options.enable_split_word_search : true;
      this.group_search = this.options.group_search != null ? this.options.group_search : true;
      this.search_contains = this.options.search_contains || false;
      this.single_backstroke_delete = this.options.single_backstroke_delete != null ? this.options.single_backstroke_delete : true;
      this.max_selected_options = this.options.max_selected_options || Infinity;
      this.inherit_select_classes = this.options.inherit_select_classes || false;
      this.display_selected_options = this.options.display_selected_options != null ? this.options.display_selected_options : true;
      return this.display_disabled_options = this.options.display_disabled_options != null ? this.options.display_disabled_options : true;
    };

    AbstractChosen.prototype.set_default_text = function() {
      if (this.form_field.getAttribute(&quot;data-placeholder&quot;)) {
        this.default_text = this.form_field.getAttribute(&quot;data-placeholder&quot;);
      } else if (this.is_multiple) {
        this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || AbstractChosen.default_multiple_text;
      } else {
        this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || AbstractChosen.default_single_text;
      }
      return this.results_none_found = this.form_field.getAttribute(&quot;data-no_results_text&quot;) || this.options.no_results_text || AbstractChosen.default_no_result_text;
    };

    AbstractChosen.prototype.mouse_enter = function() {
      return this.mouse_on_container = true;
    };

    AbstractChosen.prototype.mouse_leave = function() {
      return this.mouse_on_container = false;
    };

    AbstractChosen.prototype.input_focus = function(evt) {
      var _this = this;
      if (this.is_multiple) {
        if (!this.active_field) {
          return setTimeout((function() {
            return _this.container_mousedown();
          }), 50);
        }
      } else {
        if (!this.active_field) {
          return this.activate_field();
        }
      }
    };

    AbstractChosen.prototype.input_blur = function(evt) {
      var _this = this;
      if (!this.mouse_on_container) {
        this.active_field = false;
        return setTimeout((function() {
          return _this.blur_test();
        }), 100);
      }
    };

    AbstractChosen.prototype.results_option_build = function(options) {
      var content, data, _i, _len, _ref;
      content = &apos;&apos;;
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        data = _ref[_i];
        if (data.group) {
          content += this.result_add_group(data);
        } else {
          content += this.result_add_option(data);
        }
        if (options != null ? options.first : void 0) {
          if (data.selected &amp;&amp; this.is_multiple) {
            this.choice_build(data);
          } else if (data.selected &amp;&amp; !this.is_multiple) {
            this.single_set_selected_text(data.text);
          }
        }
      }
      return content;
    };

    AbstractChosen.prototype.result_add_option = function(option) {
      var classes, option_el;
      if (!option.search_match) {
        return &apos;&apos;;
      }
      if (!this.include_option_in_results(option)) {
        return &apos;&apos;;
      }
      classes = [];
      if (!option.disabled &amp;&amp; !(option.selected &amp;&amp; this.is_multiple)) {
        classes.push(&quot;active-result&quot;);
      }
      if (option.disabled &amp;&amp; !(option.selected &amp;&amp; this.is_multiple)) {
        classes.push(&quot;disabled-result&quot;);
      }
      if (option.selected) {
        classes.push(&quot;result-selected&quot;);
      }
      if (option.group_array_index != null) {
        classes.push(&quot;group-option&quot;);
      }
      if (option.classes !== &quot;&quot;) {
        classes.push(option.classes);
      }
      option_el = document.createElement(&quot;li&quot;);
      option_el.className = classes.join(&quot; &quot;);
      option_el.style.cssText = option.style;
      option_el.setAttribute(&quot;data-option-array-index&quot;, option.array_index);
      option_el.innerHTML = option.search_text;
      return this.outerHTML(option_el);
    };

    AbstractChosen.prototype.result_add_group = function(group) {
      var classes, group_el;
      if (!(group.search_match || group.group_match)) {
        return &apos;&apos;;
      }
      if (!(group.active_options &gt; 0)) {
        return &apos;&apos;;
      }
      classes = [];
      classes.push(&quot;group-result&quot;);
      if (group.classes) {
        classes.push(group.classes);
      }
      group_el = document.createElement(&quot;li&quot;);
      group_el.className = classes.join(&quot; &quot;);
      group_el.innerHTML = group.search_text;
      return this.outerHTML(group_el);
    };

    AbstractChosen.prototype.results_update_field = function() {
      this.set_default_text();
      if (!this.is_multiple) {
        this.results_reset_cleanup();
      }
      this.result_clear_highlight();
      this.results_build();
      if (this.results_showing) {
        return this.winnow_results();
      }
    };

    AbstractChosen.prototype.reset_single_select_options = function() {
      var result, _i, _len, _ref, _results;
      _ref = this.results_data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        result = _ref[_i];
        if (result.selected) {
          _results.push(result.selected = false);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    AbstractChosen.prototype.results_toggle = function() {
      if (this.results_showing) {
        return this.results_hide();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.results_search = function(evt) {
      if (this.results_showing) {
        return this.winnow_results();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.winnow_results = function() {
      var escapedSearchText, option, regex, results, results_group, searchText, startpos, text, zregex, _i, _len, _ref;
      this.no_results_clear();
      results = 0;
      searchText = this.get_search_text();
      escapedSearchText = searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, &quot;\\$&amp;&quot;);

      ///////////////////////////////////////////////////////////////
      // CHANGED
      // zregex = new RegExp(escapedSearchText, &apos;i&apos;);
      // regex = this.get_search_regex(escapedSearchText);
      var $$regexs = [];
      var $$list = escapedSearchText.split(&quot;\\ &quot;);
      for (var $$i = 0; $$i &lt; $$list.length; $$i++)
        $$regexs.push(new RegExp($$list[$$i],&apos;i&apos;));
      ///////////////////////////////////////////////////////////////

      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        option = _ref[_i];
        option.search_match = false;
        results_group = null;
        if (this.include_option_in_results(option)) {
          if (option.group) {
            option.group_match = false;
            option.active_options = 0;
          }
          if ((option.group_array_index != null) &amp;&amp; this.results_data[option.group_array_index]) {
            results_group = this.results_data[option.group_array_index];
            if (results_group.active_options === 0 &amp;&amp; results_group.search_match) {
              results += 1;
            }
            results_group.active_options += 1;
          }
          if (!(option.group &amp;&amp; !this.group_search)) {
            option.search_text = option.group ? option.label : option.text;

            /////////////////////////////////////////////////////////
            // CHANGED
            // option.search_match = this.search_string_match(option.search_text, regex);
            option.search_match = true;
            for (var $$i = 0; $$i &lt; $$regexs.length; $$i++)
              option.search_match = option.search_match &amp;&amp; $$regexs[$$i].test(option.search_text);
            /////////////////////////////////////////////////////////

            if (option.search_match &amp;&amp; !option.group) {
              results += 1;
            }
            if (option.search_match) {
              if (searchText.length) {

                /////////////////////////////////////////////////////
                // CHANGED
                // startpos = option.search_text.search(zregex);
                // text = option.search_text.substr(0, startpos + searchText.length) + &apos;&lt;/em&gt;&apos; + option.search_text.substr(startpos + searchText.length);
                // option.search_text = text.substr(0, startpos) + &apos;&lt;em&gt;&apos; + text.substr(startpos);
                var $$done = &quot;&quot;;
                var $$todo = option.search_text;
                var $$zregex = new RegExp($$list.join(&quot;|&quot;), &quot;i&quot;);
                while ($$todo != &quot;&quot;) {
                  var $$i = $$zregex.exec($$todo);
                  if ($$i == null) {$$done = $$done + $$todo; $$todo = &quot;&quot;; break;}
                  $$done = $$done + $$todo.substr(0, $$i.index) + &quot;&lt;em&gt;&quot; + $$todo.substr($$i.index, $$i[0].length) + &quot;&lt;/em&gt;&quot;;
                  $$todo = $$todo.substr($$i.index + $$i[0].length);
                }
                option.search_text = $$done;
                /////////////////////////////////////////////////////

              }
              if (results_group != null) {
                results_group.group_match = true;
              }
            } else if ((option.group_array_index != null) &amp;&amp; this.results_data[option.group_array_index].search_match) {
              option.search_match = true;
            }
          }
        }
      }
      this.result_clear_highlight();
      if (results &lt; 1 &amp;&amp; searchText.length) {
        this.update_results_content(&quot;&quot;);
        return this.no_results(searchText);
      } else {
        this.update_results_content(this.results_option_build());
        return this.winnow_results_set_highlight();
      }
    };

    AbstractChosen.prototype.get_search_regex = function(escaped_search_string) {
      var regex_anchor;
      regex_anchor = this.search_contains ? &quot;&quot; : &quot;^&quot;;
      return new RegExp(regex_anchor + escaped_search_string, &apos;i&apos;);
    };

    AbstractChosen.prototype.search_string_match = function(search_string, regex) {
      var part, parts, _i, _len;
      if (regex.test(search_string)) {
        return true;
      } else if (this.enable_split_word_search &amp;&amp; (search_string.indexOf(&quot; &quot;) &gt;= 0 || search_string.indexOf(&quot;[&quot;) === 0)) {
        parts = search_string.replace(/\[|\]/g, &quot;&quot;).split(&quot; &quot;);
        if (parts.length) {
          for (_i = 0, _len = parts.length; _i &lt; _len; _i++) {
            part = parts[_i];
            if (regex.test(part)) {
              return true;
            }
          }
        }
      }
    };

    AbstractChosen.prototype.choices_count = function() {
      var option, _i, _len, _ref;
      if (this.selected_option_count != null) {
        return this.selected_option_count;
      }
      this.selected_option_count = 0;
      _ref = this.form_field.options;
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        option = _ref[_i];
        if (option.selected) {
          this.selected_option_count += 1;
        }
      }
      return this.selected_option_count;
    };

    AbstractChosen.prototype.choices_click = function(evt) {
      evt.preventDefault();
      if (!(this.results_showing || this.is_disabled)) {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.keyup_checker = function(evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      switch (stroke) {
        case 8:
          if (this.is_multiple &amp;&amp; this.backstroke_length &lt; 1 &amp;&amp; this.choices_count() &gt; 0) {
            return this.keydown_backstroke();
          } else if (!this.pending_backstroke) {
            this.result_clear_highlight();
            return this.results_search();
          }
          break;
        case 13:
          evt.preventDefault();
          if (this.results_showing) {
            return this.result_select(evt);
          }
          break;
        case 27:
          if (this.results_showing) {
            this.results_hide();
          }
          return true;
        case 9:
        case 38:
        case 40:
        case 16:
        case 91:
        case 17:
          break;
        default:
          return this.results_search();
      }
    };

    AbstractChosen.prototype.clipboard_event_checker = function(evt) {
      var _this = this;
      return setTimeout((function() {
        return _this.results_search();
      }), 50);
    };

    AbstractChosen.prototype.container_width = function() {
      if (this.options.width != null) {
        return this.options.width;
      } else {
        return &quot;&quot; + this.form_field.offsetWidth + &quot;px&quot;;
      }
    };

    AbstractChosen.prototype.include_option_in_results = function(option) {
      if (this.is_multiple &amp;&amp; (!this.display_selected_options &amp;&amp; option.selected)) {
        return false;
      }
      if (!this.display_disabled_options &amp;&amp; option.disabled) {
        return false;
      }
      if (option.empty) {
        return false;
      }
      return true;
    };

    AbstractChosen.prototype.search_results_touchstart = function(evt) {
      this.touch_started = true;
      return this.search_results_mouseover(evt);
    };

    AbstractChosen.prototype.search_results_touchmove = function(evt) {
      this.touch_started = false;
      return this.search_results_mouseout(evt);
    };

    AbstractChosen.prototype.search_results_touchend = function(evt) {
      if (this.touch_started) {
        return this.search_results_mouseup(evt);
      }
    };

    AbstractChosen.prototype.outerHTML = function(element) {
      var tmp;
      if (element.outerHTML) {
        return element.outerHTML;
      }
      tmp = document.createElement(&quot;div&quot;);
      tmp.appendChild(element);
      return tmp.innerHTML;
    };

    AbstractChosen.browser_is_supported = function() {
      if (window.navigator.appName === &quot;Microsoft Internet Explorer&quot;) {
        return document.documentMode &gt;= 8;
      }
      if (/iP(od|hone)/i.test(window.navigator.userAgent)) {
        return false;
      }
      if (/Android/i.test(window.navigator.userAgent)) {
        if (/Mobile/i.test(window.navigator.userAgent)) {
          return false;
        }
      }
      return true;
    };

    AbstractChosen.default_multiple_text = &quot;Select Some Options&quot;;

    AbstractChosen.default_single_text = &quot;Select an Option&quot;;

    AbstractChosen.default_no_result_text = &quot;No results match&quot;;

    return AbstractChosen;

  })();

  $ = jQuery;

  $.fn.extend({
    chosen: function(options) {
      if (!AbstractChosen.browser_is_supported()) {
        return this;
      }
      return this.each(function(input_field) {
        var $this, chosen;
        $this = $(this);
        chosen = $this.data(&apos;chosen&apos;);
        if (options === &apos;destroy&apos; &amp;&amp; chosen instanceof Chosen) {
          chosen.destroy();
        } else if (!(chosen instanceof Chosen)) {
          $this.data(&apos;chosen&apos;, new Chosen(this, options));
        }
      });
    }
  });

  Chosen = (function(_super) {
    __extends(Chosen, _super);

    function Chosen() {
      _ref = Chosen.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Chosen.prototype.setup = function() {
      this.form_field_jq = $(this.form_field);
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.is_rtl = this.form_field_jq.hasClass(&quot;chosen-rtl&quot;);
    };

    Chosen.prototype.set_up_html = function() {
      var container_classes, container_props;
      container_classes = [&quot;chosen-container&quot;];
      container_classes.push(&quot;chosen-container-&quot; + (this.is_multiple ? &quot;multi&quot; : &quot;single&quot;));
      if (this.inherit_select_classes &amp;&amp; this.form_field.className) {
        container_classes.push(this.form_field.className);
      }
      if (this.is_rtl) {
        container_classes.push(&quot;chosen-rtl&quot;);
      }
      container_props = {
        &apos;class&apos;: container_classes.join(&apos; &apos;),
        &apos;style&apos;: &quot;width: &quot; + (this.container_width()) + &quot;;&quot;,
        &apos;title&apos;: this.form_field.title
      };
      if (this.form_field.id.length) {
        container_props.id = this.form_field.id.replace(/[^\w]/g, &apos;_&apos;) + &quot;_chosen&quot;;
      }
      this.container = $(&quot;&lt;div /&gt;&quot;, container_props);
      if (this.is_multiple) {
        this.container.html(&apos;&lt;ul class=&quot;chosen-choices&quot;&gt;&lt;li class=&quot;search-field&quot;&gt;&lt;input type=&quot;text&quot; value=&quot;&apos; + this.default_text + &apos;&quot; class=&quot;default&quot; autocomplete=&quot;off&quot; style=&quot;width:25px;&quot; /&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;chosen-drop&quot;&gt;&lt;ul class=&quot;chosen-results&quot;&gt;&lt;/ul&gt;&lt;/div&gt;&apos;);
      } else {
        this.container.html(&apos;&lt;a class=&quot;chosen-single chosen-default&quot; tabindex=&quot;-1&quot;&gt;&lt;span&gt;&apos; + this.default_text + &apos;&lt;/span&gt;&lt;div&gt;&lt;b&gt;&lt;/b&gt;&lt;/div&gt;&lt;/a&gt;&lt;div class=&quot;chosen-drop&quot;&gt;&lt;div class=&quot;chosen-search&quot;&gt;&lt;input type=&quot;text&quot; autocomplete=&quot;off&quot; /&gt;&lt;/div&gt;&lt;ul class=&quot;chosen-results&quot;&gt;&lt;/ul&gt;&lt;/div&gt;&apos;);
      }
      this.form_field_jq.hide().after(this.container);
      this.dropdown = this.container.find(&apos;div.chosen-drop&apos;).first();
      this.search_field = this.container.find(&apos;input&apos;).first();
      this.search_results = this.container.find(&apos;ul.chosen-results&apos;).first();
      this.search_field_scale();
      this.search_no_results = this.container.find(&apos;li.no-results&apos;).first();
      if (this.is_multiple) {
        this.search_choices = this.container.find(&apos;ul.chosen-choices&apos;).first();
        this.search_container = this.container.find(&apos;li.search-field&apos;).first();
      } else {
        this.search_container = this.container.find(&apos;div.chosen-search&apos;).first();
        this.selected_item = this.container.find(&apos;.chosen-single&apos;).first();
      }
      this.results_build();
      this.set_tab_index();
      return this.set_label_behavior();
    };

    Chosen.prototype.on_ready = function() {
      return this.form_field_jq.trigger(&quot;chosen:ready&quot;, {
        chosen: this
      });
    };

    Chosen.prototype.register_observers = function() {
      var _this = this;
      this.container.bind(&apos;touchstart.chosen&apos;, function(evt) {
        _this.container_mousedown(evt);
      });
      this.container.bind(&apos;touchend.chosen&apos;, function(evt) {
        _this.container_mouseup(evt);
      });
      this.container.bind(&apos;mousedown.chosen&apos;, function(evt) {
        _this.container_mousedown(evt);
      });
      this.container.bind(&apos;mouseup.chosen&apos;, function(evt) {
        _this.container_mouseup(evt);
      });
      this.container.bind(&apos;mouseenter.chosen&apos;, function(evt) {
        _this.mouse_enter(evt);
      });
      this.container.bind(&apos;mouseleave.chosen&apos;, function(evt) {
        _this.mouse_leave(evt);
      });
      this.search_results.bind(&apos;mouseup.chosen&apos;, function(evt) {
        _this.search_results_mouseup(evt);
      });
      this.search_results.bind(&apos;mouseover.chosen&apos;, function(evt) {
        _this.search_results_mouseover(evt);
      });
      this.search_results.bind(&apos;mouseout.chosen&apos;, function(evt) {
        _this.search_results_mouseout(evt);
      });
      this.search_results.bind(&apos;mousewheel.chosen DOMMouseScroll.chosen&apos;, function(evt) {
        _this.search_results_mousewheel(evt);
      });
      this.search_results.bind(&apos;touchstart.chosen&apos;, function(evt) {
        _this.search_results_touchstart(evt);
      });
      this.search_results.bind(&apos;touchmove.chosen&apos;, function(evt) {
        _this.search_results_touchmove(evt);
      });
      this.search_results.bind(&apos;touchend.chosen&apos;, function(evt) {
        _this.search_results_touchend(evt);
      });
      this.form_field_jq.bind(&quot;chosen:updated.chosen&quot;, function(evt) {
        _this.results_update_field(evt);
      });
      this.form_field_jq.bind(&quot;chosen:activate.chosen&quot;, function(evt) {
        _this.activate_field(evt);
      });
      this.form_field_jq.bind(&quot;chosen:open.chosen&quot;, function(evt) {
        _this.container_mousedown(evt);
      });
      this.form_field_jq.bind(&quot;chosen:close.chosen&quot;, function(evt) {
        _this.input_blur(evt);
      });
      this.search_field.bind(&apos;blur.chosen&apos;, function(evt) {
        _this.input_blur(evt);
      });
      this.search_field.bind(&apos;keyup.chosen&apos;, function(evt) {
        _this.keyup_checker(evt);
      });
      this.search_field.bind(&apos;keydown.chosen&apos;, function(evt) {
        _this.keydown_checker(evt);
      });
      this.search_field.bind(&apos;focus.chosen&apos;, function(evt) {
        _this.input_focus(evt);
      });
      this.search_field.bind(&apos;cut.chosen&apos;, function(evt) {
        _this.clipboard_event_checker(evt);
      });
      this.search_field.bind(&apos;paste.chosen&apos;, function(evt) {
        _this.clipboard_event_checker(evt);
      });
      if (this.is_multiple) {
        return this.search_choices.bind(&apos;click.chosen&apos;, function(evt) {
          _this.choices_click(evt);
        });
      } else {
        return this.container.bind(&apos;click.chosen&apos;, function(evt) {
          evt.preventDefault();
        });
      }
    };

    Chosen.prototype.destroy = function() {
      $(this.container[0].ownerDocument).unbind(&quot;click.chosen&quot;, this.click_test_action);
      if (this.search_field[0].tabIndex) {
        this.form_field_jq[0].tabIndex = this.search_field[0].tabIndex;
      }
      this.container.remove();
      this.form_field_jq.removeData(&apos;chosen&apos;);
      return this.form_field_jq.show();
    };

    Chosen.prototype.search_field_disabled = function() {
      this.is_disabled = this.form_field_jq[0].disabled;
      if (this.is_disabled) {
        this.container.addClass(&apos;chosen-disabled&apos;);
        this.search_field[0].disabled = true;
        if (!this.is_multiple) {
          this.selected_item.unbind(&quot;focus.chosen&quot;, this.activate_action);
        }
        return this.close_field();
      } else {
        this.container.removeClass(&apos;chosen-disabled&apos;);
        this.search_field[0].disabled = false;
        if (!this.is_multiple) {
          return this.selected_item.bind(&quot;focus.chosen&quot;, this.activate_action);
        }
      }
    };

    Chosen.prototype.container_mousedown = function(evt) {
      if (!this.is_disabled) {
        if (evt &amp;&amp; evt.type === &quot;mousedown&quot; &amp;&amp; !this.results_showing) {
          evt.preventDefault();
        }
        if (!((evt != null) &amp;&amp; ($(evt.target)).hasClass(&quot;search-choice-close&quot;))) {
          if (!this.active_field) {
            if (this.is_multiple) {
              this.search_field.val(&quot;&quot;);
            }
            $(this.container[0].ownerDocument).bind(&apos;click.chosen&apos;, this.click_test_action);
            this.results_show();
          } else if (!this.is_multiple &amp;&amp; evt &amp;&amp; (($(evt.target)[0] === this.selected_item[0]) || $(evt.target).parents(&quot;a.chosen-single&quot;).length)) {
            evt.preventDefault();
            this.results_toggle();
          }
          return this.activate_field();
        }
      }
    };

    Chosen.prototype.container_mouseup = function(evt) {
      if (evt.target.nodeName === &quot;ABBR&quot; &amp;&amp; !this.is_disabled) {
        return this.results_reset(evt);
      }
    };

    Chosen.prototype.search_results_mousewheel = function(evt) {
      var delta;
      if (evt.originalEvent) {
        delta = evt.originalEvent.deltaY || -evt.originalEvent.wheelDelta || evt.originalEvent.detail;
      }
      if (delta != null) {
        evt.preventDefault();
        if (evt.type === &apos;DOMMouseScroll&apos;) {
          delta = delta * 40;
        }
        return this.search_results.scrollTop(delta + this.search_results.scrollTop());
      }
    };

    Chosen.prototype.blur_test = function(evt) {
      if (!this.active_field &amp;&amp; this.container.hasClass(&quot;chosen-container-active&quot;)) {
        return this.close_field();
      }
    };

    Chosen.prototype.close_field = function() {
      $(this.container[0].ownerDocument).unbind(&quot;click.chosen&quot;, this.click_test_action);
      this.active_field = false;
      this.results_hide();
      this.container.removeClass(&quot;chosen-container-active&quot;);
      this.clear_backstroke();
      this.show_search_field_default();
      return this.search_field_scale();
    };

    Chosen.prototype.activate_field = function() {
      this.container.addClass(&quot;chosen-container-active&quot;);
      this.active_field = true;
      this.search_field.val(this.search_field.val());
      return this.search_field.focus();
    };

    Chosen.prototype.test_active_click = function(evt) {
      var active_container;
      active_container = $(evt.target).closest(&apos;.chosen-container&apos;);
      if (active_container.length &amp;&amp; this.container[0] === active_container[0]) {
        return this.active_field = true;
      } else {
        return this.close_field();
      }
    };

    Chosen.prototype.results_build = function() {
      this.parsing = true;
      this.selected_option_count = null;
      this.results_data = SelectParser.select_to_array(this.form_field);
      if (this.is_multiple) {
        this.search_choices.find(&quot;li.search-choice&quot;).remove();
      } else if (!this.is_multiple) {
        this.single_set_selected_text();
        if (this.disable_search || this.form_field.options.length &lt;= this.disable_search_threshold) {
          this.search_field[0].readOnly = true;
          this.container.addClass(&quot;chosen-container-single-nosearch&quot;);
        } else {
          this.search_field[0].readOnly = false;
          this.container.removeClass(&quot;chosen-container-single-nosearch&quot;);
        }
      }
      this.update_results_content(this.results_option_build({
        first: true
      }));
      this.search_field_disabled();
      this.show_search_field_default();
      this.search_field_scale();
      return this.parsing = false;
    };

    Chosen.prototype.result_do_highlight = function(el) {
      var high_bottom, high_top, maxHeight, visible_bottom, visible_top;
      if (el.length) {
        this.result_clear_highlight();
        this.result_highlight = el;
        this.result_highlight.addClass(&quot;highlighted&quot;);
        maxHeight = parseInt(this.search_results.css(&quot;maxHeight&quot;), 10);
        visible_top = this.search_results.scrollTop();
        visible_bottom = maxHeight + visible_top;
        high_top = this.result_highlight.position().top + this.search_results.scrollTop();
        high_bottom = high_top + this.result_highlight.outerHeight();
        if (high_bottom &gt;= visible_bottom) {
          return this.search_results.scrollTop((high_bottom - maxHeight) &gt; 0 ? high_bottom - maxHeight : 0);
        } else if (high_top &lt; visible_top) {
          return this.search_results.scrollTop(high_top);
        }
      }
    };

    Chosen.prototype.result_clear_highlight = function() {
      if (this.result_highlight) {
        this.result_highlight.removeClass(&quot;highlighted&quot;);
      }
      return this.result_highlight = null;
    };

    Chosen.prototype.results_show = function() {
      if (this.is_multiple &amp;&amp; this.max_selected_options &lt;= this.choices_count()) {
        this.form_field_jq.trigger(&quot;chosen:maxselected&quot;, {
          chosen: this
        });
        return false;
      }
      this.container.addClass(&quot;chosen-with-drop&quot;);
      this.results_showing = true;
      this.search_field.focus();
      this.search_field.val(this.search_field.val());
      this.winnow_results();
      return this.form_field_jq.trigger(&quot;chosen:showing_dropdown&quot;, {
        chosen: this
      });
    };

    Chosen.prototype.update_results_content = function(content) {
      return this.search_results.html(content);
    };

    Chosen.prototype.results_hide = function() {
      if (this.results_showing) {
        this.result_clear_highlight();
        this.container.removeClass(&quot;chosen-with-drop&quot;);
        this.form_field_jq.trigger(&quot;chosen:hiding_dropdown&quot;, {
          chosen: this
        });
      }
      return this.results_showing = false;
    };

    Chosen.prototype.set_tab_index = function(el) {
      var ti;
      if (this.form_field.tabIndex) {
        ti = this.form_field.tabIndex;
        this.form_field.tabIndex = -1;
        return this.search_field[0].tabIndex = ti;
      }
    };

    Chosen.prototype.set_label_behavior = function() {
      var _this = this;
      this.form_field_label = this.form_field_jq.parents(&quot;label&quot;);
      if (!this.form_field_label.length &amp;&amp; this.form_field.id.length) {
        this.form_field_label = $(&quot;label[for=&apos;&quot; + this.form_field.id + &quot;&apos;]&quot;);
      }
      if (this.form_field_label.length &gt; 0) {
        return this.form_field_label.bind(&apos;click.chosen&apos;, function(evt) {
          if (_this.is_multiple) {
            return _this.container_mousedown(evt);
          } else {
            return _this.activate_field();
          }
        });
      }
    };

    Chosen.prototype.show_search_field_default = function() {
      if (this.is_multiple &amp;&amp; this.choices_count() &lt; 1 &amp;&amp; !this.active_field) {
        this.search_field.val(this.default_text);
        return this.search_field.addClass(&quot;default&quot;);
      } else {
        this.search_field.val(&quot;&quot;);
        return this.search_field.removeClass(&quot;default&quot;);
      }
    };

    Chosen.prototype.search_results_mouseup = function(evt) {
      var target;
      target = $(evt.target).hasClass(&quot;active-result&quot;) ? $(evt.target) : $(evt.target).parents(&quot;.active-result&quot;).first();
      if (target.length) {
        this.result_highlight = target;
        this.result_select(evt);
        return this.search_field.focus();
      }
    };

    Chosen.prototype.search_results_mouseover = function(evt) {
      var target;
      target = $(evt.target).hasClass(&quot;active-result&quot;) ? $(evt.target) : $(evt.target).parents(&quot;.active-result&quot;).first();
      if (target) {
        return this.result_do_highlight(target);
      }
    };

    Chosen.prototype.search_results_mouseout = function(evt) {
      if ($(evt.target).hasClass(&quot;active-result&quot; || $(evt.target).parents(&apos;.active-result&apos;).first())) {
        return this.result_clear_highlight();
      }
    };

    Chosen.prototype.choice_build = function(item) {
      var choice, close_link,
        _this = this;
      choice = $(&apos;&lt;li /&gt;&apos;, {
        &quot;class&quot;: &quot;search-choice&quot;
      }).html(&quot;&lt;span&gt;&quot; + item.html + &quot;&lt;/span&gt;&quot;);
      if (item.disabled) {
        choice.addClass(&apos;search-choice-disabled&apos;);
      } else {
        close_link = $(&apos;&lt;a /&gt;&apos;, {
          &quot;class&quot;: &apos;search-choice-close&apos;,
          &apos;data-option-array-index&apos;: item.array_index
        });
        close_link.bind(&apos;click.chosen&apos;, function(evt) {
          return _this.choice_destroy_link_click(evt);
        });
        choice.append(close_link);
      }
      return this.search_container.before(choice);
    };

    Chosen.prototype.choice_destroy_link_click = function(evt) {
      evt.preventDefault();
      evt.stopPropagation();
      if (!this.is_disabled) {
        return this.choice_destroy($(evt.target));
      }
    };

    Chosen.prototype.choice_destroy = function(link) {
      if (this.result_deselect(link[0].getAttribute(&quot;data-option-array-index&quot;))) {
        this.show_search_field_default();
        if (this.is_multiple &amp;&amp; this.choices_count() &gt; 0 &amp;&amp; this.search_field.val().length &lt; 1) {
          this.results_hide();
        }
        link.parents(&apos;li&apos;).first().remove();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.results_reset = function() {
      this.reset_single_select_options();
      this.form_field.options[0].selected = true;
      this.single_set_selected_text();
      this.show_search_field_default();
      this.results_reset_cleanup();
      this.form_field_jq.trigger(&quot;change&quot;);
      if (this.active_field) {
        return this.results_hide();
      }
    };

    Chosen.prototype.results_reset_cleanup = function() {
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.selected_item.find(&quot;abbr&quot;).remove();
    };

    Chosen.prototype.result_select = function(evt) {
      var high, item;
      if (this.result_highlight) {
        high = this.result_highlight;
        this.result_clear_highlight();
        if (this.is_multiple &amp;&amp; this.max_selected_options &lt;= this.choices_count()) {
          this.form_field_jq.trigger(&quot;chosen:maxselected&quot;, {
            chosen: this
          });
          return false;
        }
        if (this.is_multiple) {
          high.removeClass(&quot;active-result&quot;);
        } else {
          this.reset_single_select_options();
        }
        item = this.results_data[high[0].getAttribute(&quot;data-option-array-index&quot;)];
        item.selected = true;
        this.form_field.options[item.options_index].selected = true;
        this.selected_option_count = null;
        if (this.is_multiple) {
          this.choice_build(item);
        } else {
          this.single_set_selected_text(item.text);
        }
        if (!((evt.metaKey || evt.ctrlKey) &amp;&amp; this.is_multiple)) {
          this.results_hide();
        }
        this.search_field.val(&quot;&quot;);
        if (this.is_multiple || this.form_field.selectedIndex !== this.current_selectedIndex) {
          this.form_field_jq.trigger(&quot;change&quot;, {
            &apos;selected&apos;: this.form_field.options[item.options_index].value
          });
        }
        this.current_selectedIndex = this.form_field.selectedIndex;
        return this.search_field_scale();
      }
    };

    Chosen.prototype.single_set_selected_text = function(text) {
      if (text == null) {
        text = this.default_text;
      }
      if (text === this.default_text) {
        this.selected_item.addClass(&quot;chosen-default&quot;);
      } else {
        this.single_deselect_control_build();
        this.selected_item.removeClass(&quot;chosen-default&quot;);
      }
      return this.selected_item.find(&quot;span&quot;).text(text);
    };

    Chosen.prototype.result_deselect = function(pos) {
      var result_data;
      result_data = this.results_data[pos];
      if (!this.form_field.options[result_data.options_index].disabled) {
        result_data.selected = false;
        this.form_field.options[result_data.options_index].selected = false;
        this.selected_option_count = null;
        this.result_clear_highlight();
        if (this.results_showing) {
          this.winnow_results();
        }
        this.form_field_jq.trigger(&quot;change&quot;, {
          deselected: this.form_field.options[result_data.options_index].value
        });
        this.search_field_scale();
        return true;
      } else {
        return false;
      }
    };

    Chosen.prototype.single_deselect_control_build = function() {
      if (!this.allow_single_deselect) {
        return;
      }
      if (!this.selected_item.find(&quot;abbr&quot;).length) {
        this.selected_item.find(&quot;span&quot;).first().after(&quot;&lt;abbr class=\&quot;search-choice-close\&quot;&gt;&lt;/abbr&gt;&quot;);
      }
      return this.selected_item.addClass(&quot;chosen-single-with-deselect&quot;);
    };

    Chosen.prototype.get_search_text = function() {
      if (this.search_field.val() === this.default_text) {
        return &quot;&quot;;
      } else {
        return $(&apos;&lt;div/&gt;&apos;).text($.trim(this.search_field.val())).html();
      }
    };

    Chosen.prototype.winnow_results_set_highlight = function() {
      var do_high, selected_results;
      selected_results = !this.is_multiple ? this.search_results.find(&quot;.result-selected.active-result&quot;) : [];
      do_high = selected_results.length ? selected_results.first() : this.search_results.find(&quot;.active-result&quot;).first();
      if (do_high != null) {
        return this.result_do_highlight(do_high);
      }
    };

    Chosen.prototype.no_results = function(terms) {
      var no_results_html;
      no_results_html = $(&apos;&lt;li class=&quot;no-results&quot;&gt;&apos; + this.results_none_found + &apos; &quot;&lt;span&gt;&lt;/span&gt;&quot;&lt;/li&gt;&apos;);
      no_results_html.find(&quot;span&quot;).first().html(terms);
      this.search_results.append(no_results_html);
      return this.form_field_jq.trigger(&quot;chosen:no_results&quot;, {
        chosen: this
      });
    };

    Chosen.prototype.no_results_clear = function() {
      return this.search_results.find(&quot;.no-results&quot;).remove();
    };

    Chosen.prototype.keydown_arrow = function() {
      var next_sib;
      if (this.results_showing &amp;&amp; this.result_highlight) {
        next_sib = this.result_highlight.nextAll(&quot;li.active-result&quot;).first();
        if (next_sib) {
          return this.result_do_highlight(next_sib);
        }
      } else {
        return this.results_show();
      }
    };

    Chosen.prototype.keyup_arrow = function() {
      var prev_sibs;
      if (!this.results_showing &amp;&amp; !this.is_multiple) {
        return this.results_show();
      } else if (this.result_highlight) {
        prev_sibs = this.result_highlight.prevAll(&quot;li.active-result&quot;);
        if (prev_sibs.length) {
          return this.result_do_highlight(prev_sibs.first());
        } else {
          if (this.choices_count() &gt; 0) {
            this.results_hide();
          }
          return this.result_clear_highlight();
        }
      }
    };

    Chosen.prototype.keydown_backstroke = function() {
      var next_available_destroy;
      if (this.pending_backstroke) {
        this.choice_destroy(this.pending_backstroke.find(&quot;a&quot;).first());
        return this.clear_backstroke();
      } else {
        next_available_destroy = this.search_container.siblings(&quot;li.search-choice&quot;).last();
        if (next_available_destroy.length &amp;&amp; !next_available_destroy.hasClass(&quot;search-choice-disabled&quot;)) {
          this.pending_backstroke = next_available_destroy;
          if (this.single_backstroke_delete) {
            return this.keydown_backstroke();
          } else {
            return this.pending_backstroke.addClass(&quot;search-choice-focus&quot;);
          }
        }
      }
    };

    Chosen.prototype.clear_backstroke = function() {
      if (this.pending_backstroke) {
        this.pending_backstroke.removeClass(&quot;search-choice-focus&quot;);
      }
      return this.pending_backstroke = null;
    };

    Chosen.prototype.keydown_checker = function(evt) {
      var stroke, _ref1;
      stroke = (_ref1 = evt.which) != null ? _ref1 : evt.keyCode;
      this.search_field_scale();
      if (stroke !== 8 &amp;&amp; this.pending_backstroke) {
        this.clear_backstroke();
      }
      switch (stroke) {
        case 8:
          this.backstroke_length = this.search_field.val().length;
          break;
        case 9:
          if (this.results_showing &amp;&amp; !this.is_multiple) {
            this.result_select(evt);
          }
          this.mouse_on_container = false;
          break;
        case 13:
          if (this.results_showing) {
            evt.preventDefault();
          }
          break;
        case 32:
          if (this.disable_search) {
            evt.preventDefault();
          }
          break;
        case 38:
          evt.preventDefault();
          this.keyup_arrow();
          break;
        case 40:
          evt.preventDefault();
          this.keydown_arrow();
          break;
      }
    };

    Chosen.prototype.search_field_scale = function() {
      var div, f_width, h, style, style_block, styles, w, _i, _len;
      if (this.is_multiple) {
        h = 0;
        w = 0;
        style_block = &quot;position:absolute; left: -1000px; top: -1000px; display:none;&quot;;
        styles = [&apos;font-size&apos;, &apos;font-style&apos;, &apos;font-weight&apos;, &apos;font-family&apos;, &apos;line-height&apos;, &apos;text-transform&apos;, &apos;letter-spacing&apos;];
        for (_i = 0, _len = styles.length; _i &lt; _len; _i++) {
          style = styles[_i];
          style_block += style + &quot;:&quot; + this.search_field.css(style) + &quot;;&quot;;
        }
        div = $(&apos;&lt;div /&gt;&apos;, {
          &apos;style&apos;: style_block
        });
        div.text(this.search_field.val());
        $(&apos;body&apos;).append(div);
        w = div.width() + 25;
        div.remove();
        f_width = this.container.outerWidth();
        if (w &gt; f_width - 10) {
          w = f_width - 10;
        }
        return this.search_field.css({
          &apos;width&apos;: w + &apos;px&apos;
        });
      }
    };

    return Chosen;

  })(AbstractChosen);

}).call(this);</file><file path="html/plugin/chosen.css">/*!
Chosen, a Select Box Enhancer for jQuery and Prototype
by Patrick Filler for Harvest, http://getharvest.com

Version 1.3.0
Full source at https://github.com/harvesthq/chosen
Copyright (c) 2011-2014 Harvest http://getharvest.com

MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
This file is generated by `grunt build`, do not edit it by hand.
*/

/* @group Base */
.chosen-container {
  position: relative;
  display: inline-block;
  vertical-align: middle;
  font-size: 13px;
  zoom: 1;
  *display: inline;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}
.chosen-container * {
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}
.chosen-container .chosen-drop {
  position: absolute;
  top: 100%;
  left: -9999px;
  z-index: 1010;
  width: 100%;
  border: 1px solid #aaa;
  border-top: 0;
  background: #fff;
  box-shadow: 0 4px 5px rgba(0, 0, 0, 0.15);
}
.chosen-container.chosen-with-drop .chosen-drop {
  left: 0;
}
.chosen-container a {
  cursor: pointer;
}

/* @end */
/* @group Single Chosen */
.chosen-container-single .chosen-single {
  position: relative;
  display: block;
  overflow: hidden;
  padding: 0 0 0 8px;
  height: 25px;
  border: 1px solid #aaa;
  border-radius: 5px;
  background-color: #fff;
  background: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(20%, #ffffff), color-stop(50%, #f6f6f6), color-stop(52%, #eeeeee), color-stop(100%, #f4f4f4));
  background: -webkit-linear-gradient(top, #ffffff 20%, #f6f6f6 50%, #eeeeee 52%, #f4f4f4 100%);
  background: -moz-linear-gradient(top, #ffffff 20%, #f6f6f6 50%, #eeeeee 52%, #f4f4f4 100%);
  background: -o-linear-gradient(top, #ffffff 20%, #f6f6f6 50%, #eeeeee 52%, #f4f4f4 100%);
  background: linear-gradient(top, #ffffff 20%, #f6f6f6 50%, #eeeeee 52%, #f4f4f4 100%);
  background-clip: padding-box;
  box-shadow: 0 0 3px white inset, 0 1px 1px rgba(0, 0, 0, 0.1);
  color: #444;
  text-decoration: none;
  white-space: nowrap;
  line-height: 24px;
}
.chosen-container-single .chosen-default {
  color: #999;
}
.chosen-container-single .chosen-single span {
  display: block;
  overflow: hidden;
  margin-right: 26px;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.chosen-container-single .chosen-single-with-deselect span {
  margin-right: 38px;
}
.chosen-container-single .chosen-single abbr {
  position: absolute;
  top: 6px;
  right: 26px;
  display: block;
  width: 12px;
  height: 12px;
  background: url(&apos;chosen-sprite.png&apos;) -42px 1px no-repeat;
  font-size: 1px;
}
.chosen-container-single .chosen-single abbr:hover {
  background-position: -42px -10px;
}
.chosen-container-single.chosen-disabled .chosen-single abbr:hover {
  background-position: -42px -10px;
}
.chosen-container-single .chosen-single div {
  position: absolute;
  top: 0;
  right: 0;
  display: block;
  width: 18px;
  height: 100%;
}
.chosen-container-single .chosen-single div b {
  display: block;
  width: 100%;
  height: 100%;
  background: url(&apos;chosen-sprite.png&apos;) no-repeat 0px 2px;
}
.chosen-container-single .chosen-search {
  position: relative;
  z-index: 1010;
  margin: 0;
  padding: 3px 4px;
  white-space: nowrap;
}
.chosen-container-single .chosen-search input[type=&quot;text&quot;] {
  margin: 1px 0;
  padding: 4px 20px 4px 5px;
  width: 100%;
  height: auto;
  outline: 0;
  border: 1px solid #aaa;
  background: white url(&apos;chosen-sprite.png&apos;) no-repeat 100% -20px;
  background: url(&apos;chosen-sprite.png&apos;) no-repeat 100% -20px;
  font-size: 1em;
  font-family: sans-serif;
  line-height: normal;
  border-radius: 0;
}
.chosen-container-single .chosen-drop {
  margin-top: -1px;
  border-radius: 0 0 4px 4px;
  background-clip: padding-box;
}
.chosen-container-single.chosen-container-single-nosearch .chosen-search {
  position: absolute;
  left: -9999px;
}

/* @end */
/* @group Results */
.chosen-container .chosen-results {
  color: #444;
  position: relative;
  overflow-x: hidden;
  overflow-y: auto;
  margin: 0 4px 4px 0;
  padding: 0 0 0 4px;
  max-height: 240px;
  -webkit-overflow-scrolling: touch;
}
.chosen-container .chosen-results li {
  display: none;
  margin: 0;
  padding: 5px 6px;
  list-style: none;
  line-height: 15px;
  word-wrap: break-word;
  -webkit-touch-callout: none;
}
.chosen-container .chosen-results li.active-result {
  display: list-item;
  cursor: pointer;
}
.chosen-container .chosen-results li.disabled-result {
  display: list-item;
  color: #ccc;
  cursor: default;
}
.chosen-container .chosen-results li.highlighted {
  background-color: #3875d7;
  background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(20%, #3875d7), color-stop(90%, #2a62bc));
  background-image: -webkit-linear-gradient(#3875d7 20%, #2a62bc 90%);
  background-image: -moz-linear-gradient(#3875d7 20%, #2a62bc 90%);
  background-image: -o-linear-gradient(#3875d7 20%, #2a62bc 90%);
  background-image: linear-gradient(#3875d7 20%, #2a62bc 90%);
  color: #fff;
}
.chosen-container .chosen-results li.no-results {
  color: #777;
  display: list-item;
  background: #f4f4f4;
}
.chosen-container .chosen-results li.group-result {
  display: list-item;
  font-weight: bold;
  cursor: default;
}
.chosen-container .chosen-results li.group-option {
  padding-left: 15px;
}
.chosen-container .chosen-results li em {
  font-style: normal;
  text-decoration: underline;
}

/* @end */
/* @group Multi Chosen */
.chosen-container-multi .chosen-choices {
  position: relative;
  overflow: hidden;
  margin: 0;
  padding: 0 5px;
  width: 100%;
  height: auto !important;
  height: 1%;
  border: 1px solid #aaa;
  background-color: #fff;
  background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(1%, #eeeeee), color-stop(15%, #ffffff));
  background-image: -webkit-linear-gradient(#eeeeee 1%, #ffffff 15%);
  background-image: -moz-linear-gradient(#eeeeee 1%, #ffffff 15%);
  background-image: -o-linear-gradient(#eeeeee 1%, #ffffff 15%);
  background-image: linear-gradient(#eeeeee 1%, #ffffff 15%);
  cursor: text;
}
.chosen-container-multi .chosen-choices li {
  float: left;
  list-style: none;
}
.chosen-container-multi .chosen-choices li.search-field {
  margin: 0;
  padding: 0;
  white-space: nowrap;
}
.chosen-container-multi .chosen-choices li.search-field input[type=&quot;text&quot;] {
  margin: 1px 0;
  padding: 0;
  height: 25px;
  outline: 0;
  border: 0 !important;
  background: transparent !important;
  box-shadow: none;
  color: #999;
  font-size: 100%;
  font-family: sans-serif;
  line-height: normal;
  border-radius: 0;
}
.chosen-container-multi .chosen-choices li.search-choice {
  position: relative;
  margin: 3px 5px 3px 0;
  padding: 3px 20px 3px 5px;
  border: 1px solid #aaa;
  max-width: 100%;
  border-radius: 3px;
  background-color: #eeeeee;
  background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(20%, #f4f4f4), color-stop(50%, #f0f0f0), color-stop(52%, #e8e8e8), color-stop(100%, #eeeeee));
  background-image: -webkit-linear-gradient(#f4f4f4 20%, #f0f0f0 50%, #e8e8e8 52%, #eeeeee 100%);
  background-image: -moz-linear-gradient(#f4f4f4 20%, #f0f0f0 50%, #e8e8e8 52%, #eeeeee 100%);
  background-image: -o-linear-gradient(#f4f4f4 20%, #f0f0f0 50%, #e8e8e8 52%, #eeeeee 100%);
  background-image: linear-gradient(#f4f4f4 20%, #f0f0f0 50%, #e8e8e8 52%, #eeeeee 100%);
  background-size: 100% 19px;
  background-repeat: repeat-x;
  background-clip: padding-box;
  box-shadow: 0 0 2px white inset, 0 1px 0 rgba(0, 0, 0, 0.05);
  color: #333;
  line-height: 13px;
  cursor: default;
}
.chosen-container-multi .chosen-choices li.search-choice span {
  word-wrap: break-word;
}
.chosen-container-multi .chosen-choices li.search-choice .search-choice-close {
  position: absolute;
  top: 4px;
  right: 3px;
  display: block;
  width: 12px;
  height: 12px;
  background: url(&apos;chosen-sprite.png&apos;) -42px 1px no-repeat;
  font-size: 1px;
}
.chosen-container-multi .chosen-choices li.search-choice .search-choice-close:hover {
  background-position: -42px -10px;
}
.chosen-container-multi .chosen-choices li.search-choice-disabled {
  padding-right: 5px;
  border: 1px solid #ccc;
  background-color: #e4e4e4;
  background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(20%, #f4f4f4), color-stop(50%, #f0f0f0), color-stop(52%, #e8e8e8), color-stop(100%, #eeeeee));
  background-image: -webkit-linear-gradient(top, #f4f4f4 20%, #f0f0f0 50%, #e8e8e8 52%, #eeeeee 100%);
  background-image: -moz-linear-gradient(top, #f4f4f4 20%, #f0f0f0 50%, #e8e8e8 52%, #eeeeee 100%);
  background-image: -o-linear-gradient(top, #f4f4f4 20%, #f0f0f0 50%, #e8e8e8 52%, #eeeeee 100%);
  background-image: linear-gradient(top, #f4f4f4 20%, #f0f0f0 50%, #e8e8e8 52%, #eeeeee 100%);
  color: #666;
}
.chosen-container-multi .chosen-choices li.search-choice-focus {
  background: #d4d4d4;
}
.chosen-container-multi .chosen-choices li.search-choice-focus .search-choice-close {
  background-position: -42px -10px;
}
.chosen-container-multi .chosen-results {
  margin: 0;
  padding: 0;
}
.chosen-container-multi .chosen-drop .result-selected {
  display: list-item;
  color: #ccc;
  cursor: default;
}

/* @end */
/* @group Active  */
.chosen-container-active .chosen-single {
  border: 1px solid #5897fb;
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
}
.chosen-container-active.chosen-with-drop .chosen-single {
  border: 1px solid #aaa;
  -moz-border-radius-bottomright: 0;
  border-bottom-right-radius: 0;
  -moz-border-radius-bottomleft: 0;
  border-bottom-left-radius: 0;
  background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(20%, #eeeeee), color-stop(80%, #ffffff));
  background-image: -webkit-linear-gradient(#eeeeee 20%, #ffffff 80%);
  background-image: -moz-linear-gradient(#eeeeee 20%, #ffffff 80%);
  background-image: -o-linear-gradient(#eeeeee 20%, #ffffff 80%);
  background-image: linear-gradient(#eeeeee 20%, #ffffff 80%);
  box-shadow: 0 1px 0 #fff inset;
}
.chosen-container-active.chosen-with-drop .chosen-single div {
  border-left: none;
  background: transparent;
}
.chosen-container-active.chosen-with-drop .chosen-single div b {
  background-position: -18px 2px;
}
.chosen-container-active .chosen-choices {
  border: 1px solid #5897fb;
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
}
.chosen-container-active .chosen-choices li.search-field input[type=&quot;text&quot;] {
  color: #222 !important;
}

/* @end */
/* @group Disabled Support */
.chosen-disabled {
  opacity: 0.5 !important;
  cursor: default;
}
.chosen-disabled .chosen-single {
  cursor: default;
}
.chosen-disabled .chosen-choices .search-choice .search-choice-close {
  cursor: default;
}

/* @end */
/* @group Right to Left */
.chosen-rtl {
  text-align: right;
}
.chosen-rtl .chosen-single {
  overflow: visible;
  padding: 0 8px 0 0;
}
.chosen-rtl .chosen-single span {
  margin-right: 0;
  margin-left: 26px;
  direction: rtl;
}
.chosen-rtl .chosen-single-with-deselect span {
  margin-left: 38px;
}
.chosen-rtl .chosen-single div {
  right: auto;
  left: 3px;
}
.chosen-rtl .chosen-single abbr {
  right: auto;
  left: 26px;
}
.chosen-rtl .chosen-choices li {
  float: right;
}
.chosen-rtl .chosen-choices li.search-field input[type=&quot;text&quot;] {
  direction: rtl;
}
.chosen-rtl .chosen-choices li.search-choice {
  margin: 3px 5px 3px 0;
  padding: 3px 5px 3px 19px;
}
.chosen-rtl .chosen-choices li.search-choice .search-choice-close {
  right: auto;
  left: 4px;
}
.chosen-rtl.chosen-container-single-nosearch .chosen-search,
.chosen-rtl .chosen-drop {
  left: 9999px;
}
.chosen-rtl.chosen-container-single .chosen-results {
  margin: 0 0 4px 4px;
  padding: 0 4px 0 0;
}
.chosen-rtl .chosen-results li.group-option {
  padding-right: 15px;
  padding-left: 0;
}
.chosen-rtl.chosen-container-active.chosen-with-drop .chosen-single div {
  border-right: none;
}
.chosen-rtl .chosen-search input[type=&quot;text&quot;] {
  padding: 4px 5px 4px 20px;
  background: white url(&apos;chosen-sprite.png&apos;) no-repeat -30px -20px;
  background: url(&apos;chosen-sprite.png&apos;) no-repeat -30px -20px;
  direction: rtl;
}
.chosen-rtl.chosen-container-single .chosen-single div b {
  background-position: 6px 2px;
}
.chosen-rtl.chosen-container-single.chosen-with-drop .chosen-single div b {
  background-position: -12px 2px;
}

/* @end */
/* @group Retina compatibility */
@media only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min-resolution: 144dpi) {
  .chosen-rtl .chosen-search input[type=&quot;text&quot;],
  .chosen-container-single .chosen-single abbr,
  .chosen-container-single .chosen-single div b,
  .chosen-container-single .chosen-search input[type=&quot;text&quot;],
  .chosen-container-multi .chosen-choices .search-choice .search-choice-close,
  .chosen-container .chosen-results-scroll-down span,
  .chosen-container .chosen-results-scroll-up span {
    background-image: url(&apos;chosen-sprite@2x.png&apos;) !important;
    background-size: 52px 37px !important;
    background-repeat: no-repeat !important;
  }
}
/* @end */</file><file path="html/plugin/jquery-cookie.js">/**
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.cookie(&apos;the_cookie&apos;, &apos;the_value&apos;);
 * @desc Set the value of a cookie.
 * @example $.cookie(&apos;the_cookie&apos;, &apos;the_value&apos;, { expires: 7, path: &apos;/&apos;, domain: &apos;jquery.com&apos;, secure: true });
 * @desc Create a cookie with all available options.
 * @example $.cookie(&apos;the_cookie&apos;, &apos;the_value&apos;);
 * @desc Create a session cookie.
 * @example $.cookie(&apos;the_cookie&apos;, null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

/**
 * Get the value of a cookie with the given name.
 *
 * @example $.cookie(&apos;the_cookie&apos;);
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
jQuery.cookie = function(name, value, options) {
    if (typeof value != &apos;undefined&apos;) { // name and value given, set cookie
        options = options || {};
        if (value === null) {
            value = &apos;&apos;;
            options.expires = -1;
        }
        var expires = &apos;&apos;;
        if (options.expires &amp;&amp; (typeof options.expires == &apos;number&apos; || options.expires.toUTCString)) {
            var date;
            if (typeof options.expires == &apos;number&apos;) {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = &apos;; expires=&apos; + date.toUTCString(); // use expires attribute, max-age is not supported by IE
        }
        // CAUTION: Needed to parenthesize options.path and options.domain
        // in the following expressions, otherwise they evaluate to undefined
        // in the packed version for some reason...
        var path = options.path ? &apos;; path=&apos; + (options.path) : &apos;&apos;;
        var domain = options.domain ? &apos;; domain=&apos; + (options.domain) : &apos;&apos;;
        var secure = options.secure ? &apos;; secure&apos; : &apos;&apos;;
        document.cookie = [name, &apos;=&apos;, encodeURIComponent(value), expires, path, domain, secure].join(&apos;&apos;);
    } else { // only name given, get cookie
        var cookieValue = null;
        if (document.cookie &amp;&amp; document.cookie != &apos;&apos;) {
            var cookies = document.cookie.split(&apos;;&apos;);
            for (var i = 0; i &lt; cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + &apos;=&apos;)) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};</file><file path="html/embed-demo.htm">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Hoogle Embed Demo&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt;
body {font-family: sans-serif;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;Hoogle Embed Demo&lt;/h1&gt;

&lt;p&gt;
Search below to query Hoogle in embedded mode, as described in
&lt;a href=&quot;https://github.com/ndmitchell/hoogle/blob/master/docs/Developers.md&quot;&gt;the documentation&lt;/a&gt;.
&lt;/p&gt;

&lt;form action=&quot;../&quot; method=&quot;get&quot;&gt;
	&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
	&lt;script type=&quot;text/javascript&quot; src=&quot;hoogle.js&quot;&gt;&lt;/script&gt;
	&lt;input type=&quot;text&quot; name=&quot;hoogle&quot; id=&quot;hoogle&quot; accesskey=&quot;1&quot; /&gt;
	&lt;input type=&quot;hidden&quot; name=&quot;prefix&quot; value=&quot;+base&quot; /&gt;
	&lt;input type=&quot;submit&quot; value=&quot;Search&quot; /&gt;
&lt;/form&gt;


&lt;/body&gt;
&lt;/html&gt;</file><file path="html/hoogle.css">/********************************************************************
*  GENERAL ELEMENTS
*/

html {
    height: 100%;
}

body {
    margin: 0px;
    padding: 0px;
    font-family: sans-serif;
    font-size: 13px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

#body {
    flex-grow: 1;
    position: relative;
}

a img {
    padding: 0px;
    margin: 0px;
    border: 0px;
}

a:hover {
    background-color: #ffb;
}

a {
    color: #C4451D;
    text-decoration: none;
}

/********************************************************************
*  TOP - LINKS AND SEARCH
*/

#links {
    background: none repeat scroll 0 0 #293845;
    border-top: 5px solid #4E6272;
    color: #DDDDDD;
    text-align: right;
    padding: 0.2em;
}

#top-menu {
    display: inline-table;
    list-style: none outside none;
    margin: 0 0 0 1em;
    text-align: left;
}

#top-menu li {
    border-left: 1px solid #D5D5D5;
    display: inline;
    padding: 0;
    white-space: nowrap;
}

#top-menu li a,
#top-menu li a:link,
#top-menu li a:visited {
    font-size: 85%;
    color: white;
    text-decoration: none;
    padding: 0.2em 0.5em;
}

#top-menu li a:hover {
    background-color: #4e6272;
    text-decoration: underline;
}

form {
    margin-bottom: 0px;
}

#logo img {
    vertical-align: bottom;
}

#hoogle, #scope, #scope_chosen, #submit {
    font-size: 16px;
    margin-bottom: 16px;
    vertical-align: bottom;
}
#scope_chosen, #scope {
    width: 200px;
}
#scope_chosen .chosen-drop {
    width: 400px;
}
.chosen-container .chosen-results li em {
  font-weight: bold;
  text-decoration: none !important;
}

#hoogle {
    width: 300px;
    margin-right: 5px;
    margin-left: 5px;
}

#submit {
    padding-left: 15px;
    padding-right: 15px;
}

#top-menu li#plugin {
    display: none;
    cursor: pointer;
}


/********************************************************************
*  LEFT - EXTRA SUGGESTIONS
*/

#left {
    float: left;
    width: 140px;
    margin: 0px;
    padding: 0px;
    margin-left: 10px;
    overflow: hidden;
    position: absolute;
    top: 0;
    left: 0;
}

#left li {
    list-style-type: none;
    margin-bottom: 7px;
    white-space: nowrap;
    display: block;
}

#left a {
    color: #C4451D;
    text-decoration: none;
    background-repeat: no-repeat;
}

#left .plus {
    padding-right: 16px;
    background-image: url(more_small.png);
    background-position: center right;
    color: #0E774A;
}

#left .pad {
    padding-left: 16px;
}

#left .minus {
    color: #770E00;
    padding-left: 16px;
    background-image: url(less_small.png);
    background-position: center left;
}


/********************************************************************
*  BOTTOM - COPYRIGHT MESSAGE
*/

#footer {
    background: none repeat scroll 0 0 #DDDDDD;
    border-top: 1px solid #AAAAAA;
    color: #666666;
    width: 100%;
    padding: 1.3em 0;
    text-align: center;
}


/********************************************************************
*  HEADING
*/

h1 {
    padding: 5px;
    margin-top: 0px;
    margin-bottom: 0px;
    padding-bottom: 0px;
    font-weight: bold;
    padding-left: 170px;
    font-size: 16px;
}

p {
    margin-left: 170px;
    margin-right: 20px;
    font-size: 16px;
}


/********************************************************************
*  SPECIAL PAGES
*/

.error {
    border-bottom: 2px solid red;
    text-decoration: none;
    white-space: pre;
}

#example {
    margin: auto;
    margin-top: 20px;
    margin-bottom: 20px;
    padding: 3px;
    width: 400px;
    border: 2px solid #cc0;
    color: black;
    background-color: #F5F5F5;
    border: 1px solid #E5E5E5;
    text-align: left;
}

#example a {
    margin-left: 20px;
}


/********************************************************************
*  RESULTS
*/

.result {
    margin-left: 170px;
    margin-right: 20px;
    margin-top: 1.5em;
}

.result.active {
    background-color: #f7f5c0;
}

.from, .doc {
    margin-top: 0.4em;
}

a.dull, a.dull:hover {
    text-decoration: none;
}

/** ANSWERS **/

.ans i {
    font-weight: bold;
    font-style: normal;
}

.ans {
    background: none repeat scroll 0 0 #F0F0F0;
    border-top: 1px solid #CCCCCC;
    font-size: 16px;
    padding: 0.2em 0.5em;
}

.ans a {
    color: black;
}
.ans .name {
    color: #C4451D;
}

.links {
    float: right;
    color: #CCCCCC;
}
.links a {
    color: #888;
    font-size: 12px;
}

.c0{background-color: #fcc;}
.c1{background-color: #cfc;}
.c2{background-color: #ccf;}
.c3{background-color: #ffc;}
.c4{background-color: #fcf;}
.c5{background-color: #cff;}

.more, .more:visited {
    padding-left: 16px;
    background-image: url(more_blue.png);
    background-repeat: no-repeat;
    background-position: center left;
    color: blue;
}

/** PARENTS **/

.from a, .p1, .p2 {
    white-space: nowrap;
    text-decoration: none;
    color: #0E774A;
}

/** DOCS **/
/*
docs may be in one of three states:
    .doc - shut and no icon
    .doc.shut - shut with an icon to expand
    .doc.open - open with an icon to collapse
*/

.doc {
    font-size: 11px;
    background-repeat: no-repeat;
    background-position: 2px left;
    margin-bottom: 1.0em;
}
.doc, .doc a {
    color: #888;
}
.doc h1, .doc h2, .doc h3, .doc h4, .doc h5, .doc h6 {
    font-size: 11px;
    display: inline;
    padding: 0px;
}

.open, .shut {padding-left: 13px;}
.open {background-image: url(less_gray.png);}
.shut {background-image: url(more_gray.png);}

.doc, .shut {
    max-height: 2.0em;
    overflow: hidden;
}
.open {
    max-height: 100%;
    white-space: pre-wrap;
}


/********************************************************************
*  PHONE SPECIFIC
*/

.phone #links {
    float: none;
    margin-left: 5px;
}

.phone #search {
    text-align: center;
}

.phone #submit {
    display: none;
}

.phone #left {
    display: none;
}

.phone h1 {
    padding-left: 5px;
}

.phone p {
    margin-left: 5px
}

.phone #example {
    width: auto;
}

.phone #footer {
    font-size: small;
}

.phone .result {
    margin-left: 5px;
    margin-right: 5px;
}</file><file path="html/hoogle.js">// PERHAPS I SHOULD BE USING Bootstrap with:
// http://silviomoreto.github.io/bootstrap-select/


var embed = false; // are we running as an embedded search box
var instant = true; // should we search on key presses
var query = parseQuery(); // what is the current query string

var $hoogle; // $(&quot;#hoogle&quot;) after load


/////////////////////////////////////////////////////////////////////
// SEARCHING

function on_arrow_press(ev) {
    var offset = 0;
    if (ev.keyCode == Key.Up) {
        offset = -1;
    } else if (ev.keyCode == Key.Down) {
        offset = +1;
    } else if (ev.keyCode != Key.Return) {
        return;
    }

    // Figure out where we are
    var results = $(&quot;div#body .result&quot;);
    var activeResults = $(&quot;div#body .result.active&quot;);
    var activeRow = -1;
    if (activeResults.length == 1) {
        activeRow = results.index(activeResults[0]);
    }

    if (ev.keyCode == Key.Return) {
        if (activeRow &gt;= 0)
            document.location.href = $(&quot;a&quot;, activeResults).attr(&quot;href&quot;);
    } else {
        var newRow = activeRow + offset;
        var $activeRow = $(results[activeRow]);
        if (newRow &lt; 0) {
            $activeRow.removeClass(&quot;active&quot;);
            $hoogle.focus();
        } else if (newRow &lt; results.length) {
            var $newRow = $(results[newRow]);
            if (activeRow &gt;= 0)
                $activeRow.removeClass(&quot;active&quot;);
            $newRow.addClass(&quot;active&quot;);
            $hoogle.blur();
        }
    }
}

$(function() {
    $(document).keyup(on_arrow_press);
});

$(function(){
    $hoogle = $(&quot;#hoogle&quot;);
    var $form = $hoogle.parents(&quot;form:first&quot;);
    var $scope = $form.find(&quot;[name=scope]&quot;);
    embed = !$hoogle.hasClass(&quot;HOOGLE_REAL&quot;);
    if (!embed) $scope.chosen({&quot;search_contains&quot;:true});

    var self = embed ? newEmbed() : newReal();

    var ajaxUrl = !embed ? &quot;?&quot; : $form.attr(&quot;action&quot;) + &quot;?&quot;;
    var ajaxMode = embed ? &apos;embed&apos; : &apos;body&apos;;

    var active = $hoogle.val() + &quot; &quot; + $scope.val(); // What is currently being searched for (may not yet be displayed)
    var past = cache(100); // Cache of previous searches
    var watch = watchdog(500, function(){self.showWaiting();}); // Timeout of the &quot;Waiting...&quot; callback

    function hit(){
        if (!instant) return;
        function getScope(){
            var v = $scope ? $scope.val() : &quot;&quot;;
            return v == null || v == &quot;set:stackage&quot; ? &quot;&quot; : v;
        }

        var nowHoogle = $hoogle.val();
        var nowScope = getScope();
        var now = nowHoogle + &quot; &quot; + nowScope;
        if (now == active) return;
        active = now;

        var title = now + (now == &quot; &quot; ? &quot;&quot; : &quot; - &quot;) + &quot;Hoogle&quot;;
        query[&quot;hoogle&quot;] = nowHoogle;
        query[&quot;scope&quot;] = nowScope;
        if (!embed){
            if (window.history)
                window.history.replaceState(null, title, renderQuery(query));
            $(&quot;title&quot;).text(title);
        }

        var old = past.ask(now);
        if (old != undefined){self.showResult(old); return;}

        watch.stop();
        if (embed &amp;&amp; now == &quot;&quot;){self.hide(); return;}
        watch.start();

        var data = {hoogle:nowHoogle, scope:nowScope, mode:ajaxMode};
        function complete(e)
        {
            watch.stop();
            var current = $hoogle.val() + &quot; &quot; + getScope() == now;
            if (e.status == 200)
            {
                past.add(now,e.responseText);
                if (current)
                    self.showResult(e.responseText);
            }
            else if (current)
                self.showError(e.status, e.responseText);
        }

        var args = {url:ajaxUrl, data:data, complete:complete, dataType:&quot;html&quot;}
        try {
            $.ajax(args);
        } catch (err) {
            try {
                if (!embed) throw err;
                $.ajaxCrossDomain(args);
            } catch (err) {
                // Probably a permissions error from cross domain scripting...
                watch.stop();
            }
        }
    };
    $hoogle.keyup(hit);
    $scope.change(hit);
})

function newReal()
{
    $hoogle.select();
    var $body = $(&quot;#body&quot;);

    return {
        showWaiting: function(){$(&quot;h1&quot;).text(&quot;Still working...&quot;);},
        showError: function(status,text){$body.html(&quot;&lt;h1&gt;&lt;b&gt;Error:&lt;/b&gt; status &quot; + status + &quot;&lt;/h1&gt;&lt;p&gt;&quot; + text + &quot;&lt;/p&gt;&quot;)},
        showResult: function(text){$body.html(text); newDocs();}
    }
}

function newEmbed()
{
    $hoogle.attr(&quot;autocomplete&quot;,&quot;off&quot;);
    // IE note: unless the div in the iframe contain any border it doesn&apos;t calculate the correct outerHeight()
    //          therefore we put 3 borders on the iframe, and leave one for the bottom div
    var $iframe = $(&quot;&lt;iframe id=&apos;hoogle-output&apos; scrolling=&apos;no&apos; &quot;+
                    &quot;style=&apos;position:absolute;border:1px solid rgb(127,157,185);border-bottom:0px;display:none;&apos; /&gt;&quot;);
    var $body;
    $iframe.load(function(){
        var $contents = $iframe.contents();
        $contents.find(&quot;head&quot;).html(
            &quot;&lt;style type=&apos;text/css&apos;&gt;&quot; +
            &quot;html {border: 0px;}&quot; +
            &quot;body {font-family: sans-serif; font-size: 13px; background-color: white; padding: 0px; margin: 0px;}&quot; +
            &quot;a, i {display: block; color: black; padding: 1px 3px; text-decoration: none; white-space: nowrap; overflow: hidden; cursor: default;}&quot; +
            &quot;a.sel {background-color: rgb(10,36,106); color: white;}&quot; +
            &quot;div {border-bottom:1px solid rgb(127,157,185);}&quot; +
            &quot;&lt;/style&gt;&quot;);
        $body = $(&quot;&lt;div&gt;&quot;).appendTo($contents.find(&quot;body&quot;));
    });
    $iframe.insertBefore($hoogle);

    var finishOnBlur = true; // Should a blur hide the box

    function show(x){
        if (x == undefined)
            $iframe.css(&quot;display&quot;,&quot;none&quot;);
        else {
            $body.html(x).find(&quot;a&quot;).attr(&quot;target&quot;,&quot;_parent&quot;)
                .mousedown(function(){finishOnBlur = false;})
                .mouseup(function(){finishOnBlur = true;})
                .mouseenter(function(){
                    $body.find(&quot;.sel&quot;).removeClass(&quot;sel&quot;);
                    $(this).addClass(&quot;sel&quot;);
                });

            var pos = $hoogle.position();
            // need to display before using $body.outerHeight() on Firefox
            $iframe.css(&quot;display&quot;,&quot;&quot;).css(
                {top:px(pos.top + $hoogle.outerHeight() + unpx($hoogle.css(&quot;margin-top&quot;)))
                ,left:px(pos.left + unpx($hoogle.css(&quot;margin-left&quot;)))
                ,width:px($hoogle.outerWidth() - 2 /* iframe border */)
                ,height:$body.outerHeight()
                });
        }
    }

    $hoogle.blur(function(){if (finishOnBlur) show();});

    $hoogle.keydown(function(event){
        switch(event.which)
        {
        case Key.Return:
            var sel = $body.find(&quot;.sel:first&quot;);
            if (sel.size() == 0) return;
            event.preventDefault();
            document.location.href = sel.attr(&quot;href&quot;);
            break;

        case Key.Escape:
            $body.find(&quot;.sel&quot;).removeClass(&quot;sel&quot;);
            show();
            break;

        case Key.Down: case Key.Up:
            var i = event.which == Key.Down ? 1 : -1;
            var all = $body.find(&quot;a&quot;);
            var sel = all.filter(&quot;.sel&quot;);
            var now = all.index(sel);
            if (now == -1)
                all.filter(i == 1 ? &quot;:first&quot; : &quot;:last&quot;).addClass(&quot;sel&quot;);
            else {
                sel.removeClass(&quot;sel&quot;);
                // IE treats :eq(-1) as :eq(0), so filter specifically
                if (now+i &gt;= 0) all.filter(&quot;:eq(&quot; + (now+i) + &quot;)&quot;).addClass(&quot;sel&quot;);
            }
            event.preventDefault();
            break;
        }
    });

    return {
        showWaiting: function(){show(&quot;&lt;i&gt;Still working...&lt;/i&gt;&quot;);},
        showError: function(status,text){show(&quot;&lt;i&gt;Error: status &quot; + status + &quot;&lt;/i&gt;&quot;);},
        showResult: function(text){show(text);},
        hide: function(){show();}
    }
}


/////////////////////////////////////////////////////////////////////
// SEARCH PLUGIN

var prefixUrl = document.location.protocol + &quot;//&quot; + document.location.hostname + document.location.pathname;

$(function(){
    if (embed) return;
    if (prefixUrl != &quot;http://hoogle.haskell.org/&quot;)
    {
        $(&quot;link[rel=search]&quot;).attr(&quot;href&quot;, function(){
            return this.href + &quot;?domain=&quot; + escape(prefixUrl);
        });
    }
    if (window.external &amp;&amp; (&quot;AddSearchProvider&quot; in window.external))
    {
        $(&quot;#plugin&quot;).css(&quot;display&quot;,&quot;inline&quot;).on(&apos;click&apos;, function(){
            var url = $(&quot;link[rel=search]&quot;).attr(&quot;href&quot;);
            //  If neither scheme(http(s)://) nor DSN prefix(//) is in URL then we
            //  should add prefix.
            if (url.indexOf(&apos;://&apos;) === -1 &amp;&amp; url.indexOf(&apos;//&apos;) !== 0)
                url = prefixUrl + url;
            window.external.AddSearchProvider(url);
        });
    }
});


/////////////////////////////////////////////////////////////////////
// DOCUMENTATION

$(function(){
    if (embed) return;
    $(window).resize(resizeDocs);
    newDocs();
});

function resizeDocs()
{
    $(&quot;#body .doc&quot;).each(function(){
        // If a segment is open, it should remain open forever
        var $this = $(this);
        var toosmall = ($.support.preWrap &amp;&amp; $this.hasClass(&quot;newline&quot;)) ||
                       ($this.height() &lt; $this.children().height());
        if (toosmall &amp;&amp; !$this.hasClass(&quot;open&quot;))
            $this.addClass(&quot;shut&quot;);
        else if (!toosmall &amp;&amp; $this.hasClass(&quot;shut&quot;))
            $this.removeClass(&quot;shut&quot;);
    });
}

function newDocs()
{
    resizeDocs();
    $(&quot;#body .doc&quot;).click(function(){
        var $this = $(this);
        if ($this.hasClass(&quot;open&quot;) || $this.hasClass(&quot;shut&quot;))
            $this.toggleClass(&quot;open&quot;).toggleClass(&quot;shut&quot;);
    });
}


/////////////////////////////////////////////////////////////////////
// iOS TWEAKS

$(function(){
    if ($.support.inputSearch)
        $(&quot;#hoogle&quot;)[0].type = &quot;search&quot;;

    var qphone = query[&quot;phone&quot;];
    phone =
        qphone == &quot;0&quot; ? false :
        qphone == &quot;1&quot; ? true :
        $.support.phone;

    if (!phone) return;
    $(&quot;body&quot;).addClass(&quot;phone&quot;);
    $(&quot;head&quot;).append(&quot;&lt;meta name=&apos;viewport&apos; content=&apos;width=device-width&apos; /&gt;&quot;);
});


/////////////////////////////////////////////////////////////////////
// LIBRARY BITS

function parseQuery() // :: IO (Dict String String)
{
    // From http://stackoverflow.com/questions/901115/get-querystring-values-with-jquery/3867610#3867610
    var params = {},
        e,
        a = /\+/g,  // Regex for replacing addition symbol with a space
        r = /([^&amp;=]+)=?([^&amp;]*)/g,
        d = function (s) { return decodeURIComponent(s.replace(a, &quot; &quot;)); },
        q = window.location.search.substring(1);

    while (e = r.exec(q))
        params[d(e[1])] = d(e[2]);

    return params;
}

function renderQuery(query) // Dict String String -&gt; IO String
{
    var s = &quot;&quot;;
    for (var i in query)
    {
        if (query[i] != &quot;&quot;)
            s += (s == &quot;&quot; ? &quot;?&quot; : &quot;&amp;&quot;) + i + &quot;=&quot; + encodeURIComponent(query[i]);
    }
    return window.location.href.substring(0, window.location.href.length - window.location.search.length) + s;
}


// Supports white-space: pre-wrap;
$.support.preWrap = true;

$.support.iOS =
    (navigator.userAgent.indexOf(&quot;iPhone&quot;) != -1) ||
    (navigator.userAgent.indexOf(&quot;iPod&quot;) != -1) ||
    (navigator.userAgent.indexOf(&quot;iPad&quot;) != -1);

$.support.phone =
    (navigator.userAgent.indexOf(&quot;iPhone&quot;) != -1) ||
    (navigator.userAgent.indexOf(&quot;iPod&quot;) != -1) ||
    (navigator.userAgent.indexOf(&quot;Android&quot;) != -1);

// Supports &lt;input type=search /&gt;
$.support.inputSearch = $.support.iOS;

var Key = {
    Up: 38,
    Down: 40,
    Return: 13,
    Escape: 27
};

function unpx(x){var r = 1 * x.replace(&quot;px&quot;,&quot;&quot;); return isNaN(r) ? 0 : r;}
function px(x){return x + &quot;px&quot;;}

function cache(maxElems)
{
    // FIXME: Currently does not evict things
    var contents = {}; // what we have in the cache, with # prepended
    // note that contents[toString] != undefined, since it&apos;s a default method
    // hence the leading #

    return {
        add: function(key,val)
        {
            contents[&quot;#&quot; + key] = val;
        },

        ask: function(key)
        {
            return contents[&quot;#&quot; + key];
        }
    };
}

function watchdog(time, fun)
{
    var id = undefined;
    function stop(){if (id == undefined) return; window.clearTimeout(id); id = undefined;}
    function start(){stop(); id = window.setTimeout(function(){id = undefined; fun();}, time);}
    return {start:start, stop:stop}
}

$.ajaxCrossDomain = function(args)
{
    if (!window.XDomainRequest) throw new Error(&quot;the XDomainRequest object is not supported in this browser&quot;);

    var xdr = new XDomainRequest();
    xdr.onload = function(){args.complete({status:200, responseText:xdr.responseText});};
    xdr.onerror = function(){args.complete({status:0, responseText:&quot;&quot;});};

    var url = &quot;&quot;;
    for (var i in args.data)
    {
        if (args.data[i] == undefined) continue;
        url += (url == &quot;&quot; ? &quot;&quot; : &quot;&amp;&quot;) + encodeURIComponent(i) + &quot;=&quot; + encodeURIComponent(args.data[i]);
    }
    xdr.open(&quot;get&quot;, args.url + url);
    xdr.send();
}</file><file path="html/index.html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
    &lt;head profile=&quot;http://a9.com/-/spec/opensearch/1.1/&quot;&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf8&quot; /&gt;
        &lt;title&gt;#{title}&lt;/title&gt;
        &lt;meta name=&quot;robots&quot; content=&quot;#{robots}&quot; /&gt;
        &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;#{cdn}hoogle.css&quot; /&gt;
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;#{cdn}plugin/chosen.css&quot; /&gt;
        &lt;link type=&quot;image/png&quot; rel=&quot;icon&quot; href=&quot;#{cdn}favicon.png&quot; /&gt;
        &lt;link type=&quot;image/png&quot; rel=&quot;apple-touch-icon&quot; href=&quot;#{cdn}favicon57.png&quot; /&gt;
        &lt;link type=&quot;application/opensearchdescription+xml&quot; rel=&quot;search&quot; href=&quot;#{cdn}search.xml&quot; title=&quot;Hoogle&quot; /&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;#{jquery}&quot;&gt; &lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;#{cdn}plugin/jquery-cookie.js&quot;&gt; &lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;#{cdn}plugin/chosen-jquery.js&quot;&gt; &lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;#{cdn}hoogle.js&quot;&gt; &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
&lt;div id=&quot;links&quot;&gt;
    &lt;ul id=&quot;top-menu&quot;&gt;
        &lt;li id=&quot;plugin&quot;&gt;&lt;a&gt;Search plugin&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://github.com/ndmitchell/hoogle/blob/master/README.md&quot;&gt;Manual&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://www.haskell.org&quot;&gt;haskell.org&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;form action=&quot;&quot; method=&quot;get&quot; id=&quot;search&quot;&gt;
    &lt;a id=&quot;logo&quot; href=&quot;#{home}&quot;&gt;
        &lt;img src=&quot;#{cdn}hoogle.png&quot; width=&quot;160&quot; height=&quot;58&quot; alt=&quot;Hoogle&quot;
    /&gt;&lt;/a&gt;
    &lt;input name=&quot;hoogle&quot; id=&quot;hoogle&quot; class=&quot;HOOGLE_REAL&quot; type=&quot;text&quot; autocomplete=&quot;off&quot; autofocus=&quot;autofocus&quot; accesskey=&quot;1&quot; placeholder=&quot;Search for...&quot; value=&quot;#{search}&quot; /&gt;
    &lt;select name=&quot;scope&quot; id=&quot;scope&quot; data-live-search=&quot;true&quot;&gt;#{tags}&lt;/select&gt;
    &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Search&quot; /&gt;
&lt;/form&gt;
&lt;div id=&quot;body&quot;&gt;
#{body}
        &lt;/div&gt;
        &lt;div id=&quot;footer&quot;&gt;&amp;copy; &lt;a href=&quot;http://ndmitchell.com&quot;&gt;Neil Mitchell&lt;/a&gt; 2004-2024, version #{version}&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</file><file path="html/log.html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf8&quot; /&gt;
        &lt;title&gt;Log view&lt;/title&gt;
        &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;#{cdn}hoogle.css&quot; /&gt;
        &lt;link type=&quot;image/png&quot; rel=&quot;icon&quot; href=&quot;#{cdn}favicon.png&quot; /&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;#{jquery}&quot;&gt; &lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;log.js&quot;&gt; &lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;plugin/jquery.flot.js&quot;&gt; &lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;plugin/jquery.flot.time.js&quot;&gt; &lt;/script&gt;

&lt;style type=&quot;text/css&quot;&gt;
.plot {width: 90%; max-width: 600px; height: 200px;}
&lt;/style&gt;

    &lt;/head&gt;
    &lt;body&gt;
&lt;/head&gt;
&lt;body style=&quot;height:100%;width:100%;&quot;&gt;
&lt;h2&gt;Hoogle Log&lt;/h2&gt;
&lt;b&gt;Users&lt;/b&gt;&lt;div id=&quot;users&quot; class=&quot;plot&quot;&gt;&lt;/div&gt;&lt;br/&gt;
&lt;b&gt;Timings&lt;/b&gt;&lt;div id=&quot;timings&quot; class=&quot;plot&quot;&gt;&lt;/div&gt;&lt;br/&gt;
&lt;b&gt;Errors&lt;/b&gt;&lt;div id=&quot;errors&quot; class=&quot;plot&quot;&gt;&lt;/div&gt;&lt;br/&gt;

&lt;div id=&quot;tooltip&quot; style=&quot;position:absolute;display:none;border-radius:4px;border:1px solid gray;padding:3px;background-color:#fea;box-shadow: 4px 3px 8px -1px rgba(0,0,0,0.38);&quot;&gt;&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;</file><file path="html/log.js">var data = #{data};
function series(name, val)
{
    val.label = name;
    val.data = [];
    for (var i = 0; i &lt; data.length; i++)
    {
        var x = data[i][name.toLowerCase()];
        val.data.push([new Date(data[i].date),x == 0 ? null : x]);
    }
    return val;
}
$(function(){
    var settings =
        {series: {lines: {show: true}, points: {show: true}}
        ,xaxis: {mode: &quot;time&quot;, minTickSize: [1, &quot;day&quot;]}
        ,yaxes: [{}, {position: &quot;right&quot;}]
        ,grid: {hoverable: true, clickable: true}};
    $.plot(&quot;#users&quot;,[series(&quot;Uses&quot;,{yaxis:2}),series(&quot;Users&quot;,{})], settings);
    $.plot(&quot;#timings&quot;,[series(&quot;Average&quot;,{}),series(&quot;Slowest&quot;,{yaxis:2})], settings);
    settings.series.lines.show = false;
    $.plot(&quot;#errors&quot;,[series(&quot;Errors&quot;,{color:&quot;darkred&quot;})], settings);

    $(&quot;.plot&quot;).bind(&quot;plothover&quot;, function (event, pos, item) {
        if (item) {
            var x = new Date(item.datapoint[0]).toDateString();
            var y = item.datapoint[1];
            y = Math.floor(y) == y ? y : y.toFixed(3);

            $(&quot;#tooltip&quot;).html(y + &quot; = &quot; + item.series.label + &quot; on &quot; + x)
                .css({top: item.pageY+5, left: item.pageX+5})
                .fadeIn(200);
        } else {
            $(&quot;#tooltip&quot;).hide();
        }
    });

});</file><file path="html/search.xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;OpenSearchDescription xmlns=&quot;http://a9.com/-/spec/opensearch/1.1/&quot;&gt;
    &lt;ShortName&gt;Hoogle&lt;/ShortName&gt;
    &lt;LongName&gt;Hoogle - Haskell API Search&lt;/LongName&gt;
    &lt;Description&gt;
        Hoogle is a Haskell API search engine, which allows you to
        search many standard Haskell libraries by either function name,
        or by approximate type signature.
    &lt;/Description&gt;
    &lt;Tags&gt;haskell&lt;/Tags&gt;
    &lt;Url type=&quot;text/html&quot; template=&quot;https://hoogle.haskell.org/?hoogle={searchTerms}&quot;/&gt;
    &lt;Url type=&quot;application/x-suggestions+json&quot; template=&quot;https://hoogle.haskell.org/?hoogle={searchTerms}&amp;amp;mode=suggest&quot;/&gt;

    &lt;Image height=&quot;16&quot; width=&quot;16&quot; type=&quot;image/png&quot;&gt;https://hoogle.haskell.org/favicon.png&lt;/Image&gt;
    &lt;Image height=&quot;64&quot; width=&quot;64&quot; type=&quot;image/png&quot;&gt;https://hoogle.haskell.org/favicon64.png&lt;/Image&gt;
    &lt;Developer&gt;Neil Mitchell&lt;/Developer&gt;
    &lt;AdultContent&gt;false&lt;/AdultContent&gt;
    &lt;Language&gt;en-us&lt;/Language&gt;
    &lt;OutputEncoding&gt;UTF-8&lt;/OutputEncoding&gt;
    &lt;InputEncoding&gt;UTF-8&lt;/InputEncoding&gt;
&lt;/OpenSearchDescription&gt;</file><file path="html/welcome.html">&lt;h1&gt;Welcome to Hoogle&lt;/h1&gt;
&lt;ul id=&quot;left&quot;&gt;
&lt;li&gt;&lt;b&gt;Links&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.haskell.org&quot;&gt;Haskell.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hackage.haskell.org&quot;&gt;Hackage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/&quot;&gt;GHC Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/libraries/&quot;&gt;Libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
    Hoogle is a Haskell API search engine, which allows you to search the Haskell libraries
    on Stackage by either function name, or by approximate type signature.
&lt;/p&gt;
&lt;p id=&quot;example&quot;&gt;
    Example searches:&lt;br/&gt;
    &lt;a href=&quot;?hoogle=map&quot;&gt;map&lt;/a&gt;&lt;br/&gt;
    &lt;a href=&quot;?hoogle=(a%20-&amp;gt;%20b)%20-&amp;gt;%20%5Ba%5D%20-&amp;gt;%20%5Bb%5D&quot;&gt;(a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&lt;/a&gt;&lt;br/&gt;
    &lt;a href=&quot;?hoogle=Ord%20a%20%3D&amp;gt;%20%5Ba%5D%20-&amp;gt;%20%5Ba%5D&quot;&gt;Ord a =&amp;gt; [a] -&amp;gt; [a]&lt;/a&gt;&lt;br/&gt;
    &lt;a href=&quot;?hoogle=Data.Set.insert&quot;&gt;Data.Set.insert&lt;/a&gt;&lt;br/&gt;
    &lt;a href=&quot;?hoogle=%2Bbytestring+concat&quot;&gt;+bytestring concat&lt;/a&gt;&lt;br/&gt;
    &lt;br/&gt;Enter your own search at the top of the page.
&lt;/p&gt;
&lt;p&gt;
    The &lt;a href=&quot;https://wiki.haskell.org/Hoogle&quot;&gt;Hoogle manual&lt;/a&gt; contains more details,
    including further details on search queries, how to install Hoogle as a command line application
    and how to integrate Hoogle with Firefox/Emacs/Vim etc.
&lt;/p&gt;
&lt;p&gt;
    I am very interested in any feedback you may have. Please
    &lt;a href=&quot;http://ndmitchell.com&quot;&gt;email me&lt;/a&gt;, or add an entry to my
    &lt;a href=&quot;https://github.com/ndmitchell/hoogle/issues&quot;&gt;bug tracker&lt;/a&gt;.
&lt;/p&gt;</file><file path="misc/sample-data/emily-1.11/emily.txt">@url http://eghmitchell.com/
@package emily
@version 1.11

module Mitchell

@url #a_wife
type family Wife (a :: Mother)
paleo :: Bool</file><file path="misc/sample-data/emily-1.2/emily.txt">@url http://eghmitchell.co.uk/
@package emily
@version 1.2

module Mitchell
@url #a_wife
type family Wife (a :: Mother)</file><file path="misc/sample-data/henry.txt">@package henry

module Mitchell

@url http://henry.com?too_long
__prefix__really_long_string_take_might_overflow_any_poorly_chosen_word8_buffers_because_someone_decided_their_identifiers_should_be_untypeable_by_mere_humans__infix__and_that_their_sample_code_should_not_fit_into_tweets_or_even_single_lines_because_they_are_definitely_too_long__suffix__ :: a -&gt; b</file><file path="misc/Keywords.hs">-- A script for parsing the Haskell keywords out of the Haskell wiki page
-- and producing a database.

import Text.HTML.TagSoup
import Data.List.Extra
import Data.Char
import System.Environment
import System.IO.Extra
import Numeric


main :: IO ()
main = do
    [input,output] &lt;- getArgs
    writeFileBinary output . translateKeywords =&lt;&lt; readFile&apos; input

translateKeywords :: String -&gt; String
translateKeywords src = unlines $ keywordPrefix ++ items
    where items = concatMap keywordFormat $ partitions (~== &quot;&lt;span class=&apos;mw-headline&apos; id&gt;&quot;) $
                  takeWhile (~/= &quot;&lt;div class=printfooter&gt;&quot;) $ parseTags src

keywordPrefix =
    [&quot;-- Hoogle documentation, generated by Hoogle&quot;
    ,&quot;-- From https://wiki.haskell.org/Keywords&quot;
    ,&quot;-- See Hoogle, https://hoogle.haskell.org/&quot;
    ,&quot;&quot;
    ,&quot;-- | Haskell keywords, always available&quot;
    ,&quot;@url https://wiki.haskell.org/Keywords&quot;
    ,&quot;@package keyword&quot;
    ]


keywordFormat x = concat [&quot;&quot; : docs ++ [&quot;@url #&quot; ++ concatMap g n, &quot;@entry keyword &quot; ++ noUnderscore n] | n &lt;- name]
    where
        noUnderscore &quot;_&quot; = &quot;_&quot;
        noUnderscore xs = map (\x -&gt; if x == &apos;_&apos; then &apos; &apos; else x) xs

        name = words $ f $ fromAttrib &quot;id&quot; (head x)
        docs = zipWith (++) (&quot;-- | &quot; : repeat &quot;--   &quot;) $
               intercalate [&quot;&quot;] $
               map docFormat $
               partitions isBlock x

        g x | isAlpha x || x `elem` &quot;_-:&quot; = [x]
            | otherwise = &apos;.&apos; : upper (showHex (ord x) &quot;&quot;)

        isBlock (TagOpen x _) = x `elem` [&quot;p&quot;,&quot;pre&quot;,&quot;ul&quot;]
        isBlock _ = False

        f (&apos;.&apos;:&apos;2&apos;:&apos;C&apos;:&apos;_&apos;:xs) = &apos; &apos; : f xs
        f (&apos;.&apos;:a:b:xs) = chr res : f xs
            where [(res,&quot;&quot;)] = readHex [a,b]
        f (x:xs) = x : f xs
        f [] = []


docFormat :: [Tag String] -&gt; [String]
docFormat (TagOpen &quot;pre&quot; _:xs) = [&quot;&lt;pre&gt;&quot;] ++ map (drop n) ys ++ [&quot;&lt;/pre&gt;&quot;]
    where
        ys = lines $ trimEnd $ innerText xs
        n = minimum $ map (length . takeWhile isSpace) ys

docFormat (TagOpen &quot;p&quot; _:xs) = g 0 [] $ words $ f xs
    where
        g n acc [] = [unwords $ reverse acc | acc /= []]
        g n acc (x:xs) | nx+1+n &gt; 70 = g n acc [] ++ g nx [x] xs
                       | otherwise = g (n+nx+1) (x:acc) xs
            where nx = length x

        f (TagOpen &quot;code&quot; _:xs) = &quot;&lt;tt&gt;&quot; ++ innerText a ++ &quot;&lt;/tt&gt;&quot; ++ f (drop1 b)
            where (a,b) = break (~== &quot;&lt;/code&gt;&quot;) xs
        f (x:xs) = h x ++ f xs
        f [] = []

        h (TagText x) = unwords (lines x)
        h _ = &quot;&quot;

docFormat (TagOpen &quot;ul&quot; _:xs) =
    [&quot;&lt;ul&gt;&lt;li&gt;&quot;] ++ intercalate [&quot;&lt;/li&gt;&lt;li&gt;&quot;] [docFormat (TagOpen &quot;p&quot; []:x) | x &lt;- partitions (~== &quot;&lt;li&gt;&quot;) xs] ++ [&quot;&lt;/li&gt;&lt;/ul&gt;&quot;]</file><file path="misc/logo.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;512&quot; height=&quot;512&quot;&gt;&lt;path fill=&quot;purple&quot; d=&quot;M377.91659 187.33355c-.99883 0-2.11307.89002-3.37494 2.62506-3.68042 5.09995-7.68853 9.57846-12 13.41654v4.54186a28.16 28.16 0 0 1 2.70827-.12522c3.20725 0 5.65099.70549 7.33333 2.12501 1.68256 1.41973 3.82934 5.33547 6.45846 11.74997l5.1249 12.20843-20.49984 54.50005c-1.62986 4.1536-3.05173 6.72021-4.20842 7.66656-1.1567.89387-2.97622 1.56864-5.49995 2.0416v6.62507c2.78656-.368 5.23008-.54165 7.33333-.54165 2.15552 0 5.39691.17279 9.70838.54186 4.20608-17.40331 10.1152-37.66869 17.79157-60.75008 7.88672 21.60939 13.42869 35.86219 16.58325 42.74987 3.20726 6.88768 6.91883 13.43189 11.12512 19.58336h2.45824c6.46699-3.25974 12.52992-6.03094 18.20843-8.29162v-4.41665c-3.25973-.31552-6.09237-1.757-8.45845-4.33344-2.31339-2.62891-6.37227-11.1968-12.20822-25.70816l-21.20832-53.41696c-3.15477-7.88672-6.3345-13.62218-9.54176-17.25013-3.20725-3.68021-5.8353-5.54155-7.83338-5.54155M0 188.54187v115.62495h23.33333v-50.58346h45.74998v50.58346h23.33333V188.54208H69.08331v45.49995H23.33333v-45.49995zm477.54176 36.66666c-10.6208 0-19.60853 4.18198-26.91669 12.54187-6.94038 8.04416-10.37504 17.46048-10.37504 28.29141 0 12.1455 3.6192 21.90016 10.87488 29.20832 7.25589 7.25568 16.96874 10.87509 29.16693 10.87509 12.09259 0 22.02091-4.0896 29.74976-12.29162.84139-.89387 1.25013-1.51786 1.25013-1.83338 0-.26283-.90986-2.144-2.74986-5.66656-1.84043-3.57547-2.84246-5.4366-3.00011-5.54177-.10453-.10453-.3712-.1664-.79168-.1664l-2.54165 2.08321c-6.94038 5.36298-14.5679 8.0418-22.8751 8.0418-4.83712 0-9.33546-1.56458-13.54176-4.66666-4.41642-3.25973-6.98304-7.2064-7.66656-11.8336 30.2848-2.26069 46.57259-3.78368 48.83328-4.62485 3.36491-1.31456 5.04171-3.94262 5.04171-7.8336 0-10.09494-3.24139-18.66283-9.70837-25.70816-6.62464-7.25568-14.8655-10.8751-24.74987-10.8751m-148.12501.1664c-.63104 0-.95851 1.55371-.95851 4.70827 0 .73621.0619 1.89205.1664 3.41675.10453 1.47221.1664 2.5248.1664 3.20853 0 .94613-.2048 1.41653-.62485 1.41653-.368 0-.992-.52096-1.83318-1.62496-5.10016-6.67733-11.99146-10.0416-20.66666-10.0416-9.83211 0-17.80694 3.7423-23.9584 11.20832-5.78347 6.99264-8.66667 15.46859-8.66667 25.45814 0 9.8321 3.00608 18.14527 8.99989 24.87509 6.25686 6.99285 14.23147 10.45824 23.9584 10.45824 8.99072 0 16.41387-3.52704 22.25003-10.62485.2112 3.83807.29163 6.31253.29163 7.41653 0 4.99499-1.97334 8.78784-5.91659 11.41674-3.4176 2.31339-7.71157 3.45815-12.91669 3.45815-7.9392 0-15.86347-2.22807-23.74998-6.74988-.42069-.26282-.73728-.41663-1.0001-.41663-.57835 0-.96726.43946-1.12491 1.33332-1.57739 8.3599-2.37504 12.24512-2.37504 11.66678 0 .52565.59328 1.18037 1.74997 1.91659 7.36086 4.5216 17.02315 6.79168 28.9583 6.79168 12.35584 0 21.33269-3.14902 26.95829-9.45834 5.3632-5.94134 8.04181-15.19488 8.04181-27.70838 0-6.30933.0619-15.75637.1664-28.37504.10454-12.67115.1664-22.19051.1664-28.49984 0-1.10421-.38869-1.77899-1.1249-2.0416-.47318-.2112-3.264-.76203-8.41664-1.70837-5.15264-.99904-8.016-1.50016-8.54187-1.50016M146.12395 226c-10.88363 0-20.0032 3.94667-27.41675 11.83339-7.20299 7.72885-10.83307 17.0944-10.83307 28.0832s3.63008 20.31275 10.83307 28.04182c7.36085 7.99168 16.48064 12 27.41675 12 10.88362 0 20.01408-4.03904 27.37493-12.0832 7.2032-7.78176 10.79168-17.13643 10.79168-28.12524 0-10.9361-3.6192-20.24021-10.87488-27.91679-7.36-7.8863-16.45995-11.83296-27.29088-11.83296m82.58347 0c-10.88363 0-20.04502 3.94666-27.45856 11.83338-7.20299 7.72886-10.79168 17.0944-10.79168 28.0832s3.58869 20.31275 10.79168 28.04181c7.36085 7.99169 16.52224 12 27.45834 12 10.88363 0 20.0143-4.03904 27.37494-12.08319 7.2032-7.78177 10.79189-17.13643 10.79189-28.12523 0-10.93611-3.61941-20.24021-10.87509-27.9168-7.36086-7.88651-16.4608-11.83317-27.29174-11.83317m247.70816 14.33344c4.31147 0 8.20758 1.67658 11.62496 5.04149 3.47008 3.36512 5.20832 7.26123 5.20832 11.62496 0 .63104-1.53386 1.16266-4.58325 1.58336-10.83093 1.57739-20.13525 2.33344-27.9168 2.33344-1.89269 0-2.83307-.52096-2.83307-1.62496 0-4.83712 1.85024-9.23435 5.58315-13.12512 3.7856-3.89077 8.07957-5.83317 12.91669-5.83317m-166.54165 1.1249c5.73099 0 10.35243 2.23915 13.8752 6.70827 3.20704 4.10112 4.79147 9.06965 4.79147 14.95829 0 5.73099-1.64587 10.6799-4.9583 14.83349-3.57546 4.52161-8.13504 6.79169-13.70837 6.79169-5.6256 0-10.2272-2.27008-13.74997-6.79169-3.25974-4.15359-4.8751-9.1025-4.8751-14.83349 0-5.83595 1.62624-10.77376 4.8335-14.87488 3.52256-4.5216 8.11306-6.79168 13.79157-6.79168m-163.74997.87488c6.30933 0 11.52384 2.3823 15.62496 7.16672 3.94325 4.52182 5.9168 10.00235 5.9168 16.41664 0 6.30933-1.97334 11.74827-5.9168 16.37505-4.1536 4.8896-9.36832 7.33333-15.62496 7.33333-6.20416 0-11.37707-2.44352-15.58336-7.33333-3.99574-4.62678-6-10.06571-6-16.37505 0-6.41429 1.97333-11.92576 5.91658-16.49984 4.1536-4.73194 9.35744-7.0833 15.66678-7.0833m82.58346 0c6.30912 0 11.52384 2.38229 15.62475 7.16672 3.94347 4.52181 5.9168 10.00234 5.9168 16.41664 0 6.30933-1.97333 11.74826-5.9168 16.37504-4.1536 4.8896-9.36811 7.33333-15.62496 7.33333-6.20416 0-11.41867-2.44352-15.62496-7.33333-3.99573-4.62678-6-10.06571-6-16.37504 0-6.4143 1.97333-11.92576 5.9168-16.49984 4.1536-4.73195 9.39883-7.08331 15.70816-7.08331&quot;/&gt;&lt;/svg&gt;</file><file path="misc/settings.txt">-- A list of settings, installed as a data file on the users machine.

-- Applied to cabal fields when the same semantic value is used multiple times with
-- typos/names/capitalisation.
RenameTag &quot;Silk-B.V.&quot; &quot;Silk&quot;
RenameTag &quot;Silk.-B.V.&quot; &quot;Silk&quot;
RenameTag &quot;Michael-snoyman&quot; &quot;Michael-Snoyman&quot;
RenameTag &quot;Apache-2.0&quot; &quot;Apache&quot;
RenameTag &quot;GPL-3&quot; &quot;GPL&quot;
RenameTag &quot;LGPL-2.1&quot; &quot;LGPL&quot;
RenameTag &quot;LGPL-3&quot; &quot;LGPL&quot;
RenameTag &quot;graphics&quot; &quot;Graphics&quot;
RenameTag &quot;math&quot; &quot;Math&quot;
RenameTag &quot;Unclassified&quot; &quot;&quot;
RenameTag &quot;data&quot; &quot;Data&quot;
RenameTag &quot;Edward-A.-Kmett&quot; &quot;Edward-Kmett&quot;
RenameTag &quot;Jose-Pedro-Magalhaes&quot; &quot;Jos-Pedro-Magalhes&quot;
RenameTag &quot;AUTHORS&quot; &quot;&quot;
RenameTag &quot;contributors-see-README&quot; &quot;&quot;
RenameTag &quot;author&quot; &quot;&quot;
RenameTag &quot;http://www.cse.chalmers.se/~nad/&quot; &quot;Nils Anders Danielsson&quot;
RenameTag &quot;many-others&quot; &quot;&quot;
RenameTag &quot;Error-handling&quot; &quot;Error-Handling&quot;
RenameTag &quot;Daniel-Schssler&quot; &quot;Daniel Schssler&quot;
RenameTag &quot;Various&quot; &quot;&quot;
RenameTag &quot;Various;-see-individual-modules&quot; &quot;&quot;

-- Reorder modules so the common things come first
ReorderModule &quot;base&quot; &quot;Prelude&quot;        1009
ReorderModule &quot;base&quot; &quot;Data.List&quot;      1008
ReorderModule &quot;base&quot; &quot;Data.Maybe&quot;     1007
ReorderModule &quot;base&quot; &quot;Data.Function&quot;  1006
ReorderModule &quot;base&quot; &quot;Control.Monad&quot;  1005
ReorderModule &quot;base&quot; &quot;GHC.*&quot;        (-1000)</file><file path="misc/Upgrade.hs">-- Script to upgrade a copy of Hoogle, run every day on haskell.org.
-- See docs/Haskell.org.md for details.

import Data.List.Extra
import Control.Monad
import Control.Applicative
import System.Directory.Extra
import System.Environment
import Data.Time.Clock
import System.Process.Extra
import Control.Exception.Extra
import Data.Time.Clock
import Data.Time.Format
import System.FilePath


-- APPROACH
-- have a directory &quot;hoogle-upgrade&quot; in which you do your work
-- inside each directory is a datetime name, e.g. hoogle-upgrade/20150126T001005
-- first delete all directories that are not the most recent 10
-- then create the new directory, git pull, cabal update, build, generate packages, test
-- kill the old server, start the new one
-- add yourself to a list of who was successfully started
-- write out a file in your directory called downgrade.sh, to do a quick downgrade if necessary
main :: IO ()
main = do
    args &lt;- getArgs
    let new = &quot;--old&quot; `notElem` args -- are we using new Hoogle server setup

    createDirectoryIfMissing True &quot;hoogle-upgrade&quot;

    now &lt;- getCurrentTime
    let dir = &quot;hoogle-upgrade/&quot; ++ formatTime defaultTimeLocale &quot;%Y-%m-%dT%H-%M-%S&quot; now
    now &lt;- createDirectoryIfMissing True dir
    withCurrentDirectory dir $ do

        -- Compile source
        putStrLn $ &quot;Upgrading into &quot; ++ dir
        echo system_ &quot;git clone https://github.com/ndmitchell/hoogle.git .&quot;
        sha1 &lt;- trim &lt;$&gt; echo systemOutput_ &quot;git rev-parse HEAD&quot;
        echo system_ &quot;cabal v2-update&quot;
        echo system_ &quot;cabal v2-build -j1 --only-dependencies --upgrade-dependencies --force-reinstalls --ghc-options=\&quot;+RTS -M1G\&quot;&quot;
        echo system_ &quot;cabal v2-configure \&quot;--ghc-options=-rtsopts -O2\&quot;&quot;
        echo system_ &quot;cabal v2-build -j1 --only-dependencies --upgrade-dependencies --force-reinstalls --ghc-options=\&quot;+RTS -M1G\&quot;&quot;
        echo system_ &quot;GHCRTS=-M1G cabal v2-install -j1 --installdir=bin&quot;
        let exe = normalise &quot;bin/hoogle&quot;

        -- Compile databases
        echo system_ $ &quot;hoogle_datadir=. &quot; ++ exe ++ &quot; generate --database=haskell.hoo +RTS -M900M -T -N2&quot;
        echo system_ $ &quot;hoogle_datadir=. &quot; ++ exe ++ &quot; test --database=haskell.hoo&quot;

        when False $ -- Frege database has disappeared
            echo system_ $ &quot;hoogle_datadir=. &quot; ++ exe ++ &quot; generate --database=frege.hoo --frege +RTS -M900M -T -N2&quot;

        when False $ do -- DAML now has its own server
            createDirectoryIfMissing True &quot;daml&quot;
            echo system_ &quot;curl https://docs.daml.com/hoogle_db/base.txt --output daml/base.txt&quot;
            echo system_ $ &quot;hoogle_datadir=. &quot; ++ exe ++ &quot; generate --database=daml.hoo --local=daml +RTS -M900M -T -N2&quot;

        ignore $ echo system_ &quot;pkill hoogle&quot;
        let hoogle database port log links = echo system_ $
                &quot;hoogle_datadir=. &quot; ++
                &quot;nohup &quot; ++ exe ++ &quot; server --database=&quot; ++ database ++ &quot; &quot; ++
                &quot;--port=&quot; ++ show (if new then 50021 + port else 8443 + port) ++ &quot; &quot; ++
                (if new then &quot;&quot; else &quot;--https --key=/etc/letsencrypt/live/hoogle.haskell.org/privkey.pem --cert=/etc/letsencrypt/live/hoogle.haskell.org/fullchain.pem &quot;) ++
                -- &quot;--cdn=https://rawcdn.githack.com/ndmitchell/hoogle/&quot; ++ sha1 ++ &quot;/html/ &quot; ++
                &quot;--log=../../log&quot; ++ log ++ &quot;.txt &quot; ++ (if links then &quot;--links &quot; else &quot;&quot;) ++ &quot; +RTS -T -N4 &gt;&gt; ../../out&quot; ++ log ++ &quot;.txt 2&gt;&amp;1 &amp;&quot;
        hoogle &quot;haskell.hoo&quot; 0 &quot;&quot; True
        -- hoogle &quot;frege.hoo&quot; 1 &quot;-frege&quot; False
        -- hoogle &quot;daml.hoo&quot; 2 &quot;-daml&quot; False

        unless new $ do
            ignore $ echo system_ &quot;pkill rdr2tls&quot;
            echo system_ &quot;nohup rdr2tls --port=8080 --path=hoogle.haskell.org &gt;&gt; ../../out-rdr2tls.txt 2&gt;&amp;1 &amp;&quot;
            -- echo system_ &quot;nohup rdr2tls --port=8081 --path=hoogle.haskell.org:8444 &gt;&gt; ../../out-frege-rdr2tls.txt 2&gt;&amp;1 &amp;&quot;
            -- echo system_ &quot;nohup rdr2tls --port=8082 --path=hoogle.haskell.org:8445 &gt;&gt; ../../out-daml-rdr2tls.txt 2&gt;&amp;1 &amp;&quot;

    appendFile &quot;hoogle-upgrade/upgrade.txt&quot; $ dir ++ &quot;\n&quot;

    dirs &lt;- filterM doesDirectoryExist =&lt;&lt; listContents &quot;hoogle-upgrade&quot;
    forM_ (dropEnd 10 $ sort dirs) $ \dir -&gt; do
        putStrLn $ &quot;Cleaning &quot; ++ dir ++ &quot;...&quot;
        removeDirectoryRecursive dir

    putStrLn &quot;Successfully upgraded&quot;


echo :: (String -&gt; IO a) -&gt; String -&gt; IO a
echo f x = putStrLn (&quot;# &quot; ++ x) &gt;&gt; f x</file><file path="src/Action/CmdLine.hs">{-# LANGUAGE DeriveDataTypeable, RecordWildCards #-}
{-# OPTIONS_GHC -fno-warn-missing-fields -fno-cse #-}

module Action.CmdLine(
    CmdLine(..), Language(..),
    getCmdLine, defaultDatabaseLang,
    defaultGenerate,
    whenLoud, whenNormal
    ) where

import Data.List.Extra
import Data.Version
import General.Util
import Paths_hoogle (version)
import System.Console.CmdArgs
import System.Directory
import System.Environment
import System.FilePath
import System.IO

data Language = Haskell | Frege deriving (Data,Typeable,Show,Eq,Enum,Bounded)

data CmdLine
    = Search
        {color :: Maybe Bool
        ,json :: Bool
        ,jsonl :: Bool
        ,link :: Bool
        ,numbers :: Bool
        ,info :: Bool
        ,database :: FilePath
        ,count :: Maybe Int
        ,query :: [String]
        ,repeat_ :: Int
        ,language :: Language
        ,compare_ :: [String]
        }
    | Generate
        {download :: Maybe Bool
        ,database :: FilePath
        ,insecure :: Bool
        ,include :: [String]
        ,count :: Maybe Int
        ,local_ :: [FilePath]
        ,haddock :: Maybe FilePath
        ,debug :: Bool
        ,language :: Language
        }
    | Server
        {port :: Int
        ,database :: FilePath
        ,cdn :: String
        ,logs :: FilePath
        ,local :: Bool
        ,haddock :: Maybe FilePath
        ,links :: Bool
        ,language :: Language
        ,scope :: String
        ,home :: String
        ,host :: String
        ,https :: Bool
        ,cert :: FilePath
        ,key :: FilePath
        ,datadir :: Maybe FilePath
        ,no_security_headers :: Bool
        }
    | Replay
        {logs :: FilePath
        ,database :: FilePath
        ,repeat_ :: Int
        ,language :: Language
        ,scope :: String
        }
    | Test
        { deep :: Bool
        , disable_network_tests  :: Bool
        , database :: FilePath
        , language :: Language
        }
      deriving (Data,Typeable,Show)

defaultDatabaseLang :: Language -&gt; IO FilePath
defaultDatabaseLang lang = do
    xdgLocation &lt;- getXdgDirectory XdgData &quot;hoogle&quot;
    legacyLocation &lt;- getAppUserDataDirectory &quot;hoogle&quot;
    doesXdgPathExist &lt;- doesPathExist xdgLocation
    doesLegacyPathExist &lt;- doesPathExist legacyLocation

    dir &lt;- case (doesXdgPathExist, doesLegacyPathExist) of
      -- On Windows XDG location and legacy location are identical
      _ | xdgLocation == legacyLocation -&gt; pure xdgLocation
      (_, False) -&gt; pure xdgLocation
      (True, True) -&gt; do
        hPutStrLn stderr $
          &quot;Warning: Legacy location ignored (&quot; ++ legacyLocation ++ &quot;),&quot;
          ++ &quot;since xdg location is available (&quot; ++ xdgLocation ++&quot;).&quot;
        pure xdgLocation
      (False, True) -&gt; do
        -- TODO: renable after release
        --hPutStrLn stderr $ &quot;Warning: &quot; ++ legacyLocation ++ &quot; is deprecated.&quot;
        --  ++ &quot;Consider moving it to $XDG_DATA_HOME/hoogle (&quot; ++ xdgLocation ++ &quot;)&quot;
        pure legacyLocation
    pure $ dir &lt;/&gt; &quot;default-&quot; ++ lower (show lang) ++ &quot;-&quot; ++ showVersion (trimVersion 3 version) ++ &quot;.hoo&quot;

getCmdLine :: [String] -&gt; IO CmdLine
getCmdLine args = do
    args &lt;- withArgs args $ cmdArgsRun cmdLineMode

    -- fill in the default database
    args &lt;- if database args /= &quot;&quot; then pure args else do
        db &lt;- defaultDatabaseLang $ language args; pure args{database=db}

    -- fix up people using Hoogle 4 instructions
    args &lt;- case args of
        Generate{..} | &quot;all&quot; `elem` include -&gt; do
            putStrLn &quot;Warning: &apos;all&apos; argument is no longer required, and has been ignored.&quot;
            pure $ args{include = delete &quot;all&quot; include}
        _ -&gt; pure args

    pure args


defaultGenerate :: CmdLine
defaultGenerate = generate{language=Haskell}


cmdLineMode = cmdArgsMode $ modes [search_ &amp;= auto,generate,server,replay,test]
    &amp;= verbosity &amp;= program &quot;hoogle&quot;
    &amp;= summary (&quot;Hoogle &quot; ++ showVersion version ++ &quot;, https://hoogle.haskell.org/&quot;)

search_ = Search
    {color = def &amp;= name &quot;colour&quot; &amp;= help &quot;Use colored output (requires ANSI terminal)&quot;
    ,json = def &amp;= name &quot;json&quot; &amp;= help &quot;Get result as JSON&quot;
    ,jsonl = def &amp;= name &quot;jsonl&quot; &amp;= help &quot;Get result as JSONL (JSON Lines)&quot;
    ,link = def &amp;= help &quot;Give URL&apos;s for each result&quot;
    ,numbers = def &amp;= help &quot;Give counter for each result&quot;
    ,info = def &amp;= help &quot;Give extended information about the first n results (set n with --count, default is 1)&quot;
    ,database = def &amp;= typFile &amp;= help &quot;Name of database to use (use .hoo extension)&quot;
    ,count = Nothing &amp;= name &quot;n&quot; &amp;= help &quot;Maximum number of results to return (defaults to 10)&quot;
    ,query = def &amp;= args &amp;= typ &quot;QUERY&quot;
    ,repeat_ = 1 &amp;= help &quot;Number of times to repeat (for benchmarking)&quot;
    ,language = enum [x &amp;= explicit &amp;= name (lower $ show x) &amp;= help (&quot;Work with &quot; ++ show x) | x &lt;- enumerate] &amp;= groupname &quot;Language&quot;
    ,compare_ = def &amp;= help &quot;Type signatures to compare against&quot;
    } &amp;= help &quot;Perform a search&quot;

generate = Generate
    {download = def &amp;= help &quot;Download all files from the web&quot;
    ,insecure = def &amp;= help &quot;Allow insecure HTTPS connections&quot;
    ,include = def &amp;= args &amp;= typ &quot;PACKAGE&quot;
    ,local_ = def &amp;= opt &quot;&quot; &amp;= help &quot;Index local packages and link to local haddock docs&quot;
    ,count = Nothing &amp;= name &quot;n&quot; &amp;= help &quot;Maximum number of packages to index (defaults to all)&quot;
    ,haddock = def &amp;= help &quot;Use local haddocks&quot;
    ,debug = def &amp;= help &quot;Generate debug information&quot;
    } &amp;= help &quot;Generate Hoogle databases&quot;

server = Server
    {port = 8080 &amp;= typ &quot;INT&quot; &amp;= help &quot;Port number&quot;
    ,cdn = &quot;&quot; &amp;= typ &quot;URL&quot; &amp;= help &quot;URL prefix to use&quot;
    ,logs = &quot;&quot; &amp;= opt &quot;log.txt&quot; &amp;= typFile &amp;= help &quot;File to log requests to (defaults to stdout)&quot;
    ,local = False &amp;= help &quot;Allow following file:// links, restricts to 127.0.0.1  Set --host explicitely (including to &apos;*&apos; for any host) to override the localhost-only behaviour&quot;
    ,haddock = def &amp;= help &quot;Serve local haddocks from a specified directory&quot;
    ,scope = def &amp;= help &quot;Default scope to start with&quot;
    ,links = def &amp;= help &quot;Display extra links&quot;
    ,home = &quot;https://hoogle.haskell.org&quot; &amp;= typ &quot;URL&quot; &amp;= help &quot;Set the URL linked to by the Hoogle logo.&quot;
    ,host = &quot;&quot; &amp;= help &quot;Set the host to bind on (e.g., an ip address; &apos;!4&apos; for ipv4-only; &apos;!6&apos; for ipv6-only; default: &apos;*&apos; for any host).&quot;
    ,https = def &amp;= help &quot;Start an https server (use --cert and --key to specify paths to the .pem files)&quot;
    ,cert = &quot;cert.pem&quot; &amp;= typFile &amp;= help &quot;Path to the certificate pem file (when running an https server)&quot;
    ,key = &quot;key.pem&quot; &amp;= typFile &amp;= help &quot;Path to the key pem file (when running an https server)&quot;
    ,datadir = def &amp;= help &quot;Override data directory paths&quot;
    ,no_security_headers = False &amp;= help &quot;Don&apos;t send CSP security headers&quot;
    } &amp;= help &quot;Start a Hoogle server&quot;

replay = Replay
    {logs = &quot;log.txt&quot; &amp;= args &amp;= typ &quot;FILE&quot;
    } &amp;= help &quot;Replay a log file&quot;

test = Test
    { deep    = False &amp;= help &quot;Run extra long tests&quot;
    , disable_network_tests = False  &amp;= help &quot;Disables the use of network tests&quot;
    } &amp;= help &quot;Run the test suite&quot;</file><file path="src/Action/Generate.hs">{-# LANGUAGE ViewPatterns, TupleSections, RecordWildCards, ScopedTypeVariables, PatternGuards #-}

module Action.Generate(actionGenerate) where

import Data.List.Extra
import System.FilePath
import System.Directory.Extra
import System.IO.Extra
import Data.Tuple.Extra
import Control.Exception.Extra
import Data.IORef
import Data.Maybe
import qualified Data.Set as Set
import qualified Data.Map.Strict as Map
import Control.Monad.Extra
import Data.Monoid
import Data.Ord
import System.Console.CmdArgs.Verbosity
import Prelude

import Output.Items
import Output.Tags
import Output.Names
import Output.Types
import Input.Cabal
import Input.Haddock
import Input.Download
import Input.Reorder
import Input.Set
import Input.Settings
import Input.Item
import General.Util
import General.Store
import General.Timing
import General.Str
import Action.CmdLine
import General.Conduit
import Control.DeepSeq
import Distribution.Package (mkPackageName, unPackageName)

{-


data GenList
    = GenList_Package String -- a literally named package
    | GenList_GhcPkg String -- command to run, or &quot;&quot; for @ghc-pkg list@
    | GenList_Stackage String -- URL of stackage file, defaults to @http://www.stackage.org/lts/cabal.config@
    | GenList_Dependencies String -- dependencies in a named .cabal file
    | GenList_Sort String -- URL of file to sort by, defaults to @http://packdeps.haskellers.com/reverse@

data GenTags
    = GenTags_GhcPkg String -- command to run, or &quot;&quot; for @ghc-pkg dump@
    | GenTags_Diff FilePath -- a diff to apply to previous metadata
    | GenTags_Tarball String -- tarball of Cabal files, defaults to http://hackage.haskell.org/packages/index.tar.gz
    | GetTags_Cabal FilePath -- tarball to get tag information from

data GenData
    = GenData_File FilePath -- a file containing package data
    | GenData_Tarball String -- URL where a tarball of data files resides


* `hoogle generate` - generate for all things in Stackage based on Hackage information.
* `hoogle generate --source=file1.txt --source=local --source=stackage --source=hackage --source=tarball.tar.gz`

Which files you want to index. Currently the list on stackage, could be those locally installed, those in a .cabal file etc. A `--list` flag, defaults to `stackage=url`. Can also be `ghc-pkg`, `ghc-pkg=user` `ghc-pkg=global`. `name=p1`.

Extra metadata you want to apply. Could be a file. `+shake author:Neil-Mitchell`, `-shake author:Neil-Mitchel`. Can be sucked out of .cabal files. A `--tags` flag, defaults to `tarball=url` and `diff=renamings.txt`.

Where the haddock files are. Defaults to `tarball=hackage-url`. Can also be `file=p1.txt`. Use `--data` flag.

Defaults to: `hoogle generate --list=ghc-pkg --list=constrain=stackage-url`.

Three pieces of data:

* Which packages to index, in order.
* Metadata.


generate :: Maybe Int -&gt; [GenList] -&gt; [GenTags] -&gt; [GenData] -&gt; IO ()
-- how often to redownload, where to put the files



generate :: FilePath -&gt; [(String, [(String, String)])] -&gt; [(String, LBS.ByteString)] -&gt; IO ()
generate output metadata = ...
-}


-- -- generate all
-- @tagsoup -- generate tagsoup
-- @tagsoup filter -- search the tagsoup package
-- filter -- search all

type Download = String -&gt; URL -&gt; IO FilePath

readHaskellOnline :: Timing -&gt; Settings -&gt; Download -&gt; IO (Map.Map PkgName Package, Set.Set PkgName, ConduitT () (PkgName, URL, LBStr) IO ())
readHaskellOnline timing settings download = do
    stackageLts &lt;- download &quot;haskell-stackage-lts.txt&quot; &quot;https://www.stackage.org/lts/cabal.config&quot;
    stackageNightly &lt;- download &quot;haskell-stackage-nightly.txt&quot; &quot;https://www.stackage.org/nightly/cabal.config&quot;
    platform &lt;- download &quot;haskell-platform.txt&quot; &quot;https://raw.githubusercontent.com/haskell/haskell-platform/master/hptool/src/Releases2015.hs&quot;
    cabals   &lt;- download &quot;haskell-cabal.tar.gz&quot; &quot;https://hackage.haskell.org/packages/index.tar.gz&quot;
    hoogles  &lt;- download &quot;haskell-hoogle.tar.gz&quot; &quot;https://hackage.haskell.org/packages/hoogle.tar.gz&quot;

    -- peakMegabytesAllocated = 2
    setStackage &lt;- Set.map mkPackageName &lt;$&gt; (Set.union &lt;$&gt; setStackage stackageLts &lt;*&gt; setStackage stackageNightly)
    setPlatform &lt;- Set.map mkPackageName &lt;$&gt; setPlatform platform
    setGHC &lt;- Set.map mkPackageName &lt;$&gt; setGHC platform

    cbl &lt;- timed timing &quot;Reading Cabal&quot; $ parseCabalTarball settings cabals
    let want = Set.insert (mkPackageName &quot;ghc&quot;) $ Set.unions [setStackage, setPlatform, setGHC]
    cbl &lt;- pure $ flip Map.mapWithKey cbl $ \name p -&gt;
        p{packageTags =
            [(strPack &quot;set&quot;,strPack &quot;included-with-ghc&quot;) | name `Set.member` setGHC] ++
            [(strPack &quot;set&quot;,strPack &quot;haskell-platform&quot;) | name `Set.member` setPlatform] ++
            [(strPack &quot;set&quot;,strPack &quot;stackage&quot;) | name `Set.member` setStackage] ++
            packageTags p}

    let source = do
            tar &lt;- liftIO $ tarballReadFiles hoogles
            forM_ tar $ \(mkPackageName . takeBaseName -&gt; name, src) -&gt;
                yield (name, hackagePackageURL name, src)
    pure (cbl, want, source)


readHaskellDirs :: Timing -&gt; Settings -&gt; [FilePath] -&gt; IO (Map.Map PkgName Package, Set.Set PkgName, ConduitT () (PkgName, URL, LBStr) IO ())
readHaskellDirs timing settings dirs = do
    files &lt;- concatMapM listFilesRecursive dirs
    -- We reverse/sort the list because of #206
    -- Two identical package names with different versions might be foo-2.0 and foo-1.0
    -- We never distinguish on versions, so they are considered equal when reordering
    -- So put 2.0 first in the list and rely on stable sorting. A bit of a hack.
    let order a = second Down $ parseTrailingVersion a
    let packages = map (mkPackageName . takeBaseName &amp;&amp;&amp; id) $ sortOn (map order . splitDirectories) $ filter ((==) &quot;.txt&quot; . takeExtension) files
    cabals &lt;- mapM parseCabal $ filter ((==) &quot;.cabal&quot; . takeExtension) files
    let source = forM_ packages $ \(name, file) -&gt; do
            src &lt;- liftIO $ bstrReadFile file
            dir &lt;- liftIO $ canonicalizePath $ takeDirectory file
            let url = &quot;file://&quot; ++ [&apos;/&apos; | not $ &quot;/&quot; `isPrefixOf` dir] ++ replace &quot;\\&quot; &quot;/&quot; dir ++ &quot;/&quot;
            when (isJust $ bstrSplitInfix (bstrPack &quot;@package &quot; &lt;&gt; bstrPack (unPackageName name)) src) $
                yield (name, url, lbstrFromChunks [src])
    pure (Map.union
                (Map.fromList cabals)
                (Map.fromListWith (&lt;&gt;) $ map generateBarePackage packages)
           ,Set.fromList $ map fst packages, source)
  where
    parseCabal fp = do
        src &lt;- bstrReadFile fp
        let pkg = readCabal settings src
        pure (mkPackageName $ takeBaseName fp, pkg)

    generateBarePackage (name, file) =
        (name, mempty{packageTags = (strPack &quot;set&quot;, strPack &quot;all&quot;) : sets})
      where
        sets = map setFromDir $ filter (`isPrefixOf` file) dirs
        setFromDir dir = (strPack &quot;set&quot;, strPack $ takeFileName $ dropTrailingPathSeparator dir)

readFregeOnline :: Timing -&gt; Download -&gt; IO (Map.Map PkgName Package, Set.Set PkgName, ConduitT () (PkgName, URL, LBStr) IO ())
readFregeOnline timing download = do
    frege &lt;- download &quot;frege-frege.txt&quot; &quot;https://github.com/Frege/try-frege/raw/refs/heads/master/try-frege-web/src/main/webapp/hoogle-frege.txt&quot;
    let source = do
            src &lt;- liftIO $ bstrReadFile frege
            yield (mkPackageName &quot;frege&quot;, &quot;http://google.com/&quot;, lbstrFromChunks [src])
    pure (Map.empty, Set.singleton $ mkPackageName &quot;frege&quot;, source)


readHaskellGhcpkg :: Timing -&gt; Settings -&gt; IO (Map.Map PkgName Package, Set.Set PkgName, ConduitT () (PkgName, URL, LBStr) IO ())
readHaskellGhcpkg timing settings = do
    cbl &lt;- timed timing &quot;Reading ghc-pkg&quot; $ readGhcPkg settings
    let source =
            forM_ (Map.toList cbl) $ \(name,Package{..}) -&gt; whenJust packageDocs $ \docs -&gt; do
                let file = docs &lt;/&gt; unPackageName name &lt;.&gt; &quot;txt&quot;
                whenM (liftIO $ doesFileExist file) $ do
                    src &lt;- liftIO $ bstrReadFile file
                    docs &lt;- liftIO $ canonicalizePath docs
                    let url = &quot;file://&quot; ++ [&apos;/&apos; | not $ all isPathSeparator $ take 1 docs] ++
                              replace &quot;\\&quot; &quot;/&quot; (addTrailingPathSeparator docs)
                    yield (name, url, lbstrFromChunks [src])
    cbl &lt;- pure $ let ts = map (both strPack) [(&quot;set&quot;,&quot;stackage&quot;),(&quot;set&quot;,&quot;installed&quot;)]
                    in Map.map (\p -&gt; p{packageTags = ts ++ packageTags p}) cbl
    pure (cbl, Map.keysSet cbl, source)

-- | @hoogle generate --haddock=path/to/doc@ works similarly to @hoogle generate --local@,
-- getting package info from a local ghc-pkg database, but uses @path/to/doc@
-- as the canonical source of Haddock documentation.
-- @path/to/doc@ should be a path to the directory that contains the root @index.html@
-- generated by cabal haddock or stack haddock.
-- Paths stored in the database are relative to this root.
--
-- @hoogle server --haddock=path/to/doc@ is intended to be used with a database
-- containing relative paths. In contrast to @hoogle server --local@,
-- paths relative to the filesystem root are not allowed;
-- only files from @path/to/doc@ are served.
--
-- These features are intended to be used together, when you want to
-- create a Hoogle index for your project in one place, then serve it somewhere else.
-- This enables a workflow such as the following:
--
-- 1. Run cabal haddock or stack haddock on your build server
-- 2. Run hoogle generate --haddock=path/to/doc on your build server (this assumes you know where the docs were written)
-- 3. Deploy the Hoogle database and Haddock files to your documentation server &amp; run hoogle server --haddock=new/path/to/doc
--
-- from https://github.com/ndmitchell/hoogle/pull/202
readHaskellHaddock :: Timing -&gt; Settings -&gt; FilePath -&gt; IO (Map.Map PkgName Package, Set.Set PkgName, ConduitT () (PkgName, URL, LBStr) IO ())
readHaskellHaddock timing settings docBaseDir = do
    cbl &lt;- timed timing &quot;Reading ghc-pkg&quot; $ readGhcPkg settings
    let source =
            forM_ (Map.toList cbl) $ \(name, p@Package{..}) -&gt; do
                let docs = docDir (unPackageName name) p
                    file = docBaseDir &lt;/&gt; docs &lt;/&gt; unPackageName name &lt;.&gt; &quot;txt&quot;
                whenM (liftIO $ doesFileExist file) $ do
                    src &lt;- liftIO $ bstrReadFile file
                    let url = [&apos;/&apos; | not $ all isPathSeparator $ take 1 docs] ++
                              replace &quot;\\&quot; &quot;/&quot; (addTrailingPathSeparator docs)
                    yield (name, url, lbstrFromChunks [src])
    cbl &lt;- pure $ let ts = map (both strPack) [(&quot;set&quot;,&quot;stackage&quot;),(&quot;set&quot;,&quot;installed&quot;)]
                    in Map.map (\p -&gt; p{packageTags = ts ++ packageTags p}) cbl
    pure (cbl, Map.keysSet cbl, source)

    where docDir name Package{..} = name ++ &quot;-&quot; ++ strUnpack packageVersion

actionGenerate :: CmdLine -&gt; IO ()
actionGenerate g@Generate{..} = withTiming (if debug then Just $ replaceExtension database &quot;timing&quot; else Nothing) $ \timing -&gt; do
    putStrLn &quot;Starting generate&quot;
    createDirectoryIfMissing True $ takeDirectory database
    whenLoud $ putStrLn $ &quot;Generating files to &quot; ++ takeDirectory database

    let warnFlagIgnored thisFlag reason ignoredFlagPred ignoredFlag =
          when ignoredFlagPred $ putStrLn $ &quot;Warning: &quot; &lt;&gt; thisFlag &lt;&gt; &quot; is &quot; &lt;&gt; reason &lt;&gt; &quot;, which means &quot; &lt;&gt; ignoredFlag &lt;&gt; &quot; is ignored.&quot;

    let doDownload name url = do
          let download&apos; = case download of
                Just True -&gt; AlwaysDownloadInput
                Just False -&gt; NeverDownloadInput
                Nothing -&gt; DownloadInputIfNotThere
          downloadInput timing insecure download&apos; (takeDirectory database) name url

    settings &lt;- loadSettings
    (cbl, want, source) &lt;- case language of
        Haskell | Just dir &lt;- haddock -&gt; do
                    warnFlagIgnored &quot;--haddock&quot; &quot;set&quot; (local_ /= []) &quot;--local&quot;
                    warnFlagIgnored &quot;--haddock&quot; &quot;set&quot; (isJust download) &quot;--download&quot;
                    readHaskellHaddock timing settings dir
                | [&quot;&quot;] &lt;- local_ -&gt; do
                    warnFlagIgnored &quot;--local&quot; &quot;used as flag (no paths)&quot; (isJust download) &quot;--download&quot;
                    readHaskellGhcpkg timing settings
                | [] &lt;- local_ -&gt; do readHaskellOnline timing settings doDownload
                | otherwise -&gt; readHaskellDirs timing settings local_
        Frege | [] &lt;- local_ -&gt; readFregeOnline timing doDownload
              | otherwise -&gt; errorIO &quot;No support for local Frege databases&quot;
    (cblErrs, popularity) &lt;- evaluate $ packagePopularity cbl
    cbl &lt;- evaluate $ Map.map (\p -&gt; p{packageDepends=[]}) cbl -- clear the memory, since the information is no longer used
    evaluate popularity

    want &lt;- pure $ if include /= [] then Set.fromList $ map mkPackageName include else want
    want &lt;- pure $ case count of Nothing -&gt; want; Just count -&gt; Set.fromList $ take count $ Set.toList want

    (stats, _) &lt;- storeWriteFile database $ \store -&gt; do
        xs &lt;- withBinaryFile (database `replaceExtension` &quot;warn&quot;) WriteMode $ \warnings -&gt; do
            hSetEncoding warnings utf8
            hPutStr warnings $ unlines cblErrs
            nCblErrs &lt;- evaluate $ length cblErrs

            itemWarn &lt;- newIORef 0
            let warning msg = do modifyIORef itemWarn succ; hPutStrLn warnings msg

            let consume :: ConduitM (Int, (PkgName, URL, LBStr)) (Maybe Target, [Item]) IO ()
                consume = awaitForever $ \(i, (unPackageName -&gt; pkg, url, body)) -&gt; do
                    timedOverwrite timing (&quot;[&quot; ++ show i ++ &quot;/&quot; ++ show (Set.size want) ++ &quot;] &quot; ++ pkg) $
                        parseHoogle (\msg -&gt; warning $ pkg ++ &quot;:&quot; ++ msg) url body

            writeItems store $ \items -&gt; do
                xs &lt;- runConduit $
                    source .|
                    filterC (flip Set.member want . fst3) .|
                    void ((|$|)
                        (zipFromC 1 .| consume)
                        (do seen &lt;- fmap Set.fromList $ mapMC (evaluate . force . fst3) .| sinkList
                            let missing = [x | x &lt;- Set.toList $ want `Set.difference` seen
                                             , fmap packageLibrary (Map.lookup x cbl) /= Just False]
                            liftIO $ putStrLn &quot;&quot;
                            liftIO $ whenNormal $ when (missing /= []) $ do
                                putStrLn $ &quot;Packages missing documentation: &quot; ++ unwords (sortOn lower $ map unPackageName missing)
                            liftIO $ when (Set.null seen) $
                                exitFail &quot;No packages were found, aborting (use no arguments to index all of Stackage)&quot;
                            -- synthesise things for Cabal packages that are not documented
                            forM_ (Map.toList cbl) $ \(name, Package{..}) -&gt; when (name `Set.notMember` seen) $ do
                                let ret prefix = yield $ fakePackage name $ prefix ++ trim (strUnpack packageSynopsis)
                                if name `Set.member` want then
                                    (if packageLibrary
                                        then ret &quot;Documentation not found, so not searched.\n&quot;
                                        else ret &quot;Executable only. &quot;)
                                else if null include then
                                    ret &quot;Not on Stackage, so not searched.\n&quot;
                                else
                                    pure ()
                            ))
                    .| pipelineC 10 (items .| sinkList)

                itemWarn &lt;- readIORef itemWarn
                when (itemWarn &gt; 0) $
                    putStrLn $ &quot;Found &quot; ++ show itemWarn ++ &quot; warnings when processing items&quot;
                pure [(a,b) | (a,bs) &lt;- xs, b &lt;- bs]

        itemsMemory &lt;- getStatsCurrentLiveBytes
        xs &lt;- timed timing &quot;Reordering items&quot; $ pure $! reorderItems settings (\s -&gt; maybe 1 negate $ Map.lookup s popularity) xs
        timed timing &quot;Writing tags&quot; $ writeTags store (`Set.member` want) (\x -&gt; maybe [] (map (both strUnpack) . packageTags) $ Map.lookup x cbl) xs
        timed timing &quot;Writing names&quot; $ writeNames store xs
        timed timing &quot;Writing types&quot; $ writeTypes store (if debug then Just $ dropExtension database else Nothing) xs

        x &lt;- getVerbosity
        when (x &gt;= Loud) $
            whenJustM getStatsDebug print
        when (x &gt;= Normal) $ do
            whenJustM getStatsPeakAllocBytes $ \x -&gt;
                putStrLn $ &quot;Peak of &quot; ++ x ++ &quot;, &quot; ++ fromMaybe &quot;unknown&quot; itemsMemory ++ &quot; for items&quot;

    when debug $
        writeFile (database `replaceExtension` &quot;store&quot;) $ unlines stats</file><file path="src/Action/Search.hs">{-# LANGUAGE LambdaCase, MultiWayIf, RecordWildCards, ScopedTypeVariables,
             TupleSections #-}

module Action.Search
    (actionSearch, withSearch, search
    ,targetInfo
    ,targetResultDisplay
    ,action_search_test
    ) where

import Control.DeepSeq
import Control.Exception.Extra
import Control.Monad.Extra
import qualified Data.Aeson as JSON
import qualified Data.ByteString.Lazy.Char8 as LBS
import Data.Functor.Identity
import Data.List.Extra
import qualified Data.Map as Map
import Data.Maybe
import qualified Data.Set as Set
import System.Directory
import Text.Blaze.Renderer.Utf8
import Safe
import System.Console.ANSI
    (hSupportsANSI, hyperlinkCode, setSGRCode
    ,SGR (SetColor), ConsoleLayer (Foreground)
    ,ColorIntensity (Vivid, Dull), Color (Yellow))
import System.IO (stdout)

import Action.CmdLine
import General.Store
import General.Util
import Input.Item
import Output.Items
import Output.Names
import Output.Tags
import Output.Types
import Query

-- -- generate all
-- @tagsoup -- generate tagsoup
-- @tagsoup filter -- search the tagsoup package
-- filter -- search all

actionSearch :: CmdLine -&gt; IO ()
actionSearch Search{..} = replicateM_ repeat_ $ -- deliberately reopen the database each time
    withSearch database $ \store -&gt;
        if null compare_ then do
            count&apos; &lt;- pure $ fromMaybe 10 count
            (q, res) &lt;- pure $ search store $ parseQuery $ unwords query
            whenLoud $ putStrLn $ &quot;Query: &quot; ++ unescapeHTML (LBS.unpack $ renderMarkup $ renderQuery q)
            color&apos; &lt;- case color of
              Just b -&gt; pure b
              Nothing -&gt; hSupportsANSI stdout
            let (shown, hidden) = splitAt count&apos; $ nubOrd $ map (targetResultDisplay link color&apos; q) res
            if null res then
                putStrLn &quot;No results found&quot;
             else if info then do
                 mapM_ (putStr . targetInfo color&apos; q)
                  $ (case count of
                    Just c -&gt; take c
                    Nothing -&gt; singleton . headErr) res
             else do
                if | json -&gt; LBS.putStrLn $ JSON.encode $ maybe id take count $ map unHTMLtargetItem res
                   | jsonl -&gt; mapM_ (LBS.putStrLn . JSON.encode) $ maybe id take count $ map unHTMLtargetItem res
                   | otherwise -&gt; putStr $ unlines $ if numbers then addCounter shown else shown
                when (hidden /= [] &amp;&amp; not json) $ do
                    whenNormal $ putStrLn $ &quot;-- plus more results not shown, pass --count=&quot; ++ show (count&apos;+10) ++ &quot; to see more&quot;
        else do
            let parseType x = case parseQuery x of
                                  [QueryType t] -&gt; (pretty t, hseToSig t)
                                  _ -&gt; error $ &quot;Expected a type signature, got: &quot; ++ x
            putStr $ unlines $ searchFingerprintsDebug store (parseType $ unwords query) (map parseType compare_)

-- | Returns the details printed out when hoogle --info is called
targetInfo :: Bool -&gt; [Query] -&gt; Target -&gt; String
targetInfo color qs Target{..} =
    unlines $ [ unHTML . (if color then ansiHighlight qs else id) $ targetItem ] ++
              [ unwords packageModule | not $ null packageModule] ++
              [ unHTML targetDocs ]
            where packageModule = map fst $ catMaybes [targetPackage, targetModule]

-- | Returns the Target formatted as an item to display in the results
-- | Bool arguments decide whether links and colors are shown
targetResultDisplay :: Bool -&gt; Bool -&gt; [Query] -&gt; Target -&gt; String
targetResultDisplay link color qs Target{..} = unHTML $ unwords $
        map fst (maybeToList targetModule) ++
        [if color then highlightFull targetItem else targetItem] ++
        [&quot;-- &quot; ++ targetURL | link]
     where
        highlightFull = hyperlinkCode targetURL . ansiHighlight qs

ansiHighlight :: [Query] -&gt; String -&gt; String
ansiHighlight = highlightItem id id ((dull ++) . (++ rst)) ((bold ++) . (++ rst))
    where
        dull = setSGRCode [SetColor Foreground Dull Yellow]
        bold = setSGRCode [SetColor Foreground Vivid Yellow]
        rst = setSGRCode []

unHTMLtargetItem :: Target -&gt; Target
unHTMLtargetItem target = target {targetItem = unHTML $ targetItem target}

addCounter :: [String] -&gt; [String]
addCounter = zipWithFrom (\i x -&gt; show i ++ &quot;) &quot; ++ x) 1

withSearch :: NFData a =&gt; FilePath -&gt; (StoreRead -&gt; IO a) -&gt; IO a
withSearch database act = do
    unlessM (doesFileExist database) $ do
        exitFail $ &quot;Error, database does not exist (run &apos;hoogle generate&apos; first)\n&quot; ++
                   &quot;    Filename: &quot; ++ database
    storeReadFile database act


search :: StoreRead -&gt; [Query] -&gt; ([Query], [Target])
search store qs = runIdentity $ do
    (qs, exact, filt, list) &lt;- pure $ applyTags store  qs
    is &lt;- case (filter isQueryName qs, filter isQueryType qs) of
        ([], [] ) -&gt; pure list
        ([], t:_) -&gt; pure $ searchTypes store $ hseToSig $ fromQueryType t
        (xs, [] ) -&gt; pure $ searchNames store exact $ map fromQueryName xs
        (xs, t:_) -&gt; do
            nam &lt;- pure $ Set.fromList $ searchNames store exact $ map fromQueryName xs
            pure $ filter (`Set.member` nam) $ searchTypes store $ hseToSig $ fromQueryType t
    let look = lookupItem store
    pure (qs, map look $ filter filt is)

action_search_test :: Bool -&gt; FilePath -&gt; IO ()
action_search_test sample database = testing &quot;Action.Search.search&quot; $ withSearch database $ \store -&gt; do
    let noResults a = do
          res &lt;- pure $ snd $ search store (parseQuery a)
          case res of
              [] -&gt; putChar &apos;.&apos;
              _ -&gt; errorIO $ &quot;Searching for: &quot; ++ show a ++ &quot;\nGot: &quot; ++ show (take 1 res) ++ &quot;\n expected none&quot;
    let a ==$ f = do
            res &lt;- pure $ snd $ search store (parseQuery a)
            case res of
                Target{..}:_ | f targetURL -&gt; putChar &apos;.&apos;
                _ -&gt; errorIO $ &quot;Searching for: &quot; ++ show a ++ &quot;\nGot: &quot; ++ show (take 1 res)
    let a === b = a ==$ (== b)

    let query :: String -&gt; [ExpectedQueryResult] -&gt; IO ()
        query a qrs = let results = deDup $ snd (search store (parseQuery a))
                      in forM_ qrs $ \qr -&gt; case matchQR qr results of
                                              Success           -&gt; putChar &apos;.&apos;
                                              ExpectedFailure   -&gt; putChar &apos;o&apos;
                                              _ -&gt; errorIO $ &quot;Searching for: &quot; ++ show a
                                                           ++ &quot;\nGot: &quot; ++ show (take 5 results)
                                                           ++ &quot;\n expected &quot; ++ expected qr

    let hackage x = &quot;https://hackage.haskell.org/package/&quot; ++ x
    if sample then do
        &quot;__prefix__&quot; === &quot;http://henry.com?too_long&quot;
        &quot;__suffix__&quot; === &quot;http://henry.com?too_long&quot;
        &quot;__infix__&quot; === &quot;http://henry.com?too_long&quot;
        &quot;Wife&quot; === &quot;http://eghmitchell.com/Mitchell.html#a_wife&quot;
        completionTags store `testEq` [&quot;set:all&quot;,&quot;set:sample-data&quot;,&quot;package:emily&quot;,&quot;package:henry&quot;]
     else do
        &quot;base&quot; === hackage &quot;base&quot;
        &quot;Prelude&quot; === hackage &quot;base/docs/Prelude.html&quot;
        &quot;map&quot; === hackage &quot;base/docs/Prelude.html#v:map&quot;
        &quot;map is:ping&quot; === hackage &quot;base/docs/Prelude.html#v:map&quot;
        &quot;map package:base&quot; === hackage &quot;base/docs/Prelude.html#v:map&quot;
        noResults &quot;map package:package-not-in-db&quot;
        noResults &quot;map module:Module.Not.In.Db&quot;
        &quot;True&quot; === hackage &quot;base/docs/Prelude.html#v:True&quot;
        &quot;Bool&quot; === hackage &quot;base/docs/Prelude.html#t:Bool&quot;
        &quot;String&quot; === hackage &quot;base/docs/Prelude.html#t:String&quot;
        &quot;Ord&quot; === hackage &quot;base/docs/Prelude.html#t:Ord&quot;
        &quot;&gt;&gt;=&quot; === hackage &quot;base/docs/Prelude.html#v:-62--62--61-&quot;
        &quot;sequen&quot; === hackage &quot;base/docs/Prelude.html#v:sequence&quot;
        &quot;foldl&apos;&quot; === hackage &quot;base/docs/Prelude.html#v:foldl-39-&quot; -- since base-4.20
        &quot;Action package:shake&quot; === &quot;https://hackage.haskell.org/package/shake/docs/Development-Shake.html#t:Action&quot;
        &quot;Action package:shake set:stackage&quot; === &quot;https://hackage.haskell.org/package/shake/docs/Development-Shake.html#t:Action&quot;
        &quot;map -package:base&quot; ==$ \x -&gt; not $ &quot;/base/&quot; `isInfixOf` x
        &quot;&lt;&gt;&quot; === hackage &quot;base/docs/Prelude.html#v:-60--62-&quot;
        &quot;Data.Set.insert&quot; === hackage &quot;containers/docs/Data-Set.html#v:insert&quot;
        &quot;Set.insert&quot; === hackage &quot;containers/docs/Data-Set.html#v:insert&quot;
        &quot;Prelude.mapM_&quot; === hackage &quot;base/docs/Prelude.html#v:mapM_&quot;
        &quot;Data.Complex.(:+)&quot; === hackage &quot;base/docs/Data-Complex.html#v::-43-&quot;
        &quot;\8801&quot; === hackage &quot;base-unicode-symbols/docs/Data-Eq-Unicode.html#v:-8801-&quot;
        &quot;\8484&quot; === hackage &quot;base-unicode-symbols/docs/Prelude-Unicode.html#t:-8484-&quot;
        &quot;copilot&quot; === hackage &quot;copilot&quot;
        &quot;supero&quot; === hackage &quot;supero&quot;
        &quot;set:stackage&quot; === hackage &quot;base&quot;
        &quot;author:Neil-Mitchell&quot; === hackage &quot;filepath&quot;
        -- FIXME: &quot;author:Neil-M&quot; === hackage &quot;filepath&quot;
        -- FIXME: &quot;Data.Se.insert&quot; === hackage &quot;containers/docs/Data-Set.html#v:insert&quot;
        &quot;set:-haskell-platform author:Neil-Mitchell&quot; === hackage &quot;safe&quot;
        &quot;author:Neil-Mitchell category:Javascript&quot; === hackage &quot;js-jquery&quot;
        &quot;( )&quot; ==$ flip seq True -- used to segfault
        &quot;( -is:exact) package:base=&quot; ==$ flip seq True
        &quot;(a -&gt; b) -&gt; [a] -&gt; [b]&quot; === hackage &quot;base/docs/Prelude.html#v:map&quot;
        &quot;Ord a =&gt; [a] -&gt; [a]&quot; === hackage &quot;base/docs/Data-List.html#v:sort&quot;
        &quot;ShakeOptions -&gt; Int&quot; === hackage &quot;shake/docs/Development-Shake.html#v:shakeThreads&quot;
        &quot;is:module&quot; === hackage &quot;base/docs/Prelude.html&quot;
        &quot;visibleDataCons&quot; === hackage &quot;ghc/docs/GHC-Core-TyCon.html#v:visibleDataCons&quot;
        &quot;sparkle&quot; === hackage &quot;sparkle&quot; -- library without Hoogle docs
        &quot;weeder&quot; === hackage &quot;weeder&quot; -- executable in Stackage
        &quot;supero&quot; === hackage &quot;supero&quot;

        query &quot;(a -&gt; [a]) -&gt; [a] -&gt; [a]&quot;
            [ TopHit   (&quot;concatMap&quot; `inPackage` &quot;base&quot;)
            , InTop 10 (&quot;(=&lt;&lt;)&quot; `inPackage` &quot;base&quot;)
            , KnownFailure &quot;&quot; $ InTop 50 (&quot;(&gt;&gt;=)&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;[a] -&gt; Maybe a&quot;
            [ TopHit  (&quot;listToMaybe&quot; `inModule` &quot;Data.Maybe&quot;)
            , InTop 10 (&quot;headMay&quot;     `inModule` &quot;Safe&quot;)
            ]
        query &quot;a -&gt; [a]&quot;
            [ InTop 10    (&quot;repeat&quot;    `inPackage` &quot;base&quot;)
            , KnownFailure &quot;&quot; $ InTop 50    (&quot;singleton&quot; `inModule` &quot;Util&quot;)
            , DoesNotFind (&quot;head&quot;      `inPackage` &quot;base&quot;)
            , DoesNotFind (&quot;last&quot;      `inPackage` &quot;base&quot;)
            , InTop 50    (&quot;pure&quot;      `inPackage` &quot;base&quot;)
            , KnownFailure &quot;&quot; $ InTop 100   (&quot;return&quot;    `inPackage` &quot;base&quot;)
            , KnownFailure &quot;GitHub issue #267&quot; $
                  (&quot;pure&quot; `inPackage` &quot;base&quot;) `AppearsBefore` (&quot;shrinkNothing&quot; `inModule` &quot;Test.QuickCheck&quot;)
            -- , InTop 10 (&quot;pure&quot;   `inPackage` &quot;base&quot;)
            -- , InTop 10 (&quot;return&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;[a] -&gt; a&quot;
            [ InTop 10 (&quot;head&quot; `inPackage` &quot;base&quot;)
            , InTop 10 (&quot;last&quot; `inPackage` &quot;base&quot;)
            , DoesNotFind (&quot;repeat&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;[Char] -&gt; Char&quot;
            [ InTop 10 (&quot;head&quot; `inPackage` &quot;base&quot;)
            , RanksBelow 10 (&quot;mconcat&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;a -&gt; b&quot;
            [ TopHit (&quot;unsafeCoerce&quot; `inModule` &quot;Unsafe.Coerce&quot;)
            , DoesNotFind (&quot;id&quot; `inPackage` &quot;base&quot;) -- see GitHub issue #180
            , KnownFailure &quot;GitHub issue #268&quot; $
                  InTop 20 (&quot;coerce&quot; `inModule` &quot;Data.Coerce&quot;)
            , KnownFailure &quot;GitHub issue #268&quot; $
                  InTop 5   (&quot;coerce&quot; `inModule` &quot;Data.Coerce&quot;)
            ]
        query &quot;String -&gt; (Char -&gt; Maybe Char) -&gt; Maybe String&quot; -- c/o @ndrssmn
            [ KnownFailure &quot;GitHub issue #266&quot; $
                  InTop 10 (&quot;traverse&quot; `inPackage` &quot;base&quot;)
            , KnownFailure &quot;GitHub issue #266&quot; $
                  InTop 10 (&quot;mapM&quot; `inPackage` &quot;base&quot;)
            , KnownFailure &quot;GitHub issue #266&quot; $
                  InTop 10 (&quot;forM&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;a -&gt; [(a,b)] -&gt; b&quot;
            [ KnownFailure &quot;GitHub issue #267&quot; $
                  TopHit  (&quot;lookup&quot; `inPackage` &quot;base&quot;)
            , InTop 3 (&quot;lookup&quot; `inPackage` &quot;base&quot;)
            , DoesNotFind (&quot;zip&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;[(a,b)] -&gt; a -&gt; b&quot;
            [ KnownFailure &quot;GitHub issue #267&quot; $
                  TopHit (&quot;lookup&quot; `inPackage` &quot;base&quot;)
            , InTop 3 (&quot;lookup&quot; `inPackage` &quot;base&quot;)
            , DoesNotFind (&quot;zip&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;(a -&gt; m b) -&gt; t a -&gt; m (t b)&quot; -- see GitHub issue #218
            [ InTop 10 (&quot;traverse&quot; `inPackage` &quot;base&quot;)
            , InTop 10 (&quot;mapConcurrently&quot; `inModule` &quot;Control.Concurrent.Async.Lifted&quot;)
            , InTop 10 (&quot;mapM&quot; `inPackage` &quot;base&quot;)
            , InTop 50 (&quot;forM&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;m (m a) -&gt; m a&quot; -- see GitHub issue #252
            [ TopHit (&quot;join&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;(a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c&quot;
            [ KnownFailure &quot;GitHub issue #269&quot; $
                  InTop 5 (&quot;ap&quot; `inPackage` &quot;base&quot;)
            , KnownFailure &quot;GitHub issue #269&quot; $
                  InTop 5 (&quot;(&lt;*&gt;)&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;String -&gt; Int&quot;
            [ DoesNotFind (&quot;cursorUpCode&quot; `inPackage` &quot;ansi-terminal&quot;)
            , KnownFailure &quot;GitHub issue #266&quot; $ InTop 20 (&quot;length&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;(a -&gt; b) -&gt; f a -&gt; f b&quot;
            [ TopHit (&quot;fmap&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;(a -&gt; b) -&gt; Maybe a -&gt; Maybe b&quot;
            [ InTop 3 (&quot;fmap&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;IO a -&gt; m a&quot;
            [ InTop 5 (&quot;liftIO&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;a -&gt; m a&quot; -- see GitHub issue #180
            [ InTop 20 (&quot;pure&quot; `inPackage` &quot;base&quot;)
            , InTop 50 (&quot;return&quot; `inPackage` &quot;base&quot;)
            , KnownFailure &quot;GitHub issue #267&quot; $
                  InTop 5 (&quot;pure&quot; `inPackage` &quot;base&quot;)
            , KnownFailure &quot;GitHub issue #267&quot; $
                  InTop 3 (&quot;return&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;(a -&gt; a) -&gt; k -&gt; Map k a -&gt; Map k a&quot; -- see GitHub issue #180
            [ TopHit (&quot;adjust&quot; `inPackage` &quot;containers&quot;)
            ]
        query &quot;Int -&gt; Integer&quot; -- see GitHub issue #127
            [ InTop 40 (&quot;toInteger&quot; `inPackage` &quot;base&quot;)
            , KnownFailure &quot;GitHub issue #127&quot; $
                  TopHit (&quot;toInteger&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;Integer -&gt; Int&quot; -- see GitHub issue #127
            [ InTop 40 (&quot;fromInteger&quot; `inPackage` &quot;base&quot;)
            , KnownFailure &quot;GitHub issue #127&quot; $
                  TopHit (&quot;fromInteger&quot; `inPackage` &quot;base&quot;)
            ]
        query &quot;[Parser a] -&gt; Parser a&quot; -- see GitHub issue #90
            [ KnownFailure &quot;Todo&quot; $ InTop 10 (&quot;choice&quot; `inPackage` &quot;attoparsec&quot;)
            ]

        let tags = completionTags store
        let asserts b x = if b then putChar &apos;.&apos; else errorIO $ &quot;Assertion failed, got False for &quot; ++ x
        asserts (&quot;set:haskell-platform&quot; `elem` tags) &quot;set:haskell-platform `elem` tags&quot;
        asserts (&quot;author:Neil-Mitchell&quot; `elem` tags) &quot;author:Neil-Mitchell `elem` tags&quot;
        asserts (&quot;package:uniplate&quot; `elem` tags) &quot;package:uniplate `elem` tags&quot;
        asserts (&quot;package:supero&quot; `notElem` tags) &quot;package:supero `notElem` tags&quot;


--------------------------------------------------------------------------------------------------
-- Test helpers

data ExpectedQueryResult
    = TopHit TargetMatcher
    | InTop Int TargetMatcher
    | RanksBelow Int TargetMatcher
    | DoesNotFind TargetMatcher
    | AppearsBefore TargetMatcher TargetMatcher
    | NoHits
    | KnownFailure String ExpectedQueryResult

expected :: ExpectedQueryResult -&gt; String
expected = \case
    TopHit tm       -&gt; showTM tm ++ &quot; as first hit.&quot;
    InTop n tm      -&gt; showTM tm ++ &quot; in top &quot; ++ show n ++ &quot; hits.&quot;
    RanksBelow n tm -&gt; showTM tm ++ &quot; not in top &quot; ++ show n ++ &quot; hits.&quot;
    DoesNotFind tm  -&gt; &quot;to not match &quot; ++ showTM tm ++ &quot;.&quot;
    AppearsBefore tm tm&apos; -&gt; showTM tm ++ &quot; to appear before &quot; ++ showTM tm&apos; ++ &quot;.&quot;
    NoHits          -&gt; &quot;no results.&quot;
    KnownFailure why qr -&gt; &quot;to see a failure (&quot; ++ why ++ &quot;): \&quot;&quot; ++ expected qr ++ &quot;\&quot; But it succeeded!&quot;

data TestResult
    = Success
    | Failure
    | ExpectedFailure
    | UnexpectedSuccess

matchQR :: ExpectedQueryResult -&gt; [[Target]] -&gt; TestResult
matchQR qr res = case qr of
    TopHit tm        -&gt; success $ any (any (runTargetMatcher tm)) $ take 1 res
    InTop n tm       -&gt; success $ any (any (runTargetMatcher tm)) $ take n res
    RanksBelow n tm  -&gt; success $ any (any (runTargetMatcher tm)) $ drop n res
    DoesNotFind tm   -&gt; success $ not $ any (any (runTargetMatcher tm)) res
    AppearsBefore tm tm&apos; -&gt; success $ ( (&lt;) &lt;$&gt; matchIdx tm &lt;*&gt; matchIdx tm&apos; ) == Just True
    NoHits           -&gt; success $ null res
    KnownFailure _ qr&apos; -&gt; case matchQR qr&apos; res of
        Success           -&gt; UnexpectedSuccess
        Failure           -&gt; ExpectedFailure
        ExpectedFailure   -&gt; Failure
        UnexpectedSuccess -&gt; Failure
  where
    success p = if p then Success else Failure
    matchIdx tm = fmap fst $ find (runTargetMatcher tm . snd) (zipFrom 0 $ concat res)

data TargetMatcher
    = MatchFunctionInModule  String String
    | MatchFunctionInPackage String String

showTM :: TargetMatcher -&gt; String
showTM = \case
    MatchFunctionInModule  f m -&gt; m ++ &quot;&apos;s &quot; ++ f
    MatchFunctionInPackage f p -&gt; f ++ &quot; from package &quot; ++ p

runTargetMatcher :: TargetMatcher -&gt; Target -&gt; Bool
runTargetMatcher matcher Target{..} = case matcher of
    MatchFunctionInModule f m -&gt;
        Just m == fmap fst targetModule
        &amp;&amp; f `isPrefixOf` unHTML targetItem
    MatchFunctionInPackage f m -&gt;
        Just m == fmap fst targetPackage
        &amp;&amp; f `isPrefixOf` unHTML targetItem

inModule :: String -&gt; String -&gt; TargetMatcher
inModule = MatchFunctionInModule

inPackage :: String -&gt; String -&gt; TargetMatcher
inPackage = MatchFunctionInPackage

-- Group duplicated targets (e.g. re-exports) together.
deDup :: [Target] -&gt; [[Target]]
deDup tgts = Map.elems (Map.fromList $ Map.elems tgtMap)
  where
    tgtMap :: Map.Map Target (Int, [Target])
    tgtMap = Map.fromListWith (\(n, ts) (n&apos;, ts&apos;) -&gt; (min n n&apos;, ts ++ ts&apos;))
             $ zipWithFrom (\n t -&gt; (simple t, (n, [t]))) 0 tgts

    simple :: Target -&gt; Target
    simple t = t { targetURL = &quot;&quot;, targetPackage = Nothing, targetModule = Nothing }</file><file path="src/Action/Server.hs">{-# LANGUAGE ViewPatterns, TupleSections, RecordWildCards, ScopedTypeVariables, PatternGuards #-}
{-# LANGUAGE OverloadedStrings #-}

module Action.Server(actionServer, actionReplay, action_server_test_, action_server_test) where

import Data.List.Extra
import System.FilePath
import Control.Exception
import Control.Exception.Extra
import Control.DeepSeq
import System.Directory
import Text.Blaze
import Text.Blaze.Renderer.Utf8
import qualified Text.Blaze.XHtml5 as H
import qualified Text.Blaze.XHtml5.Attributes as H
import Data.Tuple.Extra
import qualified Language.Javascript.JQuery as JQuery
import qualified Language.Javascript.Flot as Flot
import Data.Version
import Paths_hoogle
import Data.Maybe
import Control.Monad.Extra
import Text.Read
import System.IO.Extra
import General.Str
import qualified Data.ByteString.Char8 as BS
import qualified Data.ByteString.Lazy.Char8 as LBS
import qualified Data.Map as Map
import System.Time.Extra
import Data.Time.Clock
import Data.Time.Calendar
import System.IO.Unsafe
import Numeric.Extra
import System.Info.Extra

import Output.Tags
import Query
import Input.Item
import General.Util
import General.Web
import General.Store
import General.Template
import General.Log
import Action.Search
import Action.CmdLine
import Control.Applicative
import Data.Monoid
import Prelude

import qualified Data.Aeson as JSON

actionServer :: CmdLine -&gt; IO ()
actionServer cmd@Server{..} = do
    -- so I can get good error messages
    hSetBuffering stdout LineBuffering
    hSetBuffering stderr LineBuffering
    putStrLn $ &quot;Server started on port &quot; ++ show port
    putStr &quot;Reading log...&quot; &gt;&gt; hFlush stdout
    time &lt;- offsetTime
    log &lt;- logCreate (if logs == &quot;&quot; then Left stdout else Right logs) $
        \x -&gt; BS.pack &quot;hoogle=&quot; `BS.isInfixOf` x &amp;&amp; not (BS.pack &quot;is:ping&quot; `BS.isInfixOf` x)
    putStrLn . showDuration =&lt;&lt; time
    evaluate spawned
    dataDir &lt;- maybe getDataDir pure datadir
    haddock &lt;- maybe (pure Nothing) (fmap Just . canonicalizePath) haddock
    withSearch database $ \store -&gt;
        server log cmd $ replyServer log local links haddock store cdn home (dataDir &lt;/&gt; &quot;html&quot;) scope

actionReplay :: CmdLine -&gt; IO ()
actionReplay Replay{..} = withBuffering stdout NoBuffering $ do
    src &lt;- readFile logs
    let qs = catMaybes [readInput url | _:ip:_:url:_ &lt;- map words $ lines src, ip /= &quot;-&quot;]
    (t,_) &lt;- duration $ withSearch database $ \store -&gt; do
        log &lt;- logNone
        dataDir &lt;- getDataDir
        let op = replyServer log False False Nothing store &quot;&quot; &quot;&quot; (dataDir &lt;/&gt; &quot;html&quot;) scope
        replicateM_ repeat_ $ forM_ qs $ \x -&gt; do
            res &lt;- op x
            evaluate $ rnf res
            putChar &apos;.&apos;
    putStrLn $ &quot;\nTook &quot; ++ showDuration t ++ &quot; (&quot; ++ showDuration (t / intToDouble (repeat_ * length qs)) ++ &quot;)&quot;

{-# NOINLINE spawned #-}
spawned :: UTCTime
spawned = unsafePerformIO getCurrentTime

replyServer :: Log -&gt; Bool -&gt; Bool -&gt; Maybe FilePath -&gt; StoreRead -&gt; String -&gt; String -&gt; FilePath -&gt; String -&gt; Input -&gt; IO Output
replyServer log local links haddock store cdn home htmlDir scope Input{..} = case inputURL of
    -- without -fno-state-hack things can get folded under this lambda
    [] -&gt; do
        let grabBy name = [x | (a,x) &lt;- inputArgs, name a, x /= &quot;&quot;]
            grab name = grabBy (== name)
            grabInt name def = fromMaybe def $ readMaybe =&lt;&lt; listToMaybe (grab name) :: Int

        let qScope = let xs = grab &quot;scope&quot; in [scope | null xs &amp;&amp; scope /= &quot;&quot;] ++ xs
        let qSearch = grabBy (`elem` [&quot;hoogle&quot;,&quot;q&quot;])
        let qSource = qSearch ++ filter (/= &quot;set:stackage&quot;) qScope
        let q = concatMap parseQuery qSource
        let (q2, results) = search store q
        let body = showResults local links haddock (filter ((/= &quot;mode&quot;) . fst) inputArgs) q2 $
                dedupeTake 25 (\t -&gt; t{targetURL=&quot;&quot;,targetPackage=Nothing, targetModule=Nothing}) results
        case lookup &quot;mode&quot; inputArgs of
            Nothing | qSource /= [] -&gt; fmap OutputHTML $ templateRender templateIndex
                        [(&quot;tags&quot;, html $ tagOptions qScope)
                        ,(&quot;body&quot;, html body)
                        ,(&quot;title&quot;, text $ unwords qSource ++ &quot; - Hoogle&quot;)
                        ,(&quot;search&quot;, text $ unwords qSearch)
                        ,(&quot;robots&quot;, text $ if any isQueryScope q then &quot;none&quot; else &quot;index&quot;)]
                    | otherwise -&gt; OutputHTML &lt;$&gt; templateRender templateHome []
            Just &quot;body&quot; -&gt; OutputHTML &lt;$&gt; if null qSource then templateRender templateEmpty [] else templateRender (html body) []
            Just &quot;json&quot; -&gt;
              let -- 1 means don&apos;t drop anything, if it&apos;s less than 1 ignore it
                  start :: Int
                  start = max 0 $ grabInt &quot;start&quot; 1 - 1
                  -- by default it returns 100 entries
                  count :: Int
                  count = min 500 $ grabInt &quot;count&quot; 100
                  filteredResults = take count $ drop start results
              in case lookup &quot;format&quot; inputArgs of
                Just &quot;text&quot; -&gt; pure $ OutputJSON $ JSON.toEncoding $ map unHTMLTarget filteredResults
                Just f -&gt; pure $ OutputFail $ lbstrPack $ &quot;Format mode &quot; ++ f ++ &quot; not (currently) supported&quot;
                Nothing -&gt; pure $ OutputJSON $ JSON.toEncoding filteredResults
            Just m -&gt; pure $ OutputFail $ lbstrPack $ &quot;Mode &quot; ++ m ++ &quot; not (currently) supported&quot;
    [&quot;plugin&quot;,&quot;jquery.js&quot;] -&gt; OutputFile &lt;$&gt; JQuery.file
    [&quot;plugin&quot;,&quot;jquery.flot.js&quot;] -&gt; OutputFile &lt;$&gt; Flot.file Flot.Flot
    [&quot;plugin&quot;,&quot;jquery.flot.time.js&quot;] -&gt; OutputFile &lt;$&gt; Flot.file Flot.FlotTime

    [&quot;canary&quot;] -&gt; do
        now &lt;- getCurrentTime
        summ &lt;- logSummary log
        let errs = sum [summaryErrors | Summary{..} &lt;- summ, summaryDate &gt;= pred (utctDay now)]
        let alive = fromRational $ toRational $ (now `diffUTCTime` spawned) / (24 * 60 * 60)
        pure $ (if errs == 0 &amp;&amp; alive &lt; 1.5 then OutputText else OutputFail) $ lbstrPack $
            &quot;Errors &quot; ++ (if errs == 0 then &quot;good&quot; else &quot;bad&quot;) ++ &quot;: &quot; ++ show errs ++ &quot; in the last 24 hours.\n&quot; ++
            &quot;Updates &quot; ++ (if alive &lt; 1.5 then &quot;good&quot; else &quot;bad&quot;) ++ &quot;: Last updated &quot; ++ showDP 2 alive ++ &quot; days ago.\n&quot;

    [&quot;log&quot;] -&gt; do
        OutputHTML &lt;$&gt; templateRender templateLog []
    [&quot;log.js&quot;] -&gt; do
        log &lt;- displayLog &lt;$&gt; logSummary log
        OutputJavascript &lt;$&gt; templateRender templateLogJs [(&quot;data&quot;,html $ H.preEscapedString log)]
    [&quot;stats&quot;] -&gt; do
        stats &lt;- getStatsDebug
        pure $ case stats of
            Nothing -&gt; OutputFail $ lbstrPack &quot;GHC Statistics is not enabled, restart with +RTS -T&quot;
            Just x -&gt; OutputText $ lbstrPack x
    &quot;haddock&quot;:xs | Just x &lt;- haddock -&gt; do
        let file = intercalate &quot;/&quot; $ x:xs
        pure $ OutputFile $ file ++ (if hasTrailingPathSeparator file then &quot;index.html&quot; else &quot;&quot;)
    &quot;file&quot;:xs | local -&gt; do
        let x = [&apos;/&apos; | not isWindows] ++ intercalate &quot;/&quot; (dropWhile null xs)
        let file = x ++ (if hasTrailingPathSeparator x then &quot;index.html&quot; else &quot;&quot;)
        if takeExtension file /= &quot;.html&quot; then
            pure $ OutputFile file
         else do
            src &lt;- readFile file
            -- Haddock incorrectly generates file:// on Windows, when it should be file:///
            -- so replace on file:// and drop all leading empty paths above
            pure $ OutputHTML $ lbstrPack $ replace &quot;file://&quot; &quot;/file/&quot; src
    xs -&gt;
        pure $ OutputFile $ joinPath $ htmlDir : xs
    where
        html = templateMarkup
        text = templateMarkup . H.string

        tagOptions sel = mconcat [H.option Text.Blaze.!? (x `elem` sel, H.selected &quot;selected&quot;) $ H.string x | x &lt;- completionTags store]
        params =
            [(&quot;cdn&quot;, text cdn)
            ,(&quot;home&quot;, text home)
            ,(&quot;jquery&quot;, text $ if null cdn then &quot;plugin/jquery.js&quot; else &quot;https:&quot; ++ JQuery.url)
            ,(&quot;version&quot;, text $ showVersion version ++ &quot; &quot; ++ showUTCTime &quot;%Y-%m-%d %H:%M&quot; spawned)]
        templateIndex = templateFile (htmlDir &lt;/&gt; &quot;index.html&quot;) `templateApply` params
        templateEmpty = templateFile (htmlDir &lt;/&gt;  &quot;welcome.html&quot;)
        templateHome = templateIndex `templateApply` [(&quot;tags&quot;,html $ tagOptions []),(&quot;body&quot;,templateEmpty),(&quot;title&quot;,text &quot;Hoogle&quot;),(&quot;search&quot;,text &quot;&quot;),(&quot;robots&quot;,text &quot;index&quot;)]
        templateLog = templateFile (htmlDir &lt;/&gt; &quot;log.html&quot;) `templateApply` params
        templateLogJs = templateFile (htmlDir &lt;/&gt; &quot;log.js&quot;) `templateApply` params


dedupeTake :: Ord k =&gt; Int -&gt; (v -&gt; k) -&gt; [v] -&gt; [[v]]
dedupeTake n key = f [] Map.empty
    where
        -- map is Map k [v]
        f res mp xs | Map.size mp &gt;= n || null xs = map (reverse . (Map.!) mp) $ reverse res
        f res mp (x:xs) | Just vs &lt;- Map.lookup k mp = f res (Map.insert k (x:vs) mp) xs
                        | otherwise = f (k:res) (Map.insert k [x] mp) xs
            where k = key x


showResults :: Bool -&gt; Bool -&gt; Maybe FilePath -&gt; [(String, String)] -&gt; [Query] -&gt; [[Target]] -&gt; Markup
showResults local links haddock args query results = do
    H.h1 $ renderQuery query
    when (null results) $ H.p &quot;No results found&quot;
    forM_ results $ \is@(Target{..}:_) -&gt; do
        H.div ! H.class_ &quot;result&quot; $ do
            H.div ! H.class_ &quot;ans&quot; $ do
                H.a ! H.href (H.stringValue $ showURL local haddock targetURL) $
                    displayItem query targetItem
                when links $
                    whenJust (useLink is) $ \link -&gt;
                        H.div ! H.class_ &quot;links&quot; $ H.a ! H.href (H.stringValue link) $ &quot;Uses&quot;
            H.div ! H.class_ &quot;from&quot; $ showFroms local haddock is
            H.div ! H.class_ &quot;doc newline shut&quot; $ H.preEscapedString targetDocs
    H.ul ! H.id &quot;left&quot; $ -- if there&apos;s already a scope query we don&apos;t show subquery links because bots will get lost in a maze of links.
        if (any isQueryScope query) then pure () else do
            H.li $ H.b &quot;Packages&quot;
            mconcat [H.li $ f cat val | (cat,val) &lt;- itemCategories $ concat results, QueryScope True cat val `notElem` query]

    where
        useLink :: [Target] -&gt; Maybe String
        useLink [t] | isNothing $ targetPackage t =
            Just $ &quot;https://packdeps.haskellers.com/reverse/&quot; ++ extractName (targetItem t)
        useLink _ = Nothing

        add x = (&quot;?&quot; ++) $ intercalate &quot;&amp;&quot; $ map (joinPair &quot;=&quot;) $
            case break ((==) &quot;hoogle&quot; . fst) args of
                (a,[]) -&gt; a ++ [(&quot;hoogle&quot;, escapeURL x)]
                (a,(_,x1):b) -&gt; a ++ [(&quot;hoogle&quot;, escapeURL $ x1 ++ &quot; &quot; ++ x)] ++ b

        f cat val = do
            H.a ! H.class_&quot; minus&quot; ! H.href (H.stringValue $ add $ &quot;-&quot; ++ cat ++ &quot;:&quot; ++ val) $ &quot;&quot;
            H.a ! H.class_ &quot;plus&quot;  ! H.href (H.stringValue $ add $        cat ++ &quot;:&quot; ++ val) $
                H.string $ (if cat == &quot;package&quot; then &quot;&quot; else cat ++ &quot;:&quot;) ++ val


-- find the &lt;span class=name&gt;X&lt;/span&gt; bit
extractName :: String -&gt; String
extractName x
    | Just (_, x) &lt;- stripInfix &quot;&lt;span class=name&gt;&quot; x
    , Just (x, _) &lt;- stripInfix &quot;&lt;/span&gt;&quot; x
    = unHTML x
extractName x = x


itemCategories :: [Target] -&gt; [(String,String)]
itemCategories xs =
    [(&quot;is&quot;,&quot;exact&quot;)] ++
    [(&quot;is&quot;,&quot;package&quot;) | any ((==) &quot;package&quot; . targetType) xs] ++
    [(&quot;is&quot;,&quot;module&quot;)  | any ((==) &quot;module&quot;  . targetType) xs] ++
    nubOrd [(&quot;package&quot;,p) | Just (p,_) &lt;- map targetPackage xs]

showFroms :: Bool -&gt; Maybe FilePath -&gt; [Target] -&gt; Markup
showFroms local haddock xs = mconcat $ intersperse &quot;, &quot; $ flip map pkgs $ \p -&gt;
    let ms = filter ((==) p . targetPackage) xs
    in mconcat $ intersperse &quot; &quot; [H.a ! H.href (H.stringValue $ showURL local haddock b) $ H.string a | (a,b) &lt;- catMaybes $ p : map remod ms]
    where
        remod Target{..} = do (a,_) &lt;- targetModule; pure (a,targetURL)
        pkgs = nubOrd $ map targetPackage xs

showURL :: Bool -&gt; Maybe FilePath -&gt; URL -&gt; String
showURL _ (Just _) x = &quot;haddock/&quot; ++ dropPrefix &quot;file:///&quot; x
showURL True _ (stripPrefix &quot;file:///&quot; -&gt; Just x) = &quot;file/&quot; ++ x
showURL _ _ x = x


-------------------------------------------------------------
-- DISPLAY AN ITEM (bold keywords etc)


displayItem :: [Query] -&gt; String -&gt; Markup
displayItem = highlightItem H.string H.preEscapedString H.string (H.b . H.string)

action_server_test_ :: IO ()
action_server_test_ = do
    testing &quot;Action.Server.displayItem&quot; $ do
        let expand = replace &quot;{&quot; &quot;&lt;b&gt;&quot; . replace &quot;}&quot; &quot;&lt;/b&gt;&quot; . replace &quot;&lt;s0&gt;&quot; &quot;&quot; . replace &quot;&lt;/s0&gt;&quot; &quot;&quot;
            contract = replace &quot;{&quot; &quot;&quot; . replace &quot;}&quot; &quot;&quot;
        let q === s | LBS.unpack (renderMarkup $ displayItem (parseQuery q) (contract s)) == expand s = putChar &apos;.&apos;
                    | otherwise = errorIO $ show (q,s,renderMarkup $ displayItem (parseQuery q) (contract s))
        &quot;test&quot; === &quot;&lt;s0&gt;my{Test}&lt;/s0&gt; :: Int -&amp;gt; test&quot;
        &quot;new west&quot; === &quot;&lt;s0&gt;{newest}_{new}&lt;/s0&gt; :: Int&quot;
        &quot;+*&quot; === &quot;(&lt;s0&gt;{+*}&amp;amp;&lt;/s0&gt;) :: Int&quot;
        &quot;+&lt;&quot; === &quot;(&lt;s0&gt;&amp;gt;{+&amp;lt;}&lt;/s0&gt;) :: Int&quot;
        &quot;foo&quot; === &quot;&lt;i&gt;data&lt;/i&gt; &lt;s0&gt;{Foo}d&lt;/s0&gt;&quot;
        &quot;foo&quot; === &quot;&lt;i&gt;type&lt;/i&gt; &lt;s0&gt;{Foo}d&lt;/s0&gt;&quot;
        &quot;foo&quot; === &quot;&lt;i&gt;type family&lt;/i&gt; &lt;s0&gt;{Foo}d&lt;/s0&gt;&quot;
        &quot;foo&quot; === &quot;&lt;i&gt;module&lt;/i&gt; Foo.Bar.&lt;s0&gt;F{Foo}&lt;/s0&gt;&quot;
        &quot;foo&quot; === &quot;&lt;i&gt;module&lt;/i&gt; &lt;s0&gt;{Foo}o&lt;/s0&gt;&quot;

action_server_test :: Bool -&gt; FilePath -&gt; IO ()
action_server_test sample database = do
    testing &quot;Action.Server.replyServer&quot; $ withSearch database $ \store -&gt; do
        log &lt;- logNone
        dataDir &lt;- getDataDir
        let check p q = do
                OutputHTML (lbstrUnpack -&gt; res) &lt;- replyServer log False False Nothing store &quot;&quot; &quot;&quot; (dataDir &lt;/&gt; &quot;html&quot;) &quot;&quot; (Input [] [(&quot;hoogle&quot;,q)])
                if p res then putChar &apos;.&apos; else fail $ &quot;Bad substring: &quot; ++ res
        let q === want = check (want `isInfixOf`) q
        let q /== want = check (not . isInfixOf want) q
        &quot;&lt;test&quot; /== &quot;&lt;test&quot;
        &quot;&amp;test&quot; /== &quot;&amp;test&quot;
        if sample then
            &quot;Wife&quot; === &quot;&lt;b&gt;type family&lt;/b&gt;&quot;
         else do
            &quot;&lt;&gt;&quot; === &quot;&lt;span class=name&gt;(&lt;b&gt;&amp;lt;&amp;gt;&lt;/b&gt;)&lt;/span&gt;&quot;
            &quot;filt&quot; === &quot;&lt;span class=name&gt;&lt;b&gt;filt&lt;/b&gt;er&lt;/span&gt;&quot;
            &quot;True&quot; === &quot;https://hackage.haskell.org/package/base/docs/Prelude.html#v:True&quot;


-------------------------------------------------------------
-- ANALYSE THE LOG


displayLog :: [Summary] -&gt; String
displayLog xs = &quot;[&quot; ++ intercalate &quot;,&quot; (map f xs) ++ &quot;]&quot;
    where
        f Summary{..} = &quot;{date:&quot; ++ show (showGregorian summaryDate) ++
                        &quot;,users:&quot; ++ show summaryUsers ++ &quot;,uses:&quot; ++ show summaryUses ++
                        &quot;,slowest:&quot; ++ show summarySlowest ++ &quot;,average:&quot; ++ show (fromAverage summaryAverage) ++
                        &quot;,errors:&quot; ++ show summaryErrors ++ &quot;}&quot;</file><file path="src/Action/Test.hs">{-# LANGUAGE TupleSections, RecordWildCards, ScopedTypeVariables #-}

module Action.Test(actionTest) where

import Query
import Action.CmdLine
import Action.Search
import Action.Server
import Action.Generate
import General.Util
import General.Web
import Input.Item
import Input.Haddock
import System.IO.Extra

import Control.Monad
import Output.Items
import Control.DeepSeq
import Control.Exception


actionTest :: CmdLine -&gt; IO ()
actionTest Test{..} = withBuffering stdout NoBuffering $ withTempFile $ \sample -&gt; do
    putStrLn &quot;Code tests&quot;
    general_util_test
    general_web_test
    input_haddock_test
    query_test
    action_server_test_
    item_test
    putStrLn &quot;&quot;

    putStrLn &quot;Sample database tests&quot;
    actionGenerate defaultGenerate{database=sample, local_=[&quot;misc/sample-data&quot;]}
    action_search_test True sample
    unless disable_network_tests $ action_server_test True sample
    putStrLn &quot;&quot;

    unless disable_network_tests $ do
        putStrLn &quot;Haskell.org database tests&quot;
        action_search_test False database
        action_server_test False database

        when deep $ withSearch database $ \store -&gt; do
            putStrLn &quot;Deep tests&quot;
            let xs = map targetItem $ listItems store
            evaluate $ rnf xs
            putStrLn $ &quot;Loaded &quot; ++ show (length xs) ++ &quot; items&quot;</file><file path="src/General/Conduit.hs">{-# LANGUAGE NoMonomorphismRestriction, PatternGuards, CPP #-}

module General.Conduit(
    module Data.Conduit, MonadIO, liftIO,
    sourceList, sinkList, sourceLStr,
    mapC, mapAccumC, filterC,
    mapMC, mapAccumMC,
    (|$|), pipelineC, groupOnLastC,
    zipFromC, linesCR
    ) where

import Data.Void
import Data.Conduit
import Data.Conduit.List as C
import Data.Conduit.Binary as C
import Data.Maybe
import Control.Applicative
import Control.Monad.Extra
import Control.Exception
import qualified Data.ByteString.Char8 as BS
import Control.Concurrent.Extra hiding (yield)
import Control.Monad.IO.Class
import General.Str
import Prelude


mapC = C.map
mapMC = C.mapM
mapAccumC f = C.mapAccum (\x a -&gt; a `seq` f a x)
mapAccumMC f = C.mapAccumM (\x a -&gt; a `seq` f a x)
filterC = C.filter

zipFromC :: (Monad m, Enum i) =&gt; i -&gt; ConduitM a (i, a) m ()
zipFromC = void . mapAccumC (\i x -&gt; (succ i, (i,x)))

(|$|) :: Monad m =&gt; ConduitM i o m r1 -&gt; ConduitM i o m r2 -&gt; ConduitM i o m (r1,r2)
(|$|) a b = getZipConduit $ (,) &lt;$&gt; ZipConduit a &lt;*&gt; ZipConduit b

sinkList :: Monad m =&gt; ConduitM a o m [a]
sinkList = consume

-- | Group things while they have the same function result, only return the last value.
--   Conduit version of @groupOnLast f = map last . groupOn f@.
groupOnLastC :: (Monad m, Eq b) =&gt; (a -&gt; b) -&gt; ConduitM a a m ()
groupOnLastC op = do
    x &lt;- await
    whenJust x $ \x -&gt; f (op x) x
    where
        f k v = await &gt;&gt;= \x -&gt; case x of
            Nothing -&gt; yield v
            Just v2 | let k2 = op v2 -&gt; do
                when (k /= k2) $ yield v
                f k2 v2


linesCR :: Monad m =&gt; ConduitM BStr BStr m ()
linesCR = C.lines .| mapC f
    where f x | Just (x, &apos;\r&apos;) &lt;- BS.unsnoc x = x
              | otherwise = x

sourceLStr :: Monad m =&gt; LBStr -&gt; ConduitM i BStr m ()
sourceLStr = sourceList . lbstrToChunks


pipelineC :: Int -&gt; ConduitM o Void IO r -&gt; ConduitM o Void IO r
pipelineC buffer sink = do
    sem &lt;- liftIO $ newQSem buffer  -- how many are in flow, to avoid memory leaks
    chan &lt;- liftIO newChan          -- the items in flow (type o)
    bar &lt;- liftIO newBarrier        -- the result type (type r)
    me &lt;- liftIO myThreadId
    liftIO $ flip forkFinally (either (throwTo me) (signalBarrier bar)) $ do
        runConduit $
            (whileM $ do
                x &lt;- liftIO $ readChan chan
                liftIO $ signalQSem sem
                whenJust x yield
                pure $ isJust x) .|
            sink
    awaitForever $ \x -&gt; liftIO $ do
        waitQSem sem
        writeChan chan $ Just x
    liftIO $ writeChan chan Nothing
    liftIO $ waitBarrier bar</file><file path="src/General/IString.hs">{-# LANGUAGE PatternGuards, DeriveDataTypeable, ViewPatterns, BangPatterns #-}

-- | Interned strings
module General.IString(
    IString, fromIString, toIString
    ) where

import Data.Data
import Data.IORef
import Control.DeepSeq
import General.Str
import qualified Data.Map as Map
import System.IO.Unsafe


data IString = IString {-# UNPACK #-} !Int !Str
    deriving (Data,Typeable)

instance Eq IString where
    IString x _ == IString y _ = x == y

instance Ord IString where
    compare (IString x1 x2) (IString y1 y2)
        | x1 == y1 = EQ
        | otherwise = compare x2 y2

instance Show IString where show = strUnpack . fromIString
instance NFData IString where rnf IString{} = () -- we force the string at construction time


{-# NOINLINE istrings #-}
istrings :: IORef (Map.Map Str IString)
istrings = unsafePerformIO $ newIORef Map.empty

fromIString :: IString -&gt; Str
fromIString (IString _ x) = x

toIString :: Str -&gt; IString
toIString x = unsafePerformIO $ atomicModifyIORef&apos; istrings $ \mp -&gt; case Map.lookup x mp of
    Just v -&gt; (mp, v)
    Nothing -&gt; let res = IString (Map.size mp) x in (Map.insert x res mp, res)</file><file path="src/General/Log.hs">{-# LANGUAGE RecordWildCards, ViewPatterns, TupleSections, PatternGuards #-}

module General.Log(
    Log, logCreate, logNone, logAddMessage, logAddEntry,
    Summary(..), logSummary,
    ) where

import Control.Concurrent.Extra
import Control.Applicative
import System.Directory
import System.IO
import Data.Hashable
import Data.Time.Calendar
import Data.Time.Clock
import Numeric.Extra
import Control.Monad.Extra
import qualified Data.IntSet as Set
import qualified Data.Map.Strict as Map
import qualified Data.ByteString.Lazy.Char8 as LBS
import qualified Data.ByteString.Char8 as BS
import Data.Semigroup
import General.Util
import Data.Maybe
import Data.List
import Data.IORef.Extra
import Safe
import Prelude


data Log = Log
    {logOutput :: Maybe (Var Handle)
    ,logCurrent :: IORef (Map.Map Day SummaryI)
    ,logInteresting :: String -&gt; Bool
    }

showTime :: UTCTime -&gt; String
showTime = showUTCTime &quot;%Y-%m-%dT%H:%M:%S%Q&quot;

logNone :: IO Log
logNone = do ref &lt;- newIORef Map.empty; pure $ Log Nothing ref (const False)

logCreate :: Either Handle FilePath -&gt; (BS.ByteString -&gt; Bool) -&gt; IO Log
logCreate store interesting = do
    (h, old) &lt;- case store of
        Left h -&gt; pure (h, Map.empty)
        Right file -&gt; do
            b &lt;- doesFileExist file
            mp &lt;- if not b then pure Map.empty else withFile file ReadMode $ \h -&gt; do
                src &lt;- LBS.hGetContents h
                let xs = mapMaybe (parseLogLine interesting . LBS.toStrict) $ LBS.lines src
                pure $! foldl&apos; (\mp (k,v) -&gt; Map.alter (Just . maybe v (&lt;&gt; v)) k mp) Map.empty xs
            (,mp) &lt;$&gt; openFile file AppendMode
    hSetBuffering h LineBuffering
    var &lt;- newVar h
    ref &lt;- newIORef old
    pure $ Log (Just var) ref (interesting . BS.pack)

logAddMessage :: Log -&gt; String -&gt; IO ()
logAddMessage Log{..} msg = do
    time &lt;- showTime &lt;$&gt; getCurrentTime
    whenJust logOutput $ \var -&gt; withVar var $ \h -&gt;
        hPutStrLn h $ time ++ &quot; - &quot; ++ msg

logAddEntry :: Log -&gt; String -&gt; String -&gt; Double -&gt; Maybe String -&gt; IO ()
logAddEntry Log{..} user question taken err = do
    time &lt;- getCurrentTime
    let add v = atomicModifyIORef_ logCurrent $ \mp -&gt; Map.alter (Just . maybe v (&lt;&gt; v)) (utctDay time) mp
    if logInteresting question then
        add $ SummaryI (Set.singleton $ hash $ LBS.pack user) 1 taken (toAverage taken) (if isJust err then 1 else 0)
     else if isJust err then
        add mempty{iErrors=1}
     else
        pure ()
    whenJust logOutput $ \var -&gt; withVar var $ \h -&gt;
        hPutStrLn h $ unwords $ [showTime time, user, showDP 3 taken, question] ++
                                maybeToList (fmap ((++) &quot;ERROR: &quot; . unwords . words) err)

-- Summary collapsed
data Summary = Summary
    {summaryDate :: Day
    ,summaryUsers :: {-# UNPACK #-} !Int
    ,summaryUses :: {-# UNPACK #-} !Int
    ,summarySlowest :: {-# UNPACK #-} !Double
    ,summaryAverage :: {-# UNPACK #-} !(Average Double)
    ,summaryErrors :: {-# UNPACK #-} !Int
    }

-- Summary accumulating
data SummaryI = SummaryI
    {iUsers :: !Set.IntSet -- number of distinct users
    ,iUses :: !Int -- number of uses
    ,iSlowest :: !Double -- slowest result
    ,iAverage :: !(Average Double) -- average result
    ,iErrors :: !Int -- number of errors
    }

instance Semigroup SummaryI where
    SummaryI x1 x2 x3 x4 x5 &lt;&gt; SummaryI y1 y2 y3 y4 y5 =
        SummaryI (f x1 y1) (x2+y2) (max x3 y3) (x4 &lt;&gt; y4) (x5+y5)
        -- more efficient union for the very common case of a single element
        where f x y | Set.size x == 1 = Set.insert (headErr $ Set.toList x) y
                    | Set.size y == 1 = Set.insert (headErr $ Set.toList y) x
                    | otherwise = Set.union x y

instance Monoid SummaryI where
    mempty = SummaryI Set.empty 0 0 (toAverage 0) 0
    mappend = (&lt;&gt;)

summarize :: Day -&gt; SummaryI -&gt; Summary
summarize date SummaryI{..} = Summary date (Set.size iUsers) iUses iSlowest iAverage iErrors

-- This noinline solves a massive memory leak at -O2, and I have no idea why
{-# NOINLINE parseLogLine #-}
parseLogLine :: (BS.ByteString -&gt; Bool) -&gt; BS.ByteString -&gt; Maybe (Day, SummaryI)
parseLogLine interesting (BS.words -&gt; time:user:dur:query:err)
    | use || isErr
    , user /= BS.singleton &apos;-&apos;
    , Just [a, b, c] &lt;- fmap (map fst) $ mapM BS.readInt $ BS.split &apos;-&apos; $ BS.takeWhile (/= &apos;T&apos;) time
    = Just (fromGregorian (fromIntegral a) b c, SummaryI
        (if use then Set.singleton $ hash user else Set.empty)
        (if use then 1 else 0)
        (if use then dur2 else 0)
        (toAverage $ if use then dur2 else 0)
        (if isErr then 1 else 0))
    where use = interesting query
          isErr = [BS.pack &quot;ERROR:&quot;] `isPrefixOf` err
          dur2 = parseDuration dur
parseLogLine _ _ = Nothing

-- Hoogle used to store whole numbers of milliseconds, then it switched to 4dp doubles with a guaranteed &apos;.&apos;
parseDuration :: BS.ByteString -&gt; Double
parseDuration x
    | Just (whole, x) &lt;- BS.readInt x
    = case BS.uncons x of
        Just (&apos;.&apos;, x)
            | Just (frac, y) &lt;- BS.readInt x
                -&gt; intToDouble whole + (intToDouble frac / (10 ^ (BS.length x - BS.length y)))
            | otherwise -&gt; 0
        _ -&gt; intToDouble whole / 1000
parseDuration _ = 0


logSummary :: Log -&gt; IO [Summary]
logSummary Log{..} = map (uncurry summarize) . Map.toAscList &lt;$&gt; readIORef logCurrent</file><file path="src/General/Store.hs">{-# LANGUAGE DeriveDataTypeable, GADTs, PatternGuards, RecordWildCards,
             ScopedTypeVariables, ViewPatterns #-}

module General.Store(
    Typeable, Stored,
    intSize, intFromBS, intToBS, encodeBS, decodeBS,
    StoreWrite, storeWriteFile, storeWrite, storeWritePart,
    StoreRead, storeReadFile, storeRead,
    Jagged, jaggedFromList, jaggedAsk,
    ) where

import Control.Applicative
import Control.DeepSeq
import Control.Exception
import Control.Exception.Extra
import Control.Monad.Extra
import Data.Binary
import qualified Data.ByteString.Char8 as BS
import qualified Data.ByteString.Lazy as LBS
import qualified Data.ByteString.Unsafe as BS
import Data.Char
import Data.IORef.Extra
import Data.List.Extra
import qualified Data.Map as Map
import Data.Typeable
import qualified Data.Vector.Storable as V
import Data.Version
import Foreign.C.String
import Foreign.ForeignPtr
import Foreign.Ptr
import Foreign.Storable
import General.Util
import Numeric.Extra
import Paths_hoogle
import Prelude
import System.Directory (renameFile)
import System.FilePath (takeDirectory, takeFileName)
import System.IO.Extra (Handle, hTell, hClose, hPutBuf)
import System.IO.MMap
import System.IO.Temp (withTempFile)
import System.IO.Unsafe

-- Ensure the string is always 25 chars long, so version numbers don&apos;t change its size
-- Only use the first two components of the version number to identify the database
verString = BS.pack $ take 25 $ &quot;HOOGLE-&quot; ++ showVersion (trimVersion 3 version) ++ repeat &apos; &apos;

---------------------------------------------------------------------
-- SERIALISATION HELPERS

intSize :: Int
intSize = 4

intToBS :: Int -&gt; BS.ByteString
intToBS i = encodeBS (fromIntegral i :: Word32)

intFromBS :: BS.ByteString -&gt; Int
intFromBS bs = fromIntegral (decodeBS bs :: Word32)

encodeBS :: Binary a =&gt; a -&gt; BS.ByteString
encodeBS = LBS.toStrict . encode

decodeBS :: Binary a =&gt; BS.ByteString -&gt; a
decodeBS = decode . LBS.fromStrict


---------------------------------------------------------------------
-- TREE INDEX STRUCTURE

-- each atom name is either unique (a scope) or &quot;&quot; (a list entry)
data Atom = Atom
    {atomType :: String -- Type that the atom contains (for sanity checking)
    ,atomPosition :: {-# UNPACK #-} !Int -- Position at which the atom starts in the file
    ,atomSize :: {-# UNPACK #-} !Int -- Number of bytes the value takes up
    } deriving Show

instance Binary Atom where
    put (Atom a b c) = put a &gt;&gt; put b &gt;&gt; put c
    get = liftA3 Atom get get get

---------------------------------------------------------------------
-- TYPE CLASS

class Typeable a =&gt; Stored a where
    storedWrite :: Typeable (t a) =&gt; StoreWrite -&gt; t a -&gt; Bool -&gt; a -&gt; IO ()
    storedRead :: Typeable (t a) =&gt; StoreRead -&gt; t a -&gt; a

instance Stored BS.ByteString where
    storedWrite store k part v = BS.unsafeUseAsCStringLen v $ \x -&gt; storeWriteAtom store k part x
    storedRead store k = storeReadAtom store k BS.unsafePackCStringLen

instance forall a . (Typeable a, Storable a) =&gt; Stored (V.Vector a) where
    storedWrite store k part v = V.unsafeWith v $ \ptr -&gt;
        storeWriteAtom store k part (castPtr ptr, V.length v * sizeOf (undefined :: a))
    storedRead store k = storeReadAtom store k $ \(ptr, len) -&gt; do
        ptr &lt;- newForeignPtr_ $ castPtr ptr
        pure $ V.unsafeFromForeignPtr0 ptr (len `div` sizeOf (undefined :: a))


---------------------------------------------------------------------
-- WRITE OUT

data SW = SW
    {swHandle :: Handle -- Immutable handle I write to
    ,swPosition :: !Int -- Position within swHandle
    ,swAtoms :: [(String, Atom)] -- List of pieces, in reverse
    }

newtype StoreWrite = StoreWrite (IORef SW)

storeWriteFile :: FilePath -&gt; (StoreWrite -&gt; IO a) -&gt; IO ([String], a)
storeWriteFile file act = do
    atoms &lt;- newIORef Map.empty
    parts &lt;- newIORef Nothing
    withTempFile (takeDirectory file) (takeFileName file) $ \tmpFile h -&gt; do
        -- put the version string at the start and end, so we can tell truncation vs wrong version
        BS.hPut h verString
        ref &lt;- newIORef $ SW h (BS.length verString) []
        res &lt;- act $ StoreWrite ref
        SW{..} &lt;- readIORef ref

        -- sort the atoms and validate there are no duplicates
        let atoms = Map.fromList swAtoms
        when (Map.size atoms /= length swAtoms) $
            errorIO $ &quot;Some duplicate names have been written out: &quot; ++ show (length swAtoms - Map.size atoms) ++ &quot; duplicates&quot;

        -- write the atoms out, then put the size at the end
        let bs = encodeBS atoms
        BS.hPut h bs
        BS.hPut h $ intToBS $ BS.length bs
        BS.hPut h verString

        final &lt;- hTell h
        let stats = prettyTable 0 &quot;Bytes&quot; $
                (&quot;Overheads&quot;, intToDouble $ fromIntegral final - sum (map atomSize $ Map.elems atoms)) :
                [(name ++ &quot; :: &quot; ++ atomType, intToDouble atomSize) | (name, Atom{..}) &lt;- Map.toList atoms]
        hClose h
        renameFile tmpFile file
        pure (stats, res)

storeWrite :: (Typeable (t a), Typeable a, Stored a) =&gt; StoreWrite -&gt; t a -&gt; a -&gt; IO ()
storeWrite store k = storedWrite store k False

storeWritePart :: forall t a . (Typeable (t a), Typeable a, Stored a) =&gt; StoreWrite -&gt; t a -&gt; a -&gt; IO ()
storeWritePart store k = storedWrite store k True

{-# NOINLINE putBuffer #-}
putBuffer a b c = hPutBuf a b c

storeWriteAtom :: forall t a . (Typeable (t a), Typeable a) =&gt; StoreWrite -&gt; t a -&gt; Bool -&gt; CStringLen -&gt; IO ()
storeWriteAtom (StoreWrite ref) (show . typeOf -&gt; key) part (ptr, len) = do
    sw@SW{..} &lt;- readIORef ref
    putBuffer swHandle ptr len

    let val = show $ typeRep (Proxy :: Proxy a)
    atoms &lt;- case swAtoms of
        (keyOld,a):xs | part, key == keyOld -&gt; do
            let size = atomSize a + len
            evaluate size
            pure $ (key,a{atomSize=size}) : xs
        _ -&gt; pure $ (key, Atom val swPosition len) : swAtoms
    writeIORef&apos; ref sw{swPosition = swPosition + len, swAtoms = atoms}


---------------------------------------------------------------------
-- READ OUT

data StoreRead = StoreRead
    {srFile :: FilePath
    ,srLen :: Int
    ,srPtr :: Ptr ()
    ,srAtoms :: Map.Map String Atom
    }

storeReadFile :: NFData a =&gt; FilePath -&gt; (StoreRead -&gt; IO a) -&gt; IO a
storeReadFile file act = mmapWithFilePtr file ReadOnly Nothing $ \(ptr, len) -&gt; strict $ do
    -- check is longer than my version string
    when (len &lt; (BS.length verString * 2) + intSize) $
        errorIO $ &quot;The Hoogle file &quot; ++ file ++ &quot; is corrupt, only &quot; ++ show len ++ &quot; bytes.&quot;

    let verN = BS.length verString
    verEnd &lt;- BS.unsafePackCStringLen (plusPtr ptr $ len - verN, verN)
    when (verString /= verEnd) $ do
        verStart &lt;- BS.unsafePackCStringLen (plusPtr ptr 0, verN)
        if verString /= verStart then
            errorIO $ &quot;The Hoogle file &quot; ++ file ++ &quot; is the wrong version or format.\n&quot; ++
                      &quot;Expected: &quot; ++ trim (BS.unpack verString) ++ &quot;\n&quot; ++
                      &quot;Got     : &quot; ++ map (\x -&gt; if isAlphaNum x || x `elem` &quot;_-. &quot; then x else &apos;?&apos;) (trim $ BS.unpack verStart)
         else
            errorIO $ &quot;The Hoogle file &quot; ++ file ++ &quot; is truncated, probably due to an error during creation.&quot;

    atomSize &lt;- intFromBS &lt;$&gt; BS.unsafePackCStringLen (plusPtr ptr $ len - verN - intSize, intSize)
    when (len &lt; verN + intSize + atomSize) $
        errorIO $ &quot;The Hoogle file &quot; ++ file ++ &quot; is corrupt, couldn&apos;t read atom table.&quot;
    atoms &lt;- decodeBS &lt;$&gt; BS.unsafePackCStringLen (plusPtr ptr $ len - verN - intSize - atomSize, atomSize)
    act $ StoreRead file len ptr atoms

storeRead :: (Typeable (t a), Typeable a, Stored a) =&gt; StoreRead -&gt; t a -&gt; a
storeRead = storedRead


storeReadAtom :: forall a t . (Typeable (t a), Typeable a) =&gt; StoreRead -&gt; t a -&gt; (CStringLen -&gt; IO a) -&gt; a
storeReadAtom StoreRead{..} (typeOf -&gt; k) unpack = unsafePerformIO $ do
    let key = show k
    let val = show $ typeRep (Proxy :: Proxy a)
    let corrupt msg = errorIO $ &quot;The Hoogle file &quot; ++ srFile ++ &quot; is corrupt, &quot; ++ key ++ &quot; &quot; ++ msg ++ &quot;.&quot;
    case Map.lookup key srAtoms of
        Nothing -&gt; corrupt &quot;is missing&quot;
        Just Atom{..}
            | atomType /= val -&gt; corrupt $ &quot;has type &quot; ++ atomType ++ &quot;, expected &quot; ++ val
            | atomPosition &lt; 0 || atomPosition + atomSize &gt; srLen -&gt; corrupt &quot;has incorrect bounds&quot;
            | otherwise -&gt; unpack (plusPtr srPtr atomPosition, atomSize)

---------------------------------------------------------------------
-- PAIRS

newtype Fst k v where Fst :: k -&gt; Fst k a deriving Typeable
newtype Snd k v where Snd :: k -&gt; Snd k b deriving Typeable

instance (Typeable a, Typeable b, Stored a, Stored b) =&gt; Stored (a,b) where
    storedWrite store k False (a,b) = storeWrite store (Fst k) a &gt;&gt; storeWrite store (Snd k) b
    storedRead store k = (storeRead store $ Fst k, storeRead store $ Snd k)


---------------------------------------------------------------------
-- LITERALS

data StoredInt k v where StoredInt :: k -&gt; StoredInt k BS.ByteString deriving Typeable

instance Stored Int where
    storedWrite store k False v = storeWrite store (StoredInt k) $ intToBS v
    storedRead store k = intFromBS $ storeRead store (StoredInt k)


---------------------------------------------------------------------
-- JAGGED ARRAYS

data Jagged a = Jagged (V.Vector Word32) (V.Vector a) deriving Typeable
data JaggedStore k v where JaggedStore :: k -&gt; JaggedStore k (V.Vector Word32, V.Vector a) deriving Typeable

jaggedFromList :: Storable a =&gt; [[a]] -&gt; Jagged a
jaggedFromList xs = Jagged is vs
    where is = V.fromList $ scanl (+) 0 $ map (\x -&gt; fromIntegral $ length x :: Word32) xs
          vs = V.fromList $ concat xs

jaggedAsk :: Storable a =&gt; Jagged a -&gt; Int -&gt; V.Vector a
jaggedAsk (Jagged is vs) i = V.slice start (end - start) vs
    where start = fromIntegral $ is V.! i
          end   = fromIntegral $ is V.! succ i

instance (Typeable a, Storable a) =&gt; Stored (Jagged a) where
    storedWrite store k False (Jagged is vs) = storeWrite store (JaggedStore k) (is, vs)
    storedRead store k = uncurry Jagged $ storeRead store $ JaggedStore k</file><file path="src/General/Str.hs">{-# LANGUAGE PatternGuards, DeriveDataTypeable, GeneralizedNewtypeDeriving #-}

-- | ByteString wrappers which don&apos;t require special imports and are all UTF8 safe
module General.Str(
    Str, strPack, strUnpack, strNull, strCopy, strCons,
    BStr, bstrPack, bstrUnpack, bstrReadFile, bstrSplitInfix, bstrNull, bstrStripPrefix, bstrTrimStart,
    LBStr, lbstrPack, lbstrUnpack, lbstrToChunks, lbstrFromChunks,
    BStr0, bstr0Join, bstr0Split
    ) where

import qualified Data.ByteString.Char8 as BS
import qualified Data.ByteString.UTF8 as US
import qualified Data.ByteString.Lazy.Char8 as LBS
import qualified Data.ByteString.Lazy.UTF8 as LUS
import qualified Data.Text as T
import Control.DeepSeq
import Data.Char
import Data.Data
import Data.List
import Data.Semigroup
import Data.String
import Prelude


newtype Str = Str { fromStr :: T.Text }
    deriving (Data, Typeable, Eq, Ord, Semigroup, Monoid)

instance Show Str where show = strUnpack
instance NFData Str where rnf x = x `seq` ()


type BStr = BS.ByteString

type LBStr = LBS.ByteString


strPack :: String -&gt; Str
strPack = Str . T.pack

strUnpack :: Str -&gt; String
strUnpack = T.unpack . fromStr

strCons :: Char -&gt; Str -&gt; Str
strCons c = Str . T.cons c . fromStr

strCopy :: Str -&gt; Str
strCopy = Str . T.copy . fromStr

strNull :: Str -&gt; Bool
strNull = T.null . fromStr

bstrPack :: String -&gt; BStr
bstrPack = US.fromString

bstrUnpack :: BStr -&gt; String
bstrUnpack = US.toString

bstrReadFile :: FilePath -&gt; IO BStr
bstrReadFile = BS.readFile

bstrSplitInfix :: BStr -&gt; BStr -&gt; Maybe (BStr, BStr)
bstrSplitInfix needle haystack
    | (a,b) &lt;- BS.breakSubstring needle haystack
    , not $ BS.null b
    = Just (a, BS.drop (BS.length needle) b)
bstrSplitInfix _ _ = Nothing

bstrNull :: BStr -&gt; Bool
bstrNull = BS.null

bstrStripPrefix :: BStr -&gt; BStr -&gt; Maybe BStr
bstrStripPrefix needle x
    | BS.isPrefixOf needle x = Just $ BS.drop (BS.length needle) x
    | otherwise = Nothing

bstrTrimStart :: BStr -&gt; BStr
bstrTrimStart = BS.dropWhile isSpace

lbstrToChunks :: LBStr -&gt; [BStr]
lbstrToChunks = LBS.toChunks

lbstrFromChunks :: [BStr] -&gt; LBStr
lbstrFromChunks = LBS.fromChunks

lbstrUnpack :: LBStr -&gt; String
lbstrUnpack = LUS.toString

lbstrPack :: String -&gt; LBStr
lbstrPack = LUS.fromString


type BStr0 = BStr

bstr0Join :: [String] -&gt; BStr0
bstr0Join = LBS.toStrict . LUS.fromString . intercalate &quot;\0&quot;

bstr0Split :: BStr0 -&gt; [BStr]
bstr0Split = BS.split &apos;\0&apos;</file><file path="src/General/Template.hs">{-# LANGUAGE PatternGuards, DeriveDataTypeable, ScopedTypeVariables #-}

module General.Template(
    Template, templateFile, templateMarkup, templateApply, templateRender
    ) where

import Data.Data
import Data.Monoid
import Text.Blaze
import Text.Blaze.Renderer.Utf8
import General.Str
import Data.List.Extra
import Control.Exception
import Data.Generics.Uniplate.Data
import Control.Applicative
import System.IO.Unsafe
import System.Directory
import Control.Monad
import Data.IORef
import Prelude

---------------------------------------------------------------------
-- TREE DATA TYPE

data Tree = Lam FilePath -- #{foo} defines a lambda
          | Var BStr -- a real variable
          | App Tree [(BStr, Tree)] -- applies a foo string to the lambda
          | Lit BStr
          | List [Tree]
            deriving (Typeable,Data,Show)


-- | Turn all Lam into Var/Lit
treeRemoveLam :: Tree -&gt; IO Tree
treeRemoveLam = transformM f
    where
        f (Lam file) = List . parse &lt;$&gt; bstrReadFile file
        f x = pure x

        parse x | Just (a,b) &lt;- bstrSplitInfix (bstrPack &quot;#{&quot;) x
                , Just (b,c) &lt;- bstrSplitInfix (bstrPack &quot;}&quot;) b
                = Lit a : Var b : parse c
        parse x = [Lit x]

treeRemoveApp :: Tree -&gt; Tree
treeRemoveApp = f []
    where
        f seen (App t xs) = f (xs ++ seen) t
        f seen (Var x) | Just t &lt;- lookup x seen = f seen t
        f seen x = descend (f seen) x

treeOptimise :: Tree -&gt; Tree
treeOptimise = transform f . treeRemoveApp
    where
        fromList (List xs) = xs; fromList x = [x]
        toList [x] = x; toList xs = List xs
        isLit (Lit x) = True; isLit _ = False
        fromLit (Lit x) = x

        f = toList . g . concatMap fromList . fromList

        g [] = []
        g (x:xs) | not $ isLit x = x : g xs
        g xs = [Lit x | let x = mconcatMap fromLit a, x /= mempty] ++ g b
            where (a,b) = span isLit xs

treeEval :: Tree -&gt; [BStr]
treeEval = f . treeRemoveApp
    where f (Lit x) = [x]
          f (List xs) = concatMap f xs
          f _ = []


---------------------------------------------------------------------
-- TEMPLATE DATA TYPE

-- a tree, and a pre-optimised tree you can create
data Template = Template Tree (IO Tree)

{-# NOINLINE treeCache #-}
treeCache :: Tree -&gt; IO Tree
treeCache t0 = unsafePerformIO $ do
    let files = [x | Lam x &lt;- universe t0]
    ref &lt;- newIORef ([], treeOptimise t0)
    pure $ do
        (old,t) &lt;- readIORef ref
        new &lt;- forM files $ \file -&gt;
            -- the standard getModificationTime message on Windows doesn&apos;t say the file
            getModificationTime file `catch` \(e :: IOException) -&gt;
                fail $ &quot;Failed: getModificationTime on &quot; ++ file ++ &quot;, &quot; ++ show e
        if old == new then pure t else do
            t &lt;- treeOptimise &lt;$&gt; treeRemoveLam t0
            writeIORef ref (new,t)
            pure t

templateTree :: Tree -&gt; Template
templateTree t = Template t $ treeCache t

templateFile :: FilePath -&gt; Template
templateFile = templateTree . Lam

templateMarkup :: Markup -&gt; Template
templateMarkup = templateStr . renderMarkup

templateStr :: LBStr -&gt; Template
templateStr = templateTree . List . map Lit . lbstrToChunks

templateApply :: Template -&gt; [(String, Template)] -&gt; Template
templateApply (Template t _) args = templateTree $ App t [(bstrPack a, b) | (a,Template b _) &lt;- args]

templateRender :: Template -&gt; [(String, Template)] -&gt; IO LBStr
templateRender (Template _ t) args = do
    t &lt;- t
    let Template t2 _ = templateApply (Template t $ pure t) args
    lbstrFromChunks . treeEval &lt;$&gt; treeRemoveLam t2</file><file path="src/General/Timing.hs">{-# LANGUAGE RecordWildCards #-}

module General.Timing(Timing, withTiming, timed, timedOverwrite) where

import Data.List.Extra
import System.Time.Extra
import Data.IORef
import Control.Monad.Extra
import System.IO
import General.Util
import Control.Monad.IO.Class

-- | A mutable object to keep timing information
data Timing = Timing
    { -- | Get time since the initialization of this &apos;Timing&apos;.
      timingOffset :: IO Seconds
      -- | Record timings for writing to a file
    , timingStore :: IORef [(String, Seconds)]
      -- | If you are below T you may overwrite N characters
      -- at the end of the current terminal output.
      -- Only used iff @timingTerminal == True@.
    , timingOverwrite :: IORef (Maybe (Seconds, Int))
      -- | whether is this a terminal
    , timingTerminal :: Bool
    }

-- | Time an action, printing timing information to the terminal
withTiming ::
  -- | A file to optionally write all timings to, after the action is finished
  Maybe FilePath -&gt;
  -- | An action that can write timings into &apos;Timing&apos;
  (Timing -&gt; IO a) -&gt;
  IO a
withTiming writeTimingsTo act = do
    timingOffset &lt;- offsetTime
    timingStore &lt;- newIORef []
    timingOverwrite &lt;- newIORef Nothing
    timingTerminal &lt;- hIsTerminalDevice stdout

    res &lt;- act Timing{..}
    total &lt;- timingOffset
    whenJust writeTimingsTo $ \file -&gt; do
        xs &lt;- readIORef timingStore
        -- Expecting unrecorded of ~2s
        -- Most of that comes from the pipeline - we get occasional 0.01 between items as one flushes
        -- Then at the end there is ~0.5 while the final item flushes
        xs &lt;- pure $ sortOn (negate . snd) $ (&quot;Unrecorded&quot;, total - sum (map snd xs)) : xs
        writeFile file $ unlines $ prettyTable 2 &quot;Secs&quot; xs
    putStrLn $ &quot;Took &quot; ++ showDuration total
    pure res


-- skip it if have written out in the last 1s and takes &lt; 0.1

-- | Time &amp; write the given message to stdout
timed :: MonadIO m =&gt; Timing -&gt; String -&gt; m a -&gt; m a
timed = timedEx False

-- | Time &amp; write the given message to stdout
-- overwriting a previous message if it was marked as overwritable
timedOverwrite :: MonadIO m =&gt; Timing -&gt; String -&gt; m a -&gt; m a
timedOverwrite = timedEx True

timedEx :: MonadIO m =&gt; Bool -&gt; Timing -&gt; String -&gt; m a -&gt; m a
timedEx overwrite Timing{..} msg act = do
    start &lt;- liftIO timingOffset
    liftIO $ whenJustM (readIORef timingOverwrite) $ \(t,n) -&gt;
        if overwrite &amp;&amp; start &lt; t then
            putStr $ replicate n &apos;\b&apos; ++ replicate n &apos; &apos; ++ replicate n &apos;\b&apos;
        else
            putStrLn &quot;&quot;

    let out msg = liftIO $ putStr msg &gt;&gt; pure (length msg)
    undo1 &lt;- out $ msg ++ &quot;... &quot;
    liftIO $ hFlush stdout

    res &lt;- act
    end &lt;- liftIO timingOffset
    let time = end - start
    liftIO $ modifyIORef timingStore ((msg,time):)

    s &lt;- maybe &quot;&quot; (\x -&gt; &quot; (&quot; ++ x ++ &quot;)&quot;) &lt;$&gt; liftIO getStatsPeakAllocBytes
    undo2 &lt;- out $ showDuration time ++ s

    old &lt;- liftIO $ readIORef timingOverwrite
    let next = maybe (start + 1.0) fst old
    liftIO $ if timingTerminal &amp;&amp; overwrite &amp;&amp; end &lt; next then
        writeIORef timingOverwrite $ Just (next, undo1 + undo2)
     else do
        writeIORef timingOverwrite Nothing
        putStrLn &quot;&quot;
    pure res</file><file path="src/General/Util.hs">{-# LANGUAGE PatternGuards, ViewPatterns, CPP, ScopedTypeVariables #-}

module General.Util(
    PkgName, ModName,
    URL,
    pretty, parseMode, applyType, applyFun1, unapplyFun, fromName, fromQName, fromTyVarBind, declNames, isTypeSig,
    fromDeclHead, fromContext, fromIParen, fromInstHead,
    tarballReadFiles,
    isUpper1, isAlpha1,
    joinPair,
    testing, testEq,
    showUTCTime,
    strict,
    withs,
    escapeHTML, unescapeHTML, unHTML,
    escapeURL,
    takeSortOn,
    Average, toAverage, fromAverage,
    inRanges,
    parseTrailingVersion,
    trimVersion,
    exitFail,
    prettyTable,
    getStatsPeakAllocBytes, getStatsCurrentLiveBytes, getStatsDebug,
    hackagePackageURL, hackageModuleURL, hackageDeclURL, ghcModuleURL,
    minimum&apos;, maximum&apos;,
    general_util_test
    ) where

import Language.Haskell.Exts
import Control.Applicative
import Data.List.Extra
import Data.Char
import Data.Either.Extra
import Data.Semigroup
import Data.Tuple.Extra
import Control.Monad.Extra
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Map as Map
import Data.Ix
import Numeric.Extra
import Codec.Compression.GZip as GZip
import Codec.Archive.Tar as Tar
import Data.Time.Clock
import Data.Time.Format
import Control.DeepSeq
import Control.Exception.Extra
import Test.QuickCheck
import Data.Version
import Data.Int
import System.IO
import System.Exit
import System.Mem
import GHC.Stats
import General.Str
import Prelude
import qualified Network.HTTP.Types.URI as URI
import qualified Data.ByteString.UTF8 as UTF8
import Distribution.Types.PackageName (PackageName, unPackageName)


type PkgName = PackageName
type ModName = Str

-- | A URL, complete with a @https:@ prefix.
type URL = String

#if __GLASGOW_HASKELL__ &gt;= 802
#define RTS_STATS 1
#endif

showMb :: (Show a, Integral a) =&gt; a -&gt; String
#if RTS_STATS
showMb x = show (x `div` (1024*1024)) ++ &quot;Mb&quot;
#else
showMb x = show x ++ &quot;Mb&quot;
#endif


#if RTS_STATS
withRTSStats :: (RTSStats -&gt; a) -&gt; IO (Maybe a)
withRTSStats f = ifM getRTSStatsEnabled (Just . f &lt;$&gt; getRTSStats) (pure Nothing)
#else
withGCStats :: (GCStats -&gt; a) -&gt; IO (Maybe a)
withGCStats f = ifM getGCStatsEnabled (Just . f &lt;$&gt; getGCStats) (pure Nothing)
#endif

getStatsCurrentLiveBytes :: IO (Maybe String)
getStatsCurrentLiveBytes = do
    performGC
#if RTS_STATS
    withRTSStats $ showMb . gcdetails_live_bytes . gc
#else
    withGCStats $ showMb . currentBytesUsed
#endif

getStatsPeakAllocBytes :: IO (Maybe String)
getStatsPeakAllocBytes = do
#if RTS_STATS
    withRTSStats $ showMb . max_mem_in_use_bytes
#else
    withGCStats $ showMb . peakMegabytesAllocated
#endif

getStatsDebug :: IO (Maybe String)
getStatsDebug = do
    let dump = replace &quot;, &quot; &quot;\n&quot; . takeWhile (/= &apos;}&apos;) . drop1 . dropWhile (/= &apos;{&apos;) . show
#if RTS_STATS
    withRTSStats dump
#else
    withGCStats dump
#endif



exitFail :: String -&gt; IO ()
exitFail msg = do
    hPutStrLn stderr msg
    exitFailure

pretty :: Pretty a =&gt; a -&gt; String
pretty = prettyPrintWithMode defaultMode{layout=PPNoLayout}


parseMode :: ParseMode
parseMode = defaultParseMode{extensions=map EnableExtension es}
    where es = [ConstraintKinds,EmptyDataDecls,TypeOperators,ExplicitForAll,GADTs,KindSignatures,MultiParamTypeClasses
               ,TypeFamilies,FlexibleContexts,FunctionalDependencies,ImplicitParams,MagicHash,UnboxedTuples
               ,ParallelArrays,UnicodeSyntax,DataKinds,PolyKinds,PatternSynonyms]

applyType :: Type a -&gt; [Type a] -&gt; Type a
applyType x (t:ts) = applyType (TyApp (ann t) x t) ts
applyType x [] = x

applyFun1 :: [Type a] -&gt; Type a
applyFun1 [x] = x
applyFun1 (x:xs) = TyFun (ann x) x $ applyFun1 xs

unapplyFun :: Type a -&gt; [Type a]
unapplyFun (TyFun _ x y) = x : unapplyFun y
unapplyFun x = [x]


fromName :: Name a -&gt; String
fromName (Ident _ x) = x
fromName (Symbol _ x) = x

fromQName :: QName a -&gt; String
fromQName (Qual _ _ x) = fromName x
fromQName (UnQual _ x) = fromName x
fromQName (Special _ UnitCon{}) = &quot;()&quot;
fromQName (Special _ ListCon{}) = &quot;[]&quot;
fromQName (Special _ FunCon{}) = &quot;-&gt;&quot;
fromQName (Special _ (TupleCon _ box n)) = &quot;(&quot; ++ h ++ replicate n &apos;,&apos; ++ h ++ &quot;)&quot;
    where h = [&apos;#&apos; | box == Unboxed]
fromQName (Special _ UnboxedSingleCon{}) = &quot;(##)&quot;
fromQName (Special _ Cons{}) = &quot;:&quot;

fromContext :: Context a -&gt; [Asst a]
fromContext (CxSingle _ x) = [x]
fromContext (CxTuple _ xs) = xs
fromContext _ = []

fromIParen :: InstRule a -&gt; InstRule a
fromIParen (IParen _ x) = fromIParen x
fromIParen x = x

fromTyVarBind :: TyVarBind a -&gt; Name a
fromTyVarBind (KindedVar _ x _) = x
fromTyVarBind (UnkindedVar _ x) = x

fromDeclHead :: DeclHead a -&gt; (Name a, [TyVarBind a])
fromDeclHead (DHead _ n) = (n, [])
fromDeclHead (DHInfix _ x n) = (n, [x])
fromDeclHead (DHParen _ x) = fromDeclHead x
fromDeclHead (DHApp _ dh x) = second (++[x]) $ fromDeclHead dh

fromInstHead :: InstHead a -&gt; (QName a, [Type a])
fromInstHead (IHCon _ n) = (n, [])
fromInstHead (IHInfix _ x n) = (n, [x])
fromInstHead (IHParen _ x) = fromInstHead x
fromInstHead (IHApp _ ih x) = second (++[x]) $ fromInstHead ih

declNames :: Decl a -&gt; [String]
declNames x = map fromName $ case x of
    TypeDecl _ hd _ -&gt; f hd
    DataDecl _ _ _ hd _ _ -&gt; f hd
    GDataDecl _ _ _ hd _ _ _ -&gt; f hd
    TypeFamDecl _ hd _ _ -&gt; f hd
    DataFamDecl _ _ hd _ -&gt; f hd
    ClassDecl _ _ hd _ _ -&gt; f hd
    TypeSig _ names _ -&gt; names
    PatSynSig _ names _ _ _ _ _ -&gt; names
    _ -&gt; []
    where f x = [fst $ fromDeclHead x]


isTypeSig :: Decl a -&gt; Bool
isTypeSig TypeSig{} = True
isTypeSig PatSynSig{} = True
isTypeSig _ = False


tarballReadFiles :: FilePath -&gt; IO [(FilePath, LBS.ByteString)]
tarballReadFiles file = f . Tar.read . GZip.decompress &lt;$&gt; LBS.readFile file
    where
        f (Next e rest) | NormalFile body _ &lt;- entryContent e = (entryPath e, body) : f rest
        f (Next _ rest) = f rest
        f Done = []
        f (Fail e) = error $ &quot;tarballReadFiles on &quot; ++ file ++ &quot;, &quot; ++ show e


innerTextHTML :: String -&gt; String
innerTextHTML (&apos;&lt;&apos;:xs) = innerTextHTML $ drop1 $ dropWhile (/= &apos;&gt;&apos;) xs
innerTextHTML (x:xs) = x : innerTextHTML xs
innerTextHTML [] = []

unHTML :: String -&gt; String
unHTML = unescapeHTML . innerTextHTML

escapeURL :: String -&gt; String
escapeURL = UTF8.toString . URI.urlEncode True . UTF8.fromString

isUpper1 (x:xs) = isUpper x
isUpper1 _ = False

isAlpha1 (x:xs) = isAlpha x
isAlpha1 [] = False

splitPair :: String -&gt; String -&gt; (String, String)
splitPair x y | (a,stripPrefix x -&gt; Just b) &lt;- breakOn x y = (a,b)
              | otherwise = error $ &quot;splitPair does not contain separator &quot; ++ show x ++ &quot; in &quot; ++ show y

joinPair :: [a] -&gt; ([a], [a]) -&gt; [a]
joinPair sep (a,b) = a ++ sep ++ b

testing_, testing :: String -&gt; IO () -&gt; IO ()
testing_ name act = do putStr $ &quot;Test &quot; ++ name ++ &quot; &quot;; act
testing name act = do testing_ name act; putStrLn &quot;&quot;

testEq :: (Show a, Eq a) =&gt; a -&gt; a -&gt; IO ()
testEq a b | a == b = putStr &quot;.&quot;
           | otherwise = errorIO $ &quot;Expected equal, but &quot; ++ show a ++ &quot; /= &quot; ++ show b

showUTCTime :: String -&gt; UTCTime -&gt; String
showUTCTime = formatTime defaultTimeLocale


withs :: [(a -&gt; r) -&gt; r] -&gt; ([a] -&gt; r) -&gt; r
withs [] act = act []
withs (f:fs) act = f $ \a -&gt; withs fs $ \as -&gt; act $ a:as


prettyTable :: Int -&gt; String -&gt; [(String, Double)] -&gt; [String]
prettyTable dp units xs =
    ( padR len units ++ &quot;\tPercent\tName&quot;) :
    [ padL len (showDP dp b) ++ &quot;\t&quot; ++ padL 7 (showDP 1 (100 * b / tot) ++ &quot;%&quot;) ++ &quot;\t&quot; ++ a
    | (a,b) &lt;- (&quot;Total&quot;, tot) : sortOn (negate . snd) xs]
    where
        tot = sum $ map snd xs
        len = length units `max` length (showDP dp tot)

        padL n s = replicate (n - length s) &apos; &apos; ++ s
        padR n s = s ++ replicate (n - length s) &apos; &apos;

-- ensure that no value escapes in a thunk from the value
strict :: NFData a =&gt; IO a -&gt; IO a
strict act = do
    res &lt;- try_ act
    case res of
        Left e -&gt; do msg &lt;- showException e; evaluate $ rnf msg; errorIO msg
        Right v -&gt; evaluate $ force v

data Average a = Average !a {-# UNPACK #-} !Int deriving Show -- a / b

toAverage :: a -&gt; Average a
toAverage x = Average x 1

fromAverage :: Fractional a =&gt; Average a -&gt; a
fromAverage (Average a b) = a / fromIntegral b

instance Num a =&gt; Semigroup (Average a) where
    Average x1 x2 &lt;&gt; Average y1 y2 = Average (x1+y1) (x2+y2)

instance Num a =&gt; Monoid (Average a) where
    mempty = Average 0 0
    mappend = (&lt;&gt;)


data TakeSort k v = More !Int !(Map.Map k [v])
                  | Full !k !(Map.Map k [v])

-- | @takeSortOn n op == take n . sortOn op@
takeSortOn :: Ord k =&gt; (a -&gt; k) -&gt; Int -&gt; [a] -&gt; [a]
takeSortOn op n xs
    | n &lt;= 0 = []
    | otherwise = concatMap reverse $ Map.elems $ getMap $ foldl&apos; add (More n Map.empty) xs
    where
        getMap (More _ mp) = mp
        getMap (Full _ mp) = mp

        add (More n mp) x = (if n &lt;= 1 then full else More (n-1)) $ Map.insertWith (++) (op x) [x] mp
        add o@(Full mx mp) x = let k = op x in if k &gt;= mx then o else full $ Map.insertWith (++) k [x] $ delMax mp
        full mp = Full (fst $ Map.findMax mp) mp
        delMax mp | Just ((k,_:vs), mp) &lt;- Map.maxViewWithKey mp = if null vs then mp else Map.insert k vs mp



-- See https://ghc.haskell.org/trac/ghc/ticket/10830 - they broke maximumBy
maximumBy&apos; :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; a
maximumBy&apos; cmp = foldl1&apos; $ \x y -&gt; if cmp x y == GT then x else y

maximum&apos; :: Ord a =&gt; [a] -&gt; a
maximum&apos; = maximumBy&apos; compare

minimumBy&apos; :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; a
minimumBy&apos; cmp = foldl1&apos; $ \x y -&gt; if cmp x y == LT then x else y

minimum&apos; :: Ord a =&gt; [a] -&gt; a
minimum&apos; = minimumBy&apos; compare


hackagePackageURL :: PkgName -&gt; URL
hackagePackageURL x = &quot;https://hackage.haskell.org/package/&quot; ++ unPackageName x

hackageModuleURL :: ModName -&gt; URL
hackageModuleURL x = &quot;/docs/&quot; ++ ghcModuleURL x

ghcModuleURL :: ModName -&gt; URL
ghcModuleURL x = replace &quot;.&quot; &quot;-&quot; (strUnpack x) ++ &quot;.html&quot;

hackageDeclURL :: Bool -&gt; String -&gt; URL
hackageDeclURL typesig x = &quot;#&quot; ++ (if typesig then &quot;v&quot; else &quot;t&quot;) ++ &quot;:&quot; ++ concatMap f x
    where
        f x | isLegal x = [x]
            | otherwise = &quot;-&quot; ++ show (ord x) ++ &quot;-&quot;
        -- isLegal is from haddock-api:Haddock.Utils; we need to use
        -- the same escaping strategy here in order for fragment links
        -- to work
        isLegal &apos;:&apos; = True
        isLegal &apos;_&apos; = True
        isLegal &apos;.&apos; = True
        isLegal c = isAscii c &amp;&amp; isAlphaNum c


trimVersion :: Int -&gt; Version -&gt; Version
trimVersion i v = v{versionBranch = take 3 $ versionBranch v}

parseTrailingVersion :: String -&gt; (String, [Int])
parseTrailingVersion = (reverse *** reverse) . f . reverse
    where
        f xs | (ver@(_:_),sep:xs) &lt;- span isDigit xs
             , sep == &apos;-&apos; || sep == &apos;.&apos;
             , (a, b) &lt;- f xs
             = (a, Prelude.read (reverse ver) : b)
        f xs = (xs, [])


-- | Equivalent to any (`inRange` x) xs, but more efficient
inRanges :: Ix a =&gt; [(a,a)] -&gt; (a -&gt; Bool)
inRanges xs = \x -&gt; maybe False (`inRange` x) $ Map.lookupLE x mp
    where
        mp = foldl&apos; add Map.empty xs

        merge (l1,u1) (l2,u2) = (min l1 l2, max u1 u2)
        overlap x1 x2 = x1 `inRange` fst x2 || x2 `inRange` fst x1
        add mp x
            | Just x2 &lt;- Map.lookupLE (fst x) mp, overlap x x2 = add (Map.delete (fst x2) mp) (merge x x2)
            | Just x2 &lt;- Map.lookupGE (fst x) mp, overlap x x2 = add (Map.delete (fst x2) mp) (merge x x2)
            | otherwise = uncurry Map.insert x mp


general_util_test :: IO ()
general_util_test = do
    testing &quot;General.Util.splitPair&quot; $ do
        let a === b = if a == b then putChar &apos;.&apos; else errorIO $ show (a,b)
        splitPair &quot;:&quot; &quot;module:foo:bar&quot; === (&quot;module&quot;,&quot;foo:bar&quot;)
        do x &lt;- try_ $ evaluate $ rnf $ splitPair &quot;-&quot; &quot;module:foo&quot;; isLeft x === True
        splitPair &quot;-&quot; &quot;module-&quot; === (&quot;module&quot;,&quot;&quot;)
    testing_ &quot;General.Util.inRanges&quot; $ do
        quickCheck $ \(x :: Int8) xs -&gt; inRanges xs x == any (`inRange` x) xs
    testing &quot;General.Util.parseTrailingVersion&quot; $ do
        let a === b = if a == b then putChar &apos;.&apos; else errorIO $ show (a,b)
        parseTrailingVersion &quot;shake-0.15.2&quot; === (&quot;shake&quot;,[0,15,2])
        parseTrailingVersion &quot;test-of-stuff1&quot; === (&quot;test-of-stuff1&quot;,[])</file><file path="src/General/Web.hs">{-# LANGUAGE ScopedTypeVariables, OverloadedStrings, ViewPatterns, RecordWildCards, DeriveFunctor #-}

module General.Web(
    Input(..),
    Output(..), readInput, server, general_web_test
    ) where

import Network.Wai.Handler.Warp hiding (Port, Handle)
import Network.Wai.Handler.WarpTLS

import Action.CmdLine
import Network.Wai.Logger
import Network.Wai
import Control.DeepSeq
import Network.HTTP.Types (parseQuery, decodePathSegments)
import Network.HTTP.Types.Status
import qualified Data.Text as Text
import qualified Data.ByteString.Char8 as BS
import qualified Data.ByteString.Lazy.Char8 as LBS
import Data.List.Extra
import Data.Aeson.Encoding
import Data.Char
import Data.String
import Data.Tuple.Extra
import Data.Maybe
import Data.Monoid
import System.FilePath
import Control.Exception.Extra
import System.Time.Extra
import General.Log
import General.Util
import Prelude
import qualified Data.ByteString.UTF8 as UTF8


data Input = Input
    {inputURL :: [String]
    ,inputArgs :: [(String, String)]
    } deriving (Eq, Show)

readInput :: String -&gt; Maybe Input
readInput (breakOn &quot;?&quot; -&gt; (a,b)) =
  if (badPath path || badArgs args) then Nothing else Just $ Input path args
  where
    path = parsePath a
    parsePath = map Text.unpack
              . decodePathSegments
              . BS.pack
    -- Note that there is a difference between URL paths
    -- which split on / and only that and file paths where
    -- an escaped %2f is equivalent to /. decodePathSegments
    -- (correctly) only considers the former so here
    -- we add an extra check that the result (which has unescaped %2f to /)
    -- does not contain path separators.
    badPath = any badSegment . filter (/= &quot;&quot;)
    badSegment seg = all (== &apos;.&apos;) seg || any isPathSeparator seg
    args = parseArgs b
    parseArgs = map (UTF8.toString *** maybe &quot;&quot; UTF8.toString)
              . parseQuery
              . UTF8.fromString
    badArgs = not . all (all isLower . fst)

data Output
    = OutputText LBS.ByteString
    | OutputHTML LBS.ByteString
    | OutputJavascript LBS.ByteString
    | OutputJSON Encoding
    | OutputFail LBS.ByteString
    | OutputFile FilePath
      deriving Show

-- | Force all the output (no delayed exceptions) and produce bytestrings
forceBS :: Output -&gt; LBS.ByteString
forceBS (OutputText x) = force x
forceBS (OutputJSON x) = force $ encodingToLazyByteString x
forceBS (OutputHTML x) = force x
forceBS (OutputJavascript x) = force x
forceBS (OutputFail x) = force x
forceBS (OutputFile x) = rnf x `seq` LBS.empty

instance NFData Output where
    rnf x = forceBS x `seq` ()

server :: Log -&gt; CmdLine -&gt; (Input -&gt; IO Output) -&gt; IO ()
server log Server{..} act = do
    let
        host&apos; = fromString $
                  if host == &quot;&quot; then
                    if local then
                      &quot;127.0.0.1&quot;
                    else
                      &quot;*&quot;
                  else
                    host
        set = setOnExceptionResponse exceptionResponseForDebug
            . setHost host&apos;
            . setPort port $
            defaultSettings
        runServer :: Application -&gt; IO ()
        runServer = if https then runTLS (tlsSettings cert key) set
                             else runSettings set
        secH = if no_security_headers then []
                                      else [
             -- The CSP is giving additional instructions to the browser.
             (&quot;Content-Security-Policy&quot;,
              -- For any content type not specifically enumerated in this CSP
              -- (e.g. fonts), the only valid origin is the same as the current
              -- page.
              &quot;default-src &apos;self&apos;;&quot;
              -- As an exception to the default rule, allow scripts from jquery
              -- and the CDN.
              &lt;&gt; &quot; script-src &apos;self&apos; https://code.jquery.com/ https://rawcdn.githack.com;&quot;
              -- As an exception to the default rule, allow stylesheets from
              -- the CDN. TODO: for now, we are also enabling inline styles,
              -- because it the chosen plugin uses them.
              &lt;&gt; &quot; style-src &apos;self&apos; &apos;unsafe-inline&apos; https://rawcdn.githack.com;&quot;
              -- As an exception to the default rule, allow images from the
              -- CDN.
              &lt;&gt; &quot; img-src &apos;self&apos; https://rawcdn.githack.com;&quot;
              -- Only allow this request in an iframe if the containing page
              -- has the same origin.
              &lt;&gt; &quot; frame-ancestors &apos;self&apos;;&quot;
              -- Forms are only allowed to target addresses under the same
              -- origin as the page.
              &lt;&gt; &quot; form-action &apos;self&apos;;&quot;
              -- Any request originating from this page and specifying http as
              -- its protocol will be automatically upgraded to https.
              &lt;&gt; (if https then &quot; upgrade-insecure-requests;&quot; else mempty)
              -- Do not display http content if the page was loaded under
              -- https.
              &lt;&gt; &quot; block-all-mixed-content&quot;),

             -- Tells the browser this web page should not be rendered inside a
             -- frame, except if the framing page comes from the same origin
             -- (i.e. DNS name + port). This is to thwart invisible, keylogging
             -- framing pages.
             (&quot;X-Frame-Options&quot;, &quot;sameorigin&quot;),

             -- Tells browsers to trust the Content-Type header and not try to
             -- otherwise guess at response types. In particular, prevents
             -- dangerous browser behaviour that would execute a file loaded
             -- from a &lt;script&gt; or &lt;style&gt; tag despite not having a
             -- text/javascript or text/css Content-Type.
             (&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;),

             -- Browser should try to detect &quot;reflected&quot; XSS attacks, where
             -- some suspicious payload of the request appears in the response.
             -- How browsers do that is unspecified. On detection, browser
             -- should block the page from rendering at all.
             (&quot;X-XSS-Protection&quot;, &quot;1; mode=block&quot;),

             -- Do not include referrer information if user-agent generates a
             -- request from an HTTPS page to an HTTP one. Note: this is
             -- technically redundant as this should be the browser default
             -- behaviour.
             (&quot;Referrer-Policy&quot;, &quot;no-referrer-when-downgrade&quot;),

             -- Strict Transport Security (aka HSTS) tells the browser that,
             -- from now on and until max-age seconds have passed, it should
             -- never try to connect to this domain name through unprotected
             -- HTTP. The browser will automatically upgrade any HTTP request
             -- to this domain name to HTTPS, client side, before any network
             -- call happens.
             (&quot;Strict-Transport-Security&quot;, &quot;max-age=31536000; includeSubDomains&quot;)]

    logAddMessage log $ &quot;Server starting on port &quot; ++ show port ++ &quot; and host/IP &quot; ++ show host&apos;

    runServer $ \req reply -&gt; do
        let pq = BS.unpack $ rawPathInfo req &lt;&gt; rawQueryString req
        putStrLn pq
        (time, res) &lt;- duration $ case readInput pq of
            Nothing -&gt; pure $ Right (OutputFail &quot;&quot;, LBS.pack $ &quot;Bad URL: &quot; ++ pq)
            Just pay -&gt;
                handle_ (fmap Left . showException) $ do
                    s &lt;- act pay; bs &lt;- evaluate $ forceBS s; pure $ Right (s, bs)
        logAddEntry log (showSockAddr $ remoteHost req) pq time (either Just (const Nothing) res)
        case res of
            Left s -&gt; reply $ responseLBS status500 [] $ LBS.pack s
            Right (v, bs) -&gt; reply $ case v of
                OutputFile file -&gt; responseFile status200
                    ([(&quot;content-type&quot;,c) | Just c &lt;- [lookup (takeExtension file) contentType]] ++ secH) file Nothing
                OutputText{} -&gt; responseLBS status200 ((&quot;content-type&quot;,&quot;text/plain&quot;) : secH) bs
                OutputJSON{} -&gt; responseLBS status200 ((&quot;content-type&quot;,&quot;application/json&quot;) : (&quot;access-control-allow-origin&quot;,&quot;*&quot;) : secH) bs
                OutputFail{} -&gt; responseLBS status400 ((&quot;content-type&quot;,&quot;text/plain&quot;) : secH) bs
                OutputHTML{} -&gt; responseLBS status200 ((&quot;content-type&quot;,&quot;text/html&quot;) : secH) bs
                OutputJavascript{} -&gt; responseLBS status200 ((&quot;content-type&quot;,&quot;text/javascript&quot;) : secH) bs

contentType = [(&quot;.html&quot;,&quot;text/html&quot;),(&quot;.css&quot;,&quot;text/css&quot;),(&quot;.js&quot;,&quot;text/javascript&quot;)]

general_web_test :: IO ()
general_web_test = do
    testing &quot;General.Web.readInput&quot; $ do
        let a === b = if a == b then putChar &apos;.&apos; else errorIO $ show (a,b)
        readInput &quot;abc&quot; === Just (Input [&quot;abc&quot;] [])
        readInput &quot;/abc&quot; === Just (Input [&quot;abc&quot;] [])
        readInput &quot;/abc/&quot; === Just (Input [&quot;abc&quot;, &quot;&quot;] [])
        readInput &quot;abc?ab=cd&amp;ef=gh&quot; === Just (Input [&quot;abc&quot;] [(&quot;ab&quot;, &quot;cd&quot;), (&quot;ef&quot;, &quot;gh&quot;)])
        readInput &quot;%2fabc&quot; === Nothing
        readInput &quot;%2F&quot; === Nothing
        readInput &quot;def%2fabc&quot; === Nothing
        readInput &quot;.&quot; === Nothing
        readInput &quot;..&quot; === Nothing
        readInput &quot;..a&quot; === Just (Input [&quot;..a&quot;] [])
        readInput &quot;../a&quot; === Nothing
        readInput &quot;a/../a&quot; === Nothing
        readInput &quot;%2e&quot; === Nothing
        readInput &quot;%2E&quot; === Nothing</file><file path="src/Input/Cabal.hs">{-# LANGUAGE ViewPatterns, PatternGuards, TupleSections, RecordWildCards, ScopedTypeVariables #-}
{-# OPTIONS_GHC -Wall -Wno-name-shadowing #-}

-- | Module for reading Cabal files.
module Input.Cabal(
    PkgName, Package(..),
    parseCabalTarball, readGhcPkg,
    packagePopularity, readCabal
    ) where

import Input.Settings

import Data.List.Extra
import System.FilePath
import Control.DeepSeq
import Control.Exception.Extra
import Control.Monad
import System.IO.Extra
import General.Str
import System.Exit
import qualified System.Process.ByteString as BS
import qualified Data.ByteString.UTF8 as UTF8
import System.Directory
import Data.Maybe
import Data.Tuple.Extra
import qualified Data.Map.Strict as Map
import General.Util
import Data.Semigroup
import Control.Applicative
import Prelude

import Distribution.Compat.Lens (toListOf)
import qualified Distribution.PackageDescription as PD
import qualified Distribution.PackageDescription.Configuration as PD
import qualified Distribution.PackageDescription.Parsec as PD
import qualified Distribution.Pretty
import qualified Distribution.Types.BuildInfo.Lens as Lens
import Distribution.Types.PackageName (mkPackageName, unPackageName)
import Distribution.Types.Version (versionNumbers)
import Distribution.Utils.ShortText (fromShortText)
import Hackage.RevDeps (lastVersionsOfPackages)
import qualified Distribution.SPDX as SPDX

---------------------------------------------------------------------
-- DATA TYPE

-- | A representation of a Cabal package.
data Package = Package
    {packageTags :: ![(Str, Str)] -- ^ The Tag information, e.g. (category,Development) (author,Neil Mitchell).
    ,packageLibrary :: !Bool -- ^ True if the package provides a library (False if it is only an executable with no API)
    ,packageSynopsis :: !Str -- ^ The synposis, grabbed from the top section.
    ,packageVersion :: !Str -- ^ The version, grabbed from the top section.
    ,packageDepends :: ![PkgName] -- ^ The list of packages that this package directly depends on.
    ,packageDocs :: !(Maybe FilePath) -- ^ Directory where the documentation is located
    } deriving Show

instance Semigroup Package where
    Package x1 x2 x3 x4 x5 x6 &lt;&gt; Package y1 y2 y3 y4 y5 y6 =
        Package (x1++y1) (x2||y2) (one x3 y3) (one x4 y4) (nubOrd $ x5 ++ y5) (x6 `mplus` y6)
        where one a b = if strNull a then b else a

instance Monoid Package where
    mempty = Package [] True mempty mempty [] Nothing
    mappend = (&lt;&gt;)

instance NFData Package where
    rnf (Package a b c d e f) = rnf (a,b,c,d,e,f)


---------------------------------------------------------------------
-- POPULARITY

-- | Given a set of packages, return the popularity of each package, along with any warnings
--   about packages imported but not found.
packagePopularity :: Map.Map PkgName Package -&gt; ([String], Map.Map PkgName Int)
packagePopularity cbl = mp `seq` (errs, mp)
    where
        mp = Map.map length good
        errs =  [ unPackageName user ++ &quot;.cabal: Import of non-existant package &quot; ++ unPackageName name ++
                          (if null rest then &quot;&quot; else &quot;, also imported by &quot; ++ show (length rest) ++ &quot; others&quot;)
                | (name, user:rest) &lt;- Map.toList bad]
        (good, bad)  = Map.partitionWithKey (\k _ -&gt; k `Map.member` cbl) $
            Map.fromListWith (++) [(b,[a]) | (a,bs) &lt;- Map.toList cbl, b &lt;- packageDepends bs]


---------------------------------------------------------------------
-- READERS

-- | Run &apos;ghc-pkg&apos; and get a list of packages which are installed.
readGhcPkg :: Settings -&gt; IO (Map.Map PkgName Package)
readGhcPkg settings = do
    topdir &lt;- findExecutable &quot;ghc-pkg&quot;
    (exit, stdout, stderr) &lt;-
    -- From GHC 9.0.1, the `haddock-html` field in `*.conf` files for GHC boot
    -- libraries has used `${pkgroot}`, which can be expanded in the output.

    -- On Windows, the `haddock-html` field in `*.conf` files for GHC boot
    -- libraries for GHC &gt;= 9.0 &amp;&amp; &lt; 9.10 contain errors. For example, this may
    -- be specified:
    --
    --     haddock-html: ${pkgroot}/../../doc/html/libraries/base-4.18.0.0
    --
    -- when the correct specification would be:
    --
    --     haddock-html: ${pkgroot}/../doc/html/libraries/base-4.18.0.0
    --
    -- However haddock does not seek to correct that. It assumes that users will
    -- correct manually the affected `*.conf` files.

    -- important to use BS process reading so it&apos;s in Binary format, see #194
      BS.readProcessWithExitCode &quot;ghc-pkg&quot; [&quot;dump&quot;, &quot;--expand-pkgroot&quot;] mempty
    when (exit /= ExitSuccess) $
        errorIO $ &quot;Error when reading from ghc-pkg, &quot; ++ show exit ++ &quot;\n&quot; ++ UTF8.toString stderr
    let g (stripPrefix &quot;$topdir&quot; -&gt; Just x) | Just t &lt;- topdir = takeDirectory t ++ x
        -- ^ Backwards compatibility with GHC &lt; 9.0
        g x = x
    let fixer p = p{packageLibrary = True, packageDocs = g &lt;$&gt; packageDocs p}
    let f ((stripPrefix &quot;name: &quot; -&gt; Just x):xs) = Just (mkPackageName $ trimStart x, fixer $ readCabal settings $ bstrPack $ unlines xs)
        f _ = Nothing
    pure $ Map.fromList $ mapMaybe f $ splitOn [&quot;---&quot;] $ lines $ filter (/= &apos;\r&apos;) $ UTF8.toString stdout


-- | Given a tarball of Cabal files, parse the latest version of each package.
parseCabalTarball :: Settings -&gt; FilePath -&gt; IO (Map.Map PkgName Package)
parseCabalTarball settings tarfile = do
    lastVersions &lt;- lastVersionsOfPackages (const True) tarfile Nothing
    pure $ Map.map (readCabal settings) lastVersions


---------------------------------------------------------------------
-- PARSERS

readCabal :: Settings -&gt; BStr -&gt; Package
readCabal settings src = case PD.parseGenericPackageDescriptionMaybe src of
    Nothing -&gt; Package
        { packageTags = []
        , packageLibrary = False
        , packageSynopsis = mempty
        , packageVersion = strPack &quot;0.0&quot;
        , packageDepends = []
        , packageDocs = Nothing
        }
    Just gpd -&gt; readCabal&apos; settings gpd

readCabal&apos; :: Settings -&gt; PD.GenericPackageDescription -&gt; Package
readCabal&apos; Settings{..} gpd = Package{..}
    where
        pd = PD.flattenPackageDescription gpd
        pkgId = PD.package pd

        packageDepends = nubOrd $ foldMap (map (\(PD.Dependency pkg _ _) -&gt; pkg) . PD.targetBuildDepends) $ toListOf Lens.traverseBuildInfos gpd
        packageVersion = strPack $ intercalate &quot;.&quot; $ map show $ versionNumbers $ PD.pkgVersion pkgId
        packageSynopsis = strPack $ fromShortText $ PD.synopsis pd
        packageLibrary = PD.hasPublicLib pd
        packageDocs = Nothing

        unpackLicenseExpression (SPDX.EOr x y) = unpackLicenseExpression x ++ unpackLicenseExpression y
        unpackLicenseExpression x = [x]

        packageLicenses = case PD.license pd of
            SPDX.NONE -&gt; []
            SPDX.License licExpr -&gt; map (show . Distribution.Pretty.pretty) $
                unpackLicenseExpression licExpr
        packageCategories =
            filter (not . null) $ split (`elem` &quot; ,&quot;) $
                fromShortText $ PD.category pd
        packageAuthor = fromShortText $ PD.author pd
        packageMaintainer = fromShortText $ PD.maintainer pd

        packageTags = map (both strPack) $ nubOrd $ concat
            [ map (&quot;license&quot;,) packageLicenses
            , map (&quot;category&quot;,) packageCategories
            , map (&quot;author&quot;,) (concatMap cleanup [packageAuthor, packageMaintainer])
            ]

        -- split on things like &quot;,&quot; &quot;&amp;&quot; &quot;and&quot;, then throw away email addresses, replace spaces with &quot;-&quot; and rename
        cleanup =
            filter (/= &quot;&quot;) .
            map (renameTag . intercalate &quot;-&quot; . filter (&apos;@&apos; `notElem`) . words . takeWhile (`notElem` &quot;&lt;(&quot;)) .
            concatMap (map unwords . split (== &quot;and&quot;) . words) . split (`elem` &quot;,&amp;&quot;)</file><file path="src/Input/Download.hs">{-# LANGUAGE TupleSections #-}

module Input.Download(downloadInput, DownloadInput(..)) where

import System.FilePath
import Control.Monad.Extra
import System.Directory
import Data.Conduit.Binary (sinkFile)
import Data.Default.Class
import qualified Network.HTTP.Conduit as C
import Network.Connection
import qualified Data.Conduit as C
import General.Util
import General.Timing
import Control.Monad.Trans.Resource
import Control.Exception.Extra

data DownloadInput =
    AlwaysDownloadInput
    | NeverDownloadInput
    | DownloadInputIfNotThere


-- | Download all the input files to input/
downloadInput :: Timing -&gt; Bool -&gt; DownloadInput -&gt; FilePath -&gt; String -&gt; URL -&gt; IO FilePath
downloadInput timing insecure download dir name url = do
    let file = dir &lt;/&gt; &quot;input-&quot; ++ name
    exists &lt;- doesFileExist file
    let act =
            timed timing (&quot;Downloading &quot; ++ url) $ do
                downloadFile insecure (file &lt;.&gt; &quot;part&quot;) url
                renameFile (file &lt;.&gt; &quot;part&quot;) file
    case download of
        NeverDownloadInput -&gt;
            unless exists $
              errorIO $ &quot;File is not already downloaded and --download=no given, downloading &quot; ++ url ++ &quot; to &quot; ++ file
        AlwaysDownloadInput -&gt; act
        DownloadInputIfNotThere -&gt;
            unless exists act
    pure file

downloadFile :: Bool -&gt; FilePath -&gt; String -&gt; IO ()
downloadFile insecure file url = do
    let request = C.parseRequest_ url
    manager &lt;- C.newManager $ C.mkManagerSettings
      (TLSSettingsSimple {
        settingDisableCertificateValidation = insecure,
        settingDisableSession = False,
        settingUseServerName = False,
        settingClientSupported = def
      }) Nothing
    runResourceT $ do
        response &lt;- C.http request manager
        C.runConduit $ C.responseBody response C..| sinkFile file</file><file path="src/Input/Haddock.hs">{-# LANGUAGE ViewPatterns, PatternGuards, TupleSections, OverloadedStrings, Rank2Types, DeriveDataTypeable, LambdaCase #-}
{-# OPTIONS_GHC -Wall #-}
{-# OPTIONS_GHC -Wno-name-shadowing #-}

module Input.Haddock(parseHoogle, fakePackage, input_haddock_test) where

import Language.Haskell.Exts as HSE
import Data.Char
import Data.List.Extra
import Data.Maybe
import Data.Data
import Input.Item
import Input.ParseDecl
import General.Util
import Control.DeepSeq
import Control.Monad.Trans.Class
import General.Conduit
import Control.Monad.Extra
import Control.Exception.Extra
import General.Str
import Safe
import Distribution.Types.PackageName (unPackageName, mkPackageName)


-- | An entry in the Hoogle DB
data Entry = EPackage PkgName
           | EModule ModName
           | EDecl (Decl ())
             deriving (Data, Show)


fakePackage :: PkgName -&gt; String -&gt; (Maybe Target, [Item])
fakePackage name desc = (Just $ Target (hackagePackageURL name) Nothing Nothing &quot;package&quot; (renderPackage name) desc, [IPackage name])

-- | Given a file name (for errors), feed in lines to the conduit and emit either errors or items
parseHoogle :: Monad m =&gt; (String -&gt; m ()) -&gt; URL -&gt; LBStr -&gt; ConduitM i (Maybe Target, [Item]) m ()
parseHoogle warning url body = sourceLStr body .| linesCR .| zipFromC 1 .| parserC warning .| hierarchyC url .| mapC (\x -&gt; rnf x `seq` x)

parserC :: Monad m =&gt; (String -&gt; m ()) -&gt; ConduitM (Int, BStr) (Target, Entry) m ()
parserC warning = f [] &quot;&quot;
    where
        f com url = do
            x &lt;- await
            whenJust x $ \(i,s) -&gt; case () of
                _ | s == &quot;}&quot; -&gt; f [] &quot;&quot;
                  -- Skip default methods like ($dmliftEq) and ($dmdisplayExceptionAnnotation)
                  | Just{} &lt;- bstrStripPrefix &quot;($dm&quot; s -&gt; f [] &quot;&quot;
                  | Just s &lt;- bstrStripPrefix &quot;-- | &quot; s -&gt; f [ignoreMath s] url
                  | Just s &lt;- bstrStripPrefix &quot;--&quot; s -&gt; f (if null com then [] else bstrTrimStart s : com) url
                  | Just s &lt;- bstrStripPrefix &quot;    --&quot; s -&gt; f (if null com then [] else bstrTrimStart s : com) url
                  | Just s &lt;- bstrStripPrefix &quot;@url &quot; s -&gt; f com (bstrUnpack s)
                  | bstrNull $ bstrTrimStart s -&gt; f [] &quot;&quot;
                  | otherwise -&gt; do
                        case parseLine $ fixLine $ bstrUnpack s of
                            Left y -&gt; lift $ warning $ show i ++ &quot;:&quot; ++ y
                            -- only check Nothing as some items (e.g. &quot;instance () :&gt; Foo a&quot;)
                            -- don&apos;t roundtrip but do come out equivalent
                            Right [EDecl InfixDecl{}] -&gt; pure () -- can ignore infix constructors
                            Right xs -&gt; forM_ xs $ \x -&gt;
                                yield (Target url Nothing Nothing (typeItem x) (renderItem x) $ reformat $ reverse com, x) -- descendBi stringShare x)
                        f [] &quot;&quot;


-- See https://github.com/ndmitchell/hoogle/issues/353
-- for functions like `tail` which start &lt;math&gt;.
ignoreMath :: BStr -&gt; BStr
ignoreMath x | Just x &lt;- &quot;&amp;lt;math&amp;gt;&quot; `bstrStripPrefix` x
             = fromMaybe x $ &quot;. &quot; `bstrStripPrefix` x
ignoreMath x = x

typeItem :: Entry -&gt; String
typeItem = \case
    EPackage{} -&gt; &quot;package&quot;
    EModule{} -&gt; &quot;module&quot;
    EDecl{} -&gt; &quot;&quot;

-- FIXME: used to be in two different modules, now does and then undoes lots of stuff
reformat :: [BStr] -&gt; String
reformat = unlines . map bstrUnpack


hierarchyC :: Monad m =&gt; URL -&gt; ConduitM (Target, Entry) (Maybe Target, [Item]) m ()
hierarchyC packageUrl = void $ mapAccumC f (Nothing, Nothing)
    where
        f (_pkg, _mod) (t, EPackage x) = ((Just (unPackageName x, url), Nothing), (Just t{targetURL=url}, [IPackage x]))
            where url = targetURL t `orIfNull` packageUrl
        f (pkg, _mod) (t, EModule x) = ((pkg, Just (strUnpack x, url)), (Just t{targetPackage=pkg, targetURL=url}, [IModule x]))
            where url = targetURL t `orIfNull` (if isGhc then ghcModuleURL x else hackageModuleURL x)
        f (pkg, mod) (_t, EDecl i@InstDecl{}) = ((pkg, mod), (Nothing, hseToItem_ i))
        f (pkg, mod) (t, EDecl x) = ((pkg, mod), (Just t{targetPackage=pkg, targetModule=mod, targetURL=url}, hseToItem_ x))
            where url = targetURL t `orIfNull` case x of
                            _ | [n] &lt;- declNames x -&gt; hackageDeclURL (isTypeSig x) n
                              | otherwise -&gt; &quot;&quot;

        isGhc = &quot;~ghc&quot; `isInfixOf` packageUrl || &quot;/&quot; `isSuffixOf` packageUrl

        hseToItem_ x = hseToItem x `orIfNull` error (&quot;hseToItem failed, &quot; ++ pretty x)
        infix 1 `orIfNull`
        orIfNull x y = if null x then y else x

renderPackage :: PkgName -&gt; [Char]
renderPackage x = &quot;&lt;b&gt;package&lt;/b&gt; &lt;span class=name&gt;&lt;s0&gt;&quot; ++ escapeHTML (unPackageName x) ++ &quot;&lt;/s0&gt;&lt;/span&gt;&quot;

renderModule :: Str -&gt; [Char]
renderModule (breakEnd (== &apos;.&apos;) . strUnpack -&gt; (pre,post)) = &quot;&lt;b&gt;module&lt;/b&gt; &quot; ++ escapeHTML pre ++ &quot;&lt;span class=name&gt;&lt;s0&gt;&quot; ++ escapeHTML post ++ &quot;&lt;/s0&gt;&lt;/span&gt;&quot;


renderItem :: Entry -&gt; String
renderItem = keyword . focus
    where
        keyword x | Just b &lt;- stripPrefix &quot;type family &quot; x = &quot;&lt;b&gt;type family&lt;/b&gt; &quot; ++ b
                  | (a,b) &lt;- word1 x, a `elem` kws = &quot;&lt;b&gt;&quot; ++ a ++ &quot;&lt;/b&gt; &quot; ++ b
                  | otherwise = x
            where kws = words &quot;class data type newtype&quot;

        name x = &quot;&lt;span class=name&gt;&quot; ++ x ++ &quot;&lt;/span&gt;&quot; :: String

        focus (EModule x) = renderModule x
        focus (EPackage x) = renderPackage x
        focus (EDecl x) | [now] &lt;- declNames x, (pre,stripPrefix now -&gt; Just post) &lt;- breakOn now $ pretty x =
            if &quot;(&quot; `isSuffixOf` pre &amp;&amp; &quot;)&quot; `isPrefixOf` post then
                init (escapeHTML pre) ++ name (&quot;(&quot; ++ highlight now ++ &quot;)&quot;) ++ escapeHTML (tailErr post)
            else
                escapeHTML pre ++ name (highlight now) ++ escapeHTML post
        focus (EDecl x) = pretty x

        highlight :: String -&gt; String
        highlight x = &quot;&lt;s0&gt;&quot; ++ escapeHTML x ++ &quot;&lt;/s0&gt;&quot;


parseLine :: String -&gt; Either String [Entry]
parseLine x@(&apos;@&apos;:str) = case a of
        &quot;package&quot; | [b] &lt;- words b, b /= &quot;&quot; -&gt; Right [EPackage $ mkPackageName b]
        &quot;version&quot; -&gt; Right []
        _ -&gt; Left $ &quot;unknown attribute: &quot; ++ x
    where (a,b) = word1 str
parseLine (stripPrefix &quot;module &quot; -&gt; Just x) = Right [EModule $ strPack x]
parseLine x | Just x &lt;- readItem x = case x of
    TypeSig a bs c -&gt; Right [EDecl (TypeSig a [b] c) | b &lt;- bs]
    x -&gt; Right [EDecl x]
parseLine x = Left $ &quot;failed to parse: &quot; ++ x


fixLine :: String -&gt; String
fixLine (stripPrefix &quot;instance [incoherent] &quot; -&gt; Just x) = fixLine $ &quot;instance &quot; ++ x
fixLine (stripPrefix &quot;instance [overlap ok] &quot; -&gt; Just x) = fixLine $ &quot;instance &quot; ++ x
fixLine (stripPrefix &quot;instance [overlapping] &quot; -&gt; Just x) = fixLine $ &quot;instance &quot; ++ x
fixLine (stripPrefix &quot;instance [safe] &quot; -&gt; Just x) = fixLine $ &quot;instance &quot; ++ x
fixLine (stripPrefix &quot;(#) &quot; -&gt; Just x) = &quot;( # ) &quot; ++ x
fixLine (&apos;[&apos;:x:xs) | isAlpha x || x `elem` (&quot;_(&quot; :: String), (a,&apos;]&apos;:b) &lt;- break (== &apos;]&apos;) xs = x : a ++ b
fixLine (&apos;[&apos;:&apos;:&apos;:xs) | (a,&apos;]&apos;:b) &lt;- break (== &apos;]&apos;) xs = &quot;(:&quot; ++ a ++ &quot;)&quot; ++ b
-- Record field accessor can start from &apos;$&apos;, such as ($*) in algebra-4.3.1
fixLine (&apos;[&apos;:&apos;$&apos;:xs) | (a,&apos;]&apos;:b) &lt;- break (== &apos;]&apos;) xs = &quot;($&quot; ++ a ++ &quot;)&quot; ++ b
-- Record field accessor can start from &apos;&gt;&apos;, such as (&gt;&gt;-) in turtle-1.6.2
fixLine (&apos;[&apos;:&apos;&gt;&apos;:xs) | (a,&apos;]&apos;:b) &lt;- break (== &apos;]&apos;) xs = &quot;(&gt;&quot; ++ a ++ &quot;)&quot; ++ b
fixLine x | &quot;class &quot; `isPrefixOf` x = fst $ breakOn &quot; where &quot; x
fixLine x = x


readItem :: String -&gt; Maybe (Decl ())
readItem x -- newtype
    | Just x &lt;- stripPrefix &quot;newtype &quot; x
    , ParseOk (DataDecl an _ b c d e) &lt;- fmap unGADT $ myParseDecl $ &quot;data &quot; ++ x
    = Just $ DataDecl an (NewType ()) b c d e
readItem x@(x0 : _) -- constructors
    | isUpper x0 || x0 == &apos;(&apos;
    , ParseOk (GDataDecl _ _ _ _ _ [GadtDecl s name _ _ _ ty] _) &lt;- myParseDecl $ &quot;data Data where &quot; ++ x
    , let f (TyBang _ _ _ (TyParen _ x@TyApp{})) = x
          f (TyParen _ x@TyApp{}) = x
          f (TyBang _ _ _ x) = x
          f x = x
    = Just $ TypeSig s [name] $ applyFun1 $ map f $ unapplyFun ty
readItem x | ParseOk y &lt;- myParseDecl x = Just $ unGADT y
readItem _ = Nothing

unGADT :: Decl l -&gt; Decl l
unGADT (GDataDecl a b c d _  [] e) = DataDecl a b c d [] e
unGADT x = x

prettyItem :: Entry -&gt; String
prettyItem (EPackage x) = &quot;package &quot; ++ unPackageName x
prettyItem (EModule x) = &quot;module &quot; ++ strUnpack x
prettyItem (EDecl x) = pretty x


input_haddock_test :: IO ()
input_haddock_test = testing &quot;Input.Haddock.parseLine&quot; $ do
    let a === b | fmap (map prettyItem) (parseLine a) == Right [b] = putChar &apos;.&apos;
                | otherwise = errorIO $ show (a,b,parseLine a, fmap (map prettyItem) $ parseLine a)
    let test a = a === a
    test &quot;type FilePath = [Char]&quot;
    test &quot;data Maybe a&quot;
    test &quot;Nothing :: Maybe a&quot;
    test &quot;Just :: a -&gt; Maybe a&quot;
    test &quot;newtype Identity a&quot;
    test &quot;foo :: Int# -&gt; b&quot;
    test &quot;(,,) :: a -&gt; b -&gt; c -&gt; (a, b, c)&quot;
    &quot;data (,,) a b&quot; === &quot;data Tuple3 a b&quot; -- when ghc-lib-parser &gt;= 9.8
    test &quot;reverse :: [a] -&gt; [a]&quot;
    -- Parallel Haskell has never been implemented
    -- test &quot;reverse :: [:a:] -&gt; [:a:]&quot;
    test &quot;module Foo.Bar&quot;
    test &quot;data Char&quot;
    &quot;data Char :: *&quot; === &quot;data Char&quot;
    &quot;newtype ModuleName :: *&quot; === &quot;newtype ModuleName&quot;
    &quot;Progress :: !(Maybe String) -&gt; {-# UNPACK #-} !Int -&gt; !(Int -&gt; Bool) -&gt; Progress&quot; ===
        &quot;Progress :: Maybe String -&gt; Int -&gt; (Int -&gt; Bool) -&gt; Progress&quot;
    test &quot;quotRemInt# :: Int# -&gt; Int# -&gt; (# Int#, Int# #)&quot;
    test &quot;( # ) :: Int&quot;
    test &quot;pattern MyPattern :: ()&quot;
    test &quot;degrees :: Floating x =&gt; Radians x -&gt; Degrees x&quot;
    test &quot;class Angle a&quot;
    test &quot;instance Eq x =&gt; Eq (Degrees x)&quot;
    test &quot;instance Angle Degrees&quot;
    test &quot;type Queue a = Deque Nonthreadsafe Nonthreadsafe SingleEnd SingleEnd Grow Safe a&quot;
    test &quot;class DequeClass d =&gt; PopL d&quot;
    test &quot;tests_fifo :: DequeClass d =&gt; (forall elt . IO (d elt)) -&gt; Test&quot;
    test &quot;class ParUnsafe iv p | p -&gt; iv&quot;
    test &quot;(##) :: Diagram -&gt; Diagram -&gt; Diagram&quot;
    test &quot;instance LayoutClass Positioned []&quot;
    test &quot;data Ord a =&gt; Range a&quot;
    test &quot;aPair :: Proxy (,)&quot;
    test &quot;aTriple :: Proxy (,,)&quot;
    test &quot;qop :: (Ord a, Show qtyp, Show (QFlipTyp qtyp), QFlipTyp (QFlipTyp qtyp) ~ qtyp) =&gt; Set (QueryRep QAtomTyp a) -&gt; Set (QueryRep (QFlipTyp qtyp) a) -&gt; QueryRep qtyp a&quot;
    test &quot;reorient :: (Unbox a) =&gt; Bernsteinp Int a -&gt; Bernsteinp Int a&quot;
    &quot;type family PrimM a :: * -&gt; *;&quot; === &quot;type family PrimM a :: * -&gt; *&quot;
    test &quot;HSNil :: HSet &apos;[]&quot;
    &quot;HSCons :: !elem -&gt; HSet elems -&gt; HSet (elem : elems)&quot; === &quot;HSCons :: elem -&gt; HSet elems -&gt; HSet (elem : elems)&quot;
    test &quot;instance Data.HSet.Reverse.HReverse &apos;[e] els1 els2 =&gt; Data.HSet.Reverse.HReverse &apos;[] (e : els1) els2&quot;
    test &quot;instance Data.HSet.Remove.HRemove (e : els) els &apos;TypeFun.Data.Peano.Z&quot;
    test &quot;Free :: (forall m . Monad m =&gt; Effects effects m -&gt; m a) -&gt; Free effects a&quot;
    test &quot;infixl 3 &lt;||&quot;
    test &quot;instance Data.String.IsString t =&gt; Data.String.IsString (t Yi.MiniBuffer.::: doc)&quot;
    test &quot;runValueExpression :: (Functor f) =&gt; Expression a ((-&gt;) b) f r -&gt; f ((a -&gt; b) -&gt; r)&quot;
    test &quot;HCons :: (x :: *) -&gt; HList xs -&gt; HList (x : xs)&quot;
    test &quot;instance forall k (key :: k) . Data.Traversable.Traversable (Data.ComposableAssociation.Association key)&quot;
    test &quot;ReflH :: forall (k :: *) (t :: k) . HetEq t t&quot;
    test &quot;egcd :: (PID d, (Euclidean d)) =&gt; d -&gt; d -&gt; (d, d, d)&quot;
    test &quot;proc :: FilePath -&gt; [String] -&gt; CreateProcess&quot;
    test &quot;unitTests :: Proxy &apos;()&quot;
    test &quot;type OneToFour = &apos;[1, 2, 3, 4]&quot;
    test &quot;data family Prio pol item :: *&quot;
    test &quot;set :: (Monad m, ToByteString a) =&gt; Key -&gt; a -&gt; Opts \&quot;SET\&quot; -&gt; Redis m Bool&quot;
    test &quot;by :: ByteString -&gt; Opts \&quot;SORT\&quot;&quot;
    test &quot;infixr 9 :+:&quot;
    test &quot;instance forall k1 k2 (expectation1 :: k2) (expectation2 :: k1) . (Test.TypeSpec.Core.PrettyTypeSpec expectation1, Test.TypeSpec.Core.PrettyTypeSpec expectation2) =&gt; Test.TypeSpec.Core.PrettyTypeSpec &apos;(expectation1, expectation2)&quot;
    test &quot;SomeFoo :: Foo a =&gt; m a -&gt; SomeFoo m&quot;
    test &quot;(@~?) :: (HasCallStack, Ord a, Num a, Show a, ?epsilon :: a) =&gt; a -&gt; a -&gt; Assertion&quot;
    test &quot;data Data where { Idx :: {idxChildren :: Index key (Node height key val)} -&gt; Node (&apos;S height) key val}&quot;
    test &quot;UnexpectedResponse :: forall k a b . () =&gt; Host -&gt; Response k a b -&gt; ProtocolError&quot;
    test &quot;(.) :: Category k cat =&gt; forall (b :: k) (c :: k) (a :: k) . cat b c -&gt; cat a b -&gt; cat a c&quot;
    test &quot;infixl 3 `And`&quot;
    test &quot;infix 1 `shouldBe`&quot;
    test &quot;pattern The :: The d a =&gt; a -&gt; d&quot;
    test &quot;Html :: Element \&quot;html\&quot; &apos;[] (Elements [\&quot;head\&quot;, \&quot;body\&quot;]) (ManifestA &amp; &apos;[])&quot;
    test &quot;instance forall k1 v1 (pk :: k1 -&gt; GHC.Types.Constraint) (k2 :: k1) (pv :: v1 -&gt; GHC.Types.Constraint) (v2 :: v1) . (pk k2, pv v2) =&gt; Type.Membership.KeyTargetAre pk pv (k2 &apos;Type.Membership.Internal.:&gt; v2)&quot;
    -- The following no longer parses since GHC 9.14 (which is the correct behaviour)
    -- test &quot;crDoubleBuffer :: CompactorReturn s -&gt; {-# UNPACK #-} !DoubleBuffer s&quot;
    test &quot;expectationFailure :: (?callStack :: CallStack) =&gt; String -&gt; Expectation&quot;
    test &quot;type family MapTyCon t xs = r | r -&gt; xs&quot;
    test &quot;pattern Id :: CRCategory k =&gt; ( ~ , Object k ) =&gt; k  &quot;
    test &quot;pattern Stream :: () =&gt; () =&gt; Repetition&quot;
    test &quot;In# :: (# #) -&gt; In (a :: Effects) (b :: Effects)&quot;
    test &quot;anyAsciiDecimalWord# :: Addr# -&gt; Addr# -&gt; (# (# #) | (# Word#, Addr# #) #)&quot;
    test &quot;class SymbolToField (sym :: Symbol) rec typ | sym rec -&gt; typ&quot;
    test &quot;closestPairDist_spec :: _ =&gt; ([r] -&gt; r) -&gt; (r -&gt; t) -&gt; [b] -&gt; Property&quot;
    -- Cannot faithfully represent ConstraintKind with ImplicitParams in HSE
    -- test &quot;type HasCallStack = ?callStack :: CallStack&quot;
    -- Cannot faithfully represent @r in HSE
    -- test &quot;Maybe# :: forall (r :: RuntimeRep) (a :: TYPE r). (# (# #) | a #) -&gt; Maybe# @r a&quot;
    -- Cannot faithfully represent visible binders in HSE
    -- test &quot;data NDFamily_ :: forall (name :: Name) -&gt; forall (ks :: Params name). ParamsProxy name ks -&gt; Res name ks Any :~: r -&gt; Args name ks -&gt; Exp r&quot;
    -- Cannot faithfully represent standalone kind signatures in HSE
    -- test &quot;type MinBound :: a;&quot;</file><file path="src/Input/Item.hs">{-# LANGUAGE GeneralizedNewtypeDeriving, DeriveDataTypeable, DeriveFunctor, ViewPatterns #-}
{-# LANGUAGE RecordWildCards, OverloadedStrings, PatternGuards, ScopedTypeVariables #-}

-- | Types used to generate the input.
module Input.Item(
    Sig(..), Ctx(..), Ty(..), prettySig,
    Item(..), itemName, highlightItem,
    Target(..), targetExpandURL, TargetId(..),
    splitIPackage, splitIModule,
    hseToSig, hseToItem, item_test,
    unHTMLTarget
    ) where

import Numeric
import Control.Applicative
import Data.Tuple.Extra
import Language.Haskell.Exts
import Data.Char
import Data.List.Extra
import Data.Maybe
import Data.Ix
import Data.Binary
import Foreign.Storable
import Control.DeepSeq
import Data.Data
import General.Util
import General.Str
import General.IString
import Prelude
import qualified Data.Aeson as J
import Data.Aeson.Types
import Test.QuickCheck
import Distribution.Types.PackageName (unPackageName, mkPackageName)
import Query

---------------------------------------------------------------------
-- TYPES

data Sig n = Sig {sigCtx :: [Ctx n], sigTy :: [Ty n]} deriving (Show,Eq,Ord,Typeable,Data,Functor) -- list of -&gt; types
data Ctx n = Ctx n n deriving (Show,Eq,Ord,Typeable,Data,Functor) -- context, second will usually be a free variable
data Ty n = TCon n [Ty n] | TVar n [Ty n] deriving (Show,Eq,Ord,Typeable,Data,Functor) -- type application, vectorised, all symbols may occur at multiple kinds

instance NFData n =&gt; NFData (Sig n) where rnf (Sig x y) = rnf x `seq` rnf y
instance NFData n =&gt; NFData (Ctx n) where rnf (Ctx x y) = rnf x `seq` rnf y
instance NFData n =&gt; NFData (Ty  n) where
    rnf (TCon x y) = rnf x `seq` rnf y
    rnf (TVar x y) = rnf x `seq` rnf y

instance Binary n =&gt; Binary (Sig n) where
    put (Sig a b) = put a &gt;&gt; put b
    get = liftA2 Sig get get

instance Binary n =&gt; Binary (Ctx n) where
    put (Ctx a b) = put a &gt;&gt; put b
    get = liftA2 Ctx get get

instance Binary n =&gt; Binary (Ty n) where
    put (TCon x y) = put (0 :: Word8) &gt;&gt; put x &gt;&gt; put y
    put (TVar x y) = put (1 :: Word8) &gt;&gt; put x &gt;&gt; put y
    get = do i :: Word8 &lt;- get; liftA2 (case i of 0 -&gt; TCon; 1 -&gt; TVar) get get

prettySig :: Sig String -&gt; String
prettySig Sig{..} =
        (if length ctx &gt; 1 then &quot;(&quot; ++ ctx ++ &quot;) =&gt; &quot;
         else if null ctx then &quot;&quot; else ctx ++ &quot; =&gt; &quot;) ++
        intercalate &quot; -&gt; &quot; (map f sigTy)
    where
        ctx = intercalate &quot;, &quot; [a ++ &quot; &quot; ++ b | Ctx a b &lt;- sigCtx]

        f (TVar x xs) = f $ TCon x xs
        f (TCon x []) = x
        f (TCon x xs) = &quot;(&quot; ++ unwords (x : map f xs) ++ &quot;)&quot;


---------------------------------------------------------------------
-- ITEMS

data Item
    = IPackage PkgName
    | IModule ModName
    | IName Str
    | ISignature (Sig IString)
    | IAlias Str [IString] (Sig IString)
    | IInstance (Sig IString)
      deriving (Show,Eq,Ord,Typeable,Data)

instance NFData Item where
    rnf (IPackage x) = rnf x
    rnf (IModule x) = rnf x
    rnf (IName x) = x `seq` ()
    rnf (ISignature x) = rnf x
    rnf (IAlias a b c) = rnf (a,b,c)
    rnf (IInstance a) = rnf a

itemName :: Item -&gt; Maybe Str
itemName (IPackage x) = Just $ strPack $ unPackageName x
itemName (IModule x) = Just x
itemName (IName x) = Just x
itemName (ISignature _) = Nothing
itemName (IAlias x _ _) = Just x
itemName (IInstance _) = Nothing


---------------------------------------------------------------------
-- DATABASE

newtype TargetId = TargetId Word32 deriving (Eq,Ord,Storable,NFData,Ix,Typeable)

instance Show TargetId where
    show (TargetId x) = showHex x &quot;&quot;

-- | A location of documentation.
data Target = Target
    {targetURL :: URL -- ^ URL where this thing is located
    ,targetPackage :: Maybe (String, URL) -- ^ Name and URL of the package it is in (Nothing if it is a package)
    ,targetModule :: Maybe (String, URL) -- ^ Name and URL of the module it is in (Nothing if it is a package or module)
    ,targetType :: String -- ^ One of package, module or empty string
    ,targetItem :: String -- ^ HTML span of the item, using @\&lt;s0\&gt;@ for the name and @\&lt;s1\&gt;@ onwards for arguments
    ,targetDocs :: String -- ^ HTML documentation to show, a sequence of block level elements
    } deriving (Show,Eq,Ord)

instance NFData Target where
    rnf (Target a b c d e f) = rnf a `seq` rnf b `seq` rnf c `seq` rnf d `seq` rnf e `seq` rnf f

instance ToJSON Target where
    toJSON (Target a b c d e f) = object [
      (&quot;url&quot;, toJSON a),
      (&quot;package&quot;, maybeNamedURL b),
      (&quot;module&quot;, maybeNamedURL c),
      (&quot;type&quot;, toJSON d),
      (&quot;item&quot;, toJSON e),
      (&quot;docs&quot;, toJSON f)
      ]
      where
        maybeNamedURL m = maybe emptyObject namedURL m
        namedURL (name, url) = object [(&quot;name&quot;, toJSON name), (&quot;url&quot;, toJSON url)]

instance FromJSON Target where
  parseJSON = withObject &quot;Target&quot; $ \o -&gt;
    Target &lt;$&gt; o .: &quot;url&quot;
           &lt;*&gt; o `namedUrl` &quot;package&quot;
           &lt;*&gt; o `namedUrl` &quot;module&quot;
           &lt;*&gt; o .: &quot;type&quot;
           &lt;*&gt; o .: &quot;item&quot;
           &lt;*&gt; o .: &quot;docs&quot;
    where namedUrl o&apos; n = do
             mObj &lt;- o&apos; .: n
             if null mObj then pure Nothing
                        else do
                           pkName &lt;- mObj .: &quot;name&quot;
                           pkUrl  &lt;- mObj .: &quot;url&quot;
                           pure $ Just (pkName, pkUrl)

instance Arbitrary Target where
  arbitrary = Target &lt;$&gt; a
                     &lt;*&gt; mNurl
                     &lt;*&gt; mNurl
                     &lt;*&gt; a
                     &lt;*&gt; a
                     &lt;*&gt; a
    where a = arbitrary
          mNurl = do
            oneof [pure Nothing
                 , Just &lt;$&gt; liftA2 (,) a a]

targetExpandURL :: Target -&gt; Target
targetExpandURL t@Target{..} = t{targetURL = url, targetModule = second (const mod) &lt;$&gt; targetModule}
    where
        pkg = maybe &quot;&quot; snd targetPackage
        mod = maybe pkg (plus pkg . snd) targetModule
        url = plus mod targetURL

        plus a b | b == &quot;&quot; = &quot;&quot;
                 | &apos;:&apos;:_ &lt;- dropWhile isAsciiLower b = b -- match http: etc
                 | otherwise = a ++ b

unHTMLTarget :: Target -&gt; Target
unHTMLTarget t@Target {..} = t{targetItem=unHTML targetItem, targetDocs=unHTML targetDocs}

splitIPackage :: [(a, Item)] -&gt; [(PkgName, [(a, Item)])]
splitIPackage = splitUsing (mkPackageName &quot;&quot;) $ \x -&gt; case snd x of
    IPackage x -&gt; Just x
    _ -&gt; Nothing

splitIModule :: [(a, Item)] -&gt; [(Str, [(a, Item)])]
splitIModule = splitUsing mempty $ \x -&gt; case snd x of
    IModule x -&gt; Just x
    _ -&gt; Nothing

splitUsing :: b -&gt; (a -&gt; Maybe b) -&gt; [a] -&gt; [(b, [a])]
splitUsing def f = repeatedly $ \(x:xs) -&gt;
    let (a,b) = break (isJust . f) xs
    in ((fromMaybe def $ f x, x:a), b)

item_test :: IO ()
item_test = testing &quot;Input.Item.Target JSON (encode . decode = id) &quot; $ do
  quickCheck $ \(t :: Target) -&gt; case J.eitherDecode $ J.encode t of
    (Left  e ) -&gt; False
    (Right t&apos;) -&gt; t == t&apos;

highlightItem:: Monoid m =&gt; (String -&gt; m) -&gt; (String -&gt; m) -&gt; (String -&gt; m) -&gt; (String -&gt; m) -&gt; [Query] -&gt; String -&gt; m
highlightItem plain safe dull bold qs x
    | Just (pre,x) &lt;- stripInfix &quot;&lt;s0&gt;&quot; x, Just (name,post) &lt;- stripInfix &quot;&lt;/s0&gt;&quot; x
        = safe pre &lt;&gt; highlight (unescapeHTML name) &lt;&gt; safe post
    | otherwise = plain x
    where
        highlight x = mconcatMap (\xs@((b,_):_) -&gt; let s = map snd xs in if b then bold s else dull s) $
                    groupOn fst $ zip (findQueries x) x
            where
                -- generates a bool mask, which is only true for charachters that compose given queries
                -- e.g. [ &quot;query&quot; &quot;ya&quot; ] -&gt; [ &quot;AqUeRyAA&quot; ] -&gt; 01111110
                findQueries :: String -&gt; [Bool]
                findQueries (x:xs) | m &gt; 0 = replicate m True ++ drop (m - 1) (findQueries xs)
                    where m = maximum $ 0 : [length y | QueryName y &lt;- qs, lower y `isPrefixOf` lower (x:xs)]
                findQueries (x:xs) = False : findQueries xs
                findQueries [] = []

---------------------------------------------------------------------
-- HSE CONVERSION

hseToSig :: Type a -&gt; Sig String
hseToSig = tyForall
    where
        -- forall at the top is different
        tyForall (TyParen _ x) = tyForall x
        tyForall (TyForall _ _ c t) | Sig cs ts &lt;- tyForall t =
            Sig (maybe [] (concatMap ctx . fromContext) c ++ cs) ts
        tyForall x = Sig [] $ tyFun x

        tyFun (TyParen _ x) = tyFun x
        tyFun (TyFun _ a b) = ty a : tyFun b
        tyFun x = [ty x]

        ty (TyForall _ _ _ x) = TCon &quot;\\/&quot; [ty x]
        ty x@TyFun{} = TCon &quot;-&gt;&quot; $ tyFun x
        ty (TyTuple an box ts) = TCon (fromQName $ Special an $ TupleCon an box $ length ts - 1) (map ty ts)
        ty (TyList _ x) = TCon &quot;[]&quot; [ty x]
        ty (TyParArray _ x) = TCon &quot;[::]&quot; [ty x]
        ty (TyApp _ x y) = case ty x of
            TCon a b -&gt; TCon a (b ++ [ty y])
            TVar a b -&gt; TVar a (b ++ [ty y])
        ty (TyVar _ x) = TVar (fromName x) []
        ty (TyCon _ x) = TCon (fromQName x) []
        ty (TyInfix an a (UnpromotedName _ b) c) = ty $ let ap = TyApp an in TyCon an b `ap` a `ap` c
        ty (TyKind _ x _) = ty x
        ty (TyBang _ _ _ x) = ty x
        ty (TyParen _ x) = ty x
        ty _ = TVar &quot;_&quot; []

        ctx (ParenA _ x) = ctx x
        ctx (TypeA _ x)  = ctxTy x
        ctx _ = []

        ctxTy (TyInfix an a (UnpromotedName _ con) b) = ctxTy $ TyApp an (TyApp an (TyCon an con) a) b
        ctxTy (fromTyApps -&gt; TyCon _ con:TyVar _ var:_) = [Ctx (fromQName con) (fromName var)]
        ctxTy _ = []

        fromTyApps (TyApp _ x y) = fromTyApps x ++ [y]
        fromTyApps x = [x]


hseToItem :: Decl a -&gt; [Item]
hseToItem (TypeSig _ names ty) = ISignature (toIString . strPack &lt;$&gt; hseToSig ty) : map (IName . strPack . fromName) names
hseToItem (TypeDecl _ (fromDeclHead -&gt; (name, bind)) rhs) = [IAlias (strPack $ fromName name) (map (toIString . strPack . fromName . fromTyVarBind) bind) (toIString . strPack &lt;$&gt; hseToSig rhs)]
hseToItem (InstDecl an _ (fromIParen -&gt; IRule _ _ ctx (fromInstHead -&gt; (name, args))) _) = [IInstance $ fmap (toIString . strPack) $ hseToSig $ TyForall an Nothing ctx $ applyType (TyCon an name) args]
hseToItem x = map (IName . strPack) $ declNames x</file><file path="src/Input/ParseDecl.hs">{-# LANGUAGE CPP #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE PatternSynonyms #-}
{-# OPTIONS_GHC -Wall #-}
{-# OPTIONS_GHC -Wno-missing-signatures -Wno-missing-pattern-synonym-signatures #-}

module Input.ParseDecl (myParseDecl) where

import Prelude hiding (Foldable(..))
import Data.Char (isAlphaNum, isUpper)
import Data.Foldable (Foldable(..))
import Data.List.Extra (dropEnd1, drop1, enumerate, stripPrefix, unsnoc, isInfixOf)
import Data.List.NonEmpty qualified as NE (toList)
import Data.Maybe (isNothing)
import GHC.Data.EnumSet qualified as EnumSet
import GHC.Data.FastString (unpackFS)
import GHC.Data.StringBuffer (stringToStringBuffer)
import GHC.Hs
import GHC.LanguageExtensions.Type (Extension (..))
import GHC.Parser (parseDeclaration)
import GHC.Parser.Lexer (P (..), ParseResult (..), initParserState, mkParserOpts)
import GHC.Types.Fixity (Fixity (..), FixityDirection (..))
import GHC.Types.Name (nameOccName, tvName)
import GHC.Types.Name.Occurrence (OccName (..), occNameString)
import GHC.Types.Name.Reader (RdrName (..), rdrNameOcc, rdrNameSpace)
import GHC.Types.SourceText (SourceText (..))
import GHC.Types.SrcLoc (GenLocated (..), mkRealSrcLoc, unLoc)
import GHC.Unit (GenModule (..))
import GHC.Utils.Error
import GHC.Utils.Outputable (Outputable (..), defaultSDocContext, runSDoc)
import Language.Haskell.Exts qualified as HSE
import Text.Read (readMaybe)

#if !MIN_VERSION_ghc_lib_parser(9,12,0)
pattern HsBang x y &lt;- HsSrcBang _ x y
#endif

#if MIN_VERSION_ghc_lib_parser(9,12,0)
pattern MyFixity x y &lt;- Fixity x y
#else
pattern MyFixity x y &lt;- Fixity _ x y
#endif

#if MIN_VERSION_ghc_lib_parser(9,10,0)
pattern MyPrefixConGADT x &lt;- PrefixConGADT _ x
pattern MyRecConGADT x &lt;- RecConGADT _ x
#else
pattern MyPrefixConGADT x &lt;- PrefixConGADT x
pattern MyRecConGADT x &lt;- RecConGADT x _
#endif

#if !MIN_VERSION_ghc_lib_parser(9,14,0)
#define con_outer_bndrs con_bndrs
#endif

myParseDecl :: String -&gt; HSE.ParseResult (HSE.Decl ())
myParseDecl str = case runGhcLibParser str of
    POk _state x -&gt; case hsDeclToDecl (unLoc x) of
        Nothing -&gt; HSE.ParseFailed HSE.noLoc str
        Just res -&gt; HSE.ParseOk res
    PFailed _state -&gt; HSE.ParseFailed HSE.noLoc str

hsDeclToDecl :: HsDecl GhcPs -&gt; Maybe (HSE.Decl ())
hsDeclToDecl (TyClD _ (SynDecl{tcdLName, tcdTyVars = HsQTvs{hsq_explicit}, tcdRhs})) =
    Just $
        HSE.TypeDecl
            ()
            ( foldl&apos;
                (\acc (L _ tv) -&gt; HSE.DHApp () acc (hsTyVarBndrToTyVarBind tv))
                (HSE.DHead () $ rdrNameToName $ unLoc tcdLName)
                hsq_explicit
            )
            (hsTypeToType $ unLoc tcdRhs)
hsDeclToDecl (TyClD _ (GHC.Hs.DataDecl{tcdLName, tcdTyVars = HsQTvs{hsq_explicit}, tcdDataDefn = HsDataDefn{dd_cons = DataTypeCons _ [], dd_ctxt, dd_kindSig = Nothing}})) =
    Just $
        HSE.DataDecl
            ()
            (HSE.DataType ())
            (fmap (hsTypesToContext . unLoc) dd_ctxt)
            ( foldl&apos;
                (\acc (L _ tv) -&gt; HSE.DHApp () acc (hsTyVarBndrToTyVarBind tv))
                (HSE.DHead () $ rdrNameToName $ unLoc tcdLName)
                hsq_explicit
            )
            []
            []
hsDeclToDecl (TyClD _ (GHC.Hs.DataDecl{tcdLName, tcdTyVars = HsQTvs{hsq_explicit}, tcdDataDefn = HsDataDefn{dd_cons = DataTypeCons _ [], dd_kindSig = Just kind}})) =
    Just $
        HSE.GDataDecl
            ()
            (HSE.DataType ())
            Nothing
            ( foldl&apos;
                (\acc (L _ tv) -&gt; HSE.DHApp () acc (hsTyVarBndrToTyVarBind tv))
                (HSE.DHead () $ rdrNameToName $ unLoc tcdLName)
                hsq_explicit
            )
            (Just $ hsTypeToType $ unLoc kind)
            []
            []
hsDeclToDecl (TyClD _ (GHC.Hs.DataDecl{tcdLName, tcdTyVars = HsQTvs{hsq_explicit}, tcdDataDefn = HsDataDefn{dd_cons = DataTypeCons _ [L _ (ConDeclGADT{con_names, con_outer_bndrs, con_g_args = MyPrefixConGADT args, con_res_ty, con_mb_cxt})]}})) =
    Just $
        HSE.GDataDecl
            ()
            (HSE.DataType ())
            Nothing
            ( foldl&apos;
                (\acc (L _ tv) -&gt; HSE.DHApp () acc (hsTyVarBndrToTyVarBind tv))
                (HSE.DHead () $ rdrNameToName $ unLoc tcdLName)
                hsq_explicit
            )
            Nothing
            ( map
                ( \con_name -&gt;
                    HSE.GadtDecl
                        ()
                        (rdrNameToName $ unLoc con_name)
                        Nothing
                        Nothing
                        Nothing
                        ( maybe id (\bs -&gt; applyTyForall (Just bs) Nothing) (hsOuterTyVarBndrsToFoo $ unLoc con_outer_bndrs) $
                            maybe id (applyTyForall Nothing . Just . hsTypesToContext . unLoc) con_mb_cxt $
                                foldr
#if MIN_VERSION_ghc_lib_parser(9,14,0)
                                    (\CDF{cdf_type} -&gt; HSE.TyFun () (hsTypeToType $ unLoc cdf_type))
#else
                                    (\(HsScaled _ a) -&gt; HSE.TyFun () (hsTypeToType $ unLoc a))
#endif
                                    (hsTypeToType $ unLoc con_res_ty)
                                    args
                        )
                )
                (NE.toList con_names)
            )
            []
hsDeclToDecl (TyClD _ (GHC.Hs.DataDecl{tcdLName, tcdTyVars = HsQTvs{hsq_explicit}, tcdDataDefn = HsDataDefn{dd_cons = DataTypeCons _ [L _ (ConDeclGADT{con_names, con_outer_bndrs, con_g_args = MyRecConGADT (L _ args), con_res_ty, con_mb_cxt})]}})) =
    Just $
        HSE.GDataDecl
            ()
            (HSE.DataType ())
            Nothing
            ( foldl&apos;
                (\acc (L _ tv) -&gt; HSE.DHApp () acc (hsTyVarBndrToTyVarBind tv))
                (HSE.DHead () $ rdrNameToName $ unLoc tcdLName)
                hsq_explicit
            )
            Nothing
            ( map
                ( \con_name -&gt;
                    HSE.GadtDecl
                        ()
                        (rdrNameToName $ unLoc con_name)
                        Nothing
                        Nothing
                        (Just $ map (conDeclFieldToFieldDecl . unLoc) args)
                        ( maybe id (HSE.TyForall () Nothing . Just . hsTypesToContext . unLoc) con_mb_cxt $
                            maybe id (\bs -&gt; HSE.TyForall () (Just bs) Nothing) (hsOuterTyVarBndrsToFoo $ unLoc con_outer_bndrs) $
                                hsTypeToType $
                                    unLoc con_res_ty
                        )
                )
                (NE.toList con_names)
            )
            []
hsDeclToDecl (TyClD _ (FamDecl{tcdFam = FamilyDecl{fdLName, fdInfo = DataFamily, fdTyVars = HsQTvs{hsq_explicit}, fdResultSig}})) =
    Just $
        HSE.DataFamDecl
            ()
            Nothing
            ( foldl&apos;
                (\acc (L _ tv) -&gt; HSE.DHApp () acc (hsTyVarBndrToTyVarBind tv))
                (HSE.DHead () $ rdrNameToName $ unLoc fdLName)
                hsq_explicit
            )
            (familyResultSigToResultSig $ unLoc fdResultSig)
hsDeclToDecl (TyClD _ (FamDecl{tcdFam = FamilyDecl{fdLName, fdTyVars = HsQTvs{hsq_explicit}, fdResultSig, fdInjectivityAnn}})) =
    Just $
        HSE.TypeFamDecl
            ()
            ( foldl&apos;
                (\acc (L _ tv) -&gt; HSE.DHApp () acc (hsTyVarBndrToTyVarBind tv))
                (HSE.DHead () $ rdrNameToName $ unLoc fdLName)
                hsq_explicit
            )
            (familyResultSigToResultSig $ unLoc fdResultSig)
            (fmap (injectivityAnnToInjectivityInfo . unLoc) fdInjectivityAnn)
hsDeclToDecl (TyClD _ (GHC.Hs.ClassDecl{tcdCtxt, tcdLName, tcdTyVars = HsQTvs{hsq_explicit}, tcdFDs})) =
    Just $
        HSE.ClassDecl
            ()
            (fmap (hsTypesToContext . unLoc) tcdCtxt)
            ( foldl&apos;
                (\acc (L _ tv) -&gt; HSE.DHApp () acc (hsTyVarBndrToTyVarBind tv))
                (HSE.DHead () $ rdrNameToName $ unLoc tcdLName)
                hsq_explicit
            )
            (map (funDepToFunDep . unLoc) tcdFDs)
            Nothing
hsDeclToDecl (SigD _ (GHC.Hs.TypeSig _ names (HsWC{hswc_body = L _ HsSig{sig_body}}))) =
    Just $
        HSE.TypeSig
            ()
            (map (rdrNameToName . unLoc) names)
            (hsTypeToType $ unLoc sig_body)
hsDeclToDecl (SigD _ (GHC.Hs.PatSynSig _ names (L _ HsSig{sig_body}))) =
    Just $ case hsTypeToType (unLoc sig_body) of
        HSE.TyForall () Nothing (Just ctx1) (HSE.TyForall () Nothing (Just ctx2) ty) -&gt;
            HSE.PatSynSig
                ()
                (map (rdrNameToName . unLoc) names)
                Nothing
                (Just ctx1)
                Nothing
                (Just ctx2)
                ty
        HSE.TyForall () Nothing (Just ctx) ty -&gt;
            HSE.PatSynSig
                ()
                (map (rdrNameToName . unLoc) names)
                Nothing
                (Just ctx)
                Nothing
                Nothing
                ty
        ty -&gt;
            HSE.PatSynSig
                ()
                (map (rdrNameToName . unLoc) names)
                Nothing
                Nothing
                Nothing
                Nothing
                ty
hsDeclToDecl (SigD _ (FixSig _ (FixitySig _ names (MyFixity priority direction)))) =
    Just $
        HSE.InfixDecl
            ()
            (fixityDirectionToAssoc direction)
            (Just priority)
            (map (varOpOrConOp . rdrNameToName . unLoc) names)
hsDeclToDecl (InstD _ (ClsInstD{cid_inst = ClsInstDecl{cid_poly_ty = (L _ HsSig{sig_bndrs, sig_body})}})) =
    Just $ case hsTypeToType (unLoc sig_body) of
        HSE.TyForall () Nothing ctxt body -&gt;
            HSE.InstDecl
                ()
                Nothing
                (HSE.IRule () (hsOuterTyVarBndrsToFoo sig_bndrs) ctxt (typeToInstHead body))
                Nothing
        body -&gt;
            HSE.InstDecl
                ()
                Nothing
                (HSE.IRule () (hsOuterTyVarBndrsToFoo sig_bndrs) Nothing (typeToInstHead body))
                Nothing
hsDeclToDecl _ = Nothing

injectivityAnnToInjectivityInfo :: InjectivityAnn GhcPs -&gt; HSE.InjectivityInfo ()
injectivityAnnToInjectivityInfo = \case
    InjectivityAnn _ lhs rhs -&gt;
        HSE.InjectivityInfo () (rdrNameToName $ unLoc lhs) (map (rdrNameToName . unLoc) rhs)

#if MIN_VERSION_ghc_lib_parser(9,14,0)
conDeclFieldToFieldDecl :: HsConDeclRecField GhcPs -&gt; HSE.FieldDecl ()
conDeclFieldToFieldDecl = \case
    HsConDeclRecField{cdrf_names, cdrf_spec = CDF{cdf_type}} -&gt;
        HSE.FieldDecl
            ()
            (map (fieldOccToName . unLoc) cdrf_names)
            (hsTypeToType $ unLoc cdf_type)
#else
conDeclFieldToFieldDecl :: ConDeclField GhcPs -&gt; HSE.FieldDecl ()
conDeclFieldToFieldDecl = \case
    ConDeclField{cd_fld_names, cd_fld_type} -&gt;
        HSE.FieldDecl
            ()
            (map (fieldOccToName . unLoc) cd_fld_names)
            (hsTypeToType $ unLoc cd_fld_type)
#endif

fieldOccToName :: FieldOcc GhcPs -&gt; HSE.Name ()
fieldOccToName = \case
    FieldOcc{foLabel} -&gt; rdrNameToName $ unLoc foLabel

varOpOrConOp :: HSE.Name () -&gt; HSE.Op ()
varOpOrConOp name = case name of
    HSE.Symbol () (&apos;:&apos; : _) -&gt; HSE.ConOp () name
    HSE.Ident () (c : _)
        | isUpper c -&gt; HSE.ConOp () name
        | otherwise -&gt; HSE.VarOp () name
    _ -&gt; HSE.VarOp () name

familyResultSigToResultSig :: FamilyResultSig GhcPs -&gt; Maybe (HSE.ResultSig ())
familyResultSigToResultSig = \case
    NoSig{} -&gt; Nothing
    GHC.Hs.KindSig _ kind -&gt;
        Just $ HSE.KindSig () $ hsTypeToType $ unLoc kind
    GHC.Hs.TyVarSig _ tvb -&gt;
        Just $ HSE.TyVarSig () $ hsTyVarBndrToTyVarBind $ unLoc tvb

hsOuterTyVarBndrsToFoo :: HsOuterSigTyVarBndrs GhcPs -&gt; Maybe [HSE.TyVarBind ()]
hsOuterTyVarBndrsToFoo = \case
    HsOuterImplicit{} -&gt; Nothing
    HsOuterExplicit{hso_bndrs} -&gt; Just $ map (hsTyVarBndrToTyVarBind . unLoc) hso_bndrs

funDepToFunDep :: GHC.Hs.FunDep GhcPs -&gt; HSE.FunDep ()
funDepToFunDep = \case
    GHC.Hs.FunDep _ lhs rhs -&gt;
        HSE.FunDep () (map (rdrNameToName . unLoc) lhs) (map (rdrNameToName . unLoc) rhs)

fixityDirectionToAssoc :: FixityDirection -&gt; HSE.Assoc ()
fixityDirectionToAssoc = \case
    InfixL -&gt; HSE.AssocLeft ()
    InfixR -&gt; HSE.AssocRight ()
    InfixN -&gt; HSE.AssocNone ()

hsTyVarBndrToTyVarBind ::
    HsTyVarBndr a GhcPs -&gt;
    HSE.TyVarBind ()
#if MIN_VERSION_ghc_lib_parser(9,12,0)
hsTyVarBndrToTyVarBind = \case
    HsTvb _ _ (HsBndrVar _ (L _ var)) HsBndrNoKind{} -&gt;
        HSE.UnkindedVar () (rdrNameToName var)
    HsTvb _ _ (HsBndrVar _ (L _ var)) (HsBndrKind _ (L _ kind)) -&gt;
        HSE.KindedVar () (rdrNameToName var) (hsTypeToType kind)
    HsTvb _ _ (HsBndrWildCard _) _ -&gt;
        HSE.UnkindedVar () (HSE.Ident () &quot;_&quot;)
#else
hsTyVarBndrToTyVarBind = \case
    UserTyVar _ _ (L _ var) -&gt;
        HSE.UnkindedVar () (rdrNameToName var)
    KindedTyVar _ _ (L _ var) (L _ kind) -&gt;
        HSE.KindedVar () (rdrNameToName var) (hsTypeToType kind)
#endif

occNameToName :: OccName -&gt; HSE.Name ()
occNameToName occ = case occNameString occ of
    xs@(x : _)
        | not (isAlphaNum x) &amp;&amp; x /= &apos;(&apos; &amp;&amp; x /= &apos;_&apos; -&gt; HSE.Symbol () xs
    xs -&gt; HSE.Ident () xs

rdrNameToName :: RdrName -&gt; HSE.Name ()
rdrNameToName = occNameToName . rdrNameOcc

rdrNameToQName :: RdrName -&gt; HSE.QName ()
rdrNameToQName = \case
    Unqual occName -&gt;
        HSE.UnQual () $ occNameToName occName
    GHC.Types.Name.Reader.Qual modName occName -&gt;
        HSE.Qual
            ()
            (HSE.ModuleName () (moduleNameString modName))
            (occNameToName occName)
    Orig modul occName -&gt;
        HSE.Qual
            ()
            (HSE.ModuleName () (moduleNameString $ moduleName modul))
            (occNameToName occName)
    Exact name -&gt;
        HSE.UnQual () $ occNameToName (nameOccName name)

hsTypeToType :: HsType GhcPs -&gt; HSE.Type ()
hsTypeToType = \case
    HsListTy _ x -&gt;
        HSE.TyList () $ hsTypeToType $ unLoc x
    HsTyVar _ _ (L _ (Exact x))
        | show (runSDoc (ppr x) defaultSDocContext) == &quot;[]&quot; -&gt;
            HSE.TyCon () $ HSE.Special () $ HSE.ListCon ()
        | show (runSDoc (ppr x) defaultSDocContext) == &quot;-&gt;&quot; -&gt;
            HSE.TyCon () $ HSE.Special () $ HSE.FunCon ()
        | Just n &lt;- stripPrefix &quot;Tuple&quot; (occNameString (nameOccName x))
        , Just n&apos; &lt;- readMaybe n -&gt;
            HSE.TyCon () $ HSE.Special () $ HSE.TupleCon () HSE.Boxed n&apos;
    HsTyVar _ IsPromoted (L _ x) -&gt;
        HSE.TyPromoted () $ HSE.PromotedCon () True $ rdrNameToQName x
    HsTyVar _ NotPromoted (L _ x) -&gt;
        case rdrNameSpace x of
            ns
                | ns == tvName -&gt;
                    HSE.TyVar () $ rdrNameToName x
            _ -&gt; HSE.TyCon () $ rdrNameToQName x
    HsAppTy _ x y -&gt;
        HSE.TyApp () (hsTypeToType $ unLoc x) (hsTypeToType $ unLoc y)
    HsFunTy _ _ x y -&gt;
        HSE.TyFun () (hsTypeToType $ unLoc x) (hsTypeToType $ unLoc y)
    HsTupleTy _ HsBoxedOrConstraintTuple [] -&gt;
        HSE.TyCon () $ HSE.Special () $ HSE.UnitCon ()
    HsTupleTy _ HsUnboxedTuple [] -&gt;
        HSE.TyCon () $ HSE.Special () $ HSE.UnboxedSingleCon ()
    HsTupleTy _ boxed xs -&gt;
        HSE.TyTuple () (hsTupleSortToBoxed boxed) (map (hsTypeToType . unLoc) xs)
    HsStarTy _ _ -&gt;
        HSE.TyStar ()
#if !MIN_VERSION_ghc_lib_parser(9,14,0)
    HsBangTy _ (HsBang unpackedness strictness) x -&gt;
        applyTyBang
            (srcStrictnessToBangType strictness)
            (srcUnpackednessToUnpackedness unpackedness)
            (hsTypeToType $ unLoc x)
#endif
    HsParTy _ x -&gt; case hsTypeToType (unLoc x) of
        x&apos;@HSE.TyKind{} -&gt; x&apos;
        x&apos; -&gt; HSE.TyParen () x&apos;
    HsQualTy{hst_ctxt, hst_body} -&gt;
        applyTyForall Nothing (Just $ hsTypesToContext $ unLoc hst_ctxt) $
            hsTypeToType $
                unLoc hst_body
    HsForAllTy{hst_tele = HsForAllInvis{hsf_invis_bndrs}, hst_body} -&gt;
        applyTyForall
            (Just $ map (hsTyVarBndrToTyVarBind . unLoc) hsf_invis_bndrs)
            Nothing
            (hsTypeToType $ unLoc hst_body)
    -- TODO FIXME when migrating to ghc-lib-parser completely:
    -- HSE does not support forall with visible binders
    HsForAllTy{hst_tele = HsForAllVis{hsf_vis_bndrs}, hst_body} -&gt;
        applyTyForall
            (Just $ map (hsTyVarBndrToTyVarBind . unLoc) hsf_vis_bndrs)
            Nothing
            (hsTypeToType $ unLoc hst_body)
    HsExplicitListTy _ IsPromoted xs -&gt;
        HSE.TyPromoted () $ HSE.PromotedList () True (map (hsTypeToType . unLoc) xs)
    HsExplicitListTy _ NotPromoted [x] -&gt;
        HSE.TyList () $ hsTypeToType $ unLoc x
    HsExplicitListTy _ NotPromoted xs -&gt;
        HSE.TyPromoted () $ HSE.PromotedList () False (map (hsTypeToType . unLoc) xs)

#if MIN_VERSION_ghc_lib_parser(9,12,0)
    HsExplicitTupleTy _ IsPromoted [] -&gt;
        HSE.TyPromoted () $ HSE.PromotedCon () True $ HSE.Special () $ HSE.UnitCon ()
    HsExplicitTupleTy _ IsPromoted xs -&gt;
        HSE.TyPromoted () $ HSE.PromotedTuple () $ map (hsTypeToType . unLoc) xs
    HsExplicitTupleTy _ NotPromoted xs -&gt;
        HSE.TyTuple () HSE.Boxed (map (hsTypeToType . unLoc) xs)
#else
    HsExplicitTupleTy _ [] -&gt;
        HSE.TyPromoted () $ HSE.PromotedCon () True $ HSE.Special () $ HSE.UnitCon ()
    HsExplicitTupleTy _ xs -&gt;
        HSE.TyPromoted () $ HSE.PromotedTuple () $ map (hsTypeToType . unLoc) xs
#endif

    HsOpTy _ _ x (L _ (Unqual y)) z
        | occNameString y == &quot;~&quot; -&gt;
            HSE.TyEquals () (hsTypeToType $ unLoc x) (hsTypeToType $ unLoc z)
    HsOpTy _ promotion x (L _ (Exact y)) z
        | occNameString (nameOccName y) == &quot;:&quot; -&gt;
            HSE.TyInfix
                ()
                (hsTypeToType $ unLoc x)
                (promotionFlagToMaybePromotedName promotion $ HSE.Special () $ HSE.Cons ())
                (hsTypeToType $ unLoc z)
    HsOpTy _ promotion x y z -&gt;
        HSE.TyInfix
            ()
            (hsTypeToType $ unLoc x)
            (promotionFlagToMaybePromotedName promotion $ rdrNameToQName $ unLoc y)
            (hsTypeToType $ unLoc z)
    HsKindSig _ lhs rhs -&gt;
        HSE.TyKind () (hsTypeToType $ unLoc lhs) (hsTypeToType $ unLoc rhs)
    HsTyLit _ (HsNumTy (SourceText txt) val) -&gt;
        HSE.TyPromoted () $ HSE.PromotedInteger () val (unpackFSOrId txt)
    HsTyLit _ (HsStrTy (SourceText txt) val) -&gt;
        HSE.TyPromoted () $ HSE.PromotedString () (unpackFS val) (drop1 $ dropEnd1 $ unpackFSOrId txt)
    HsSumTy _ xs -&gt;
        HSE.TyUnboxedSum () $ map (hsTypeToType . unLoc) xs
    HsWildCardTy _ -&gt;
        HSE.TyWildCard () Nothing
    -- Everything else cannot be represented in HSE, so replacing with a wildcard
    _ -&gt; HSE.TyWildCard () Nothing

promotionFlagToMaybePromotedName ::
    PromotionFlag -&gt; HSE.QName () -&gt; HSE.MaybePromotedName ()
promotionFlagToMaybePromotedName = \case
    NotPromoted -&gt; HSE.UnpromotedName ()
    IsPromoted -&gt; HSE.PromotedName ()

applyTyForall ::
    Maybe [HSE.TyVarBind ()] -&gt; Maybe (HSE.Context ()) -&gt; HSE.Type () -&gt; HSE.Type ()
applyTyForall mArg1 mArg2 = \case
    HSE.TyForall () Nothing mArg2&apos; ty
        | isNothing mArg2 -&gt; HSE.TyForall () mArg1 mArg2&apos; ty
    ty -&gt; HSE.TyForall () mArg1 mArg2 ty

#if !MIN_VERSION_ghc_lib_parser(9,14,0)
applyTyBang ::
    HSE.BangType () -&gt; HSE.Unpackedness () -&gt; HSE.Type () -&gt; HSE.Type ()
applyTyBang bang unpack = \case
    HSE.TyBang () (HSE.NoStrictAnnot ()) unpack&apos; ty
        | unpack == HSE.NoUnpackPragma () -&gt; HSE.TyBang () bang unpack&apos; ty
    HSE.TyBang () bang&apos; (HSE.NoUnpackPragma ()) ty
        | bang == HSE.NoStrictAnnot () -&gt; HSE.TyBang () bang&apos; unpack ty
    HSE.TyApp () x y -&gt; HSE.TyApp () (applyTyBang bang unpack x) y
    ty -&gt; HSE.TyBang () bang unpack ty

srcStrictnessToBangType :: SrcStrictness -&gt; HSE.BangType ()
srcStrictnessToBangType = \case
    SrcLazy -&gt; HSE.LazyTy ()
    SrcStrict -&gt; HSE.BangedTy ()
    NoSrcStrict -&gt; HSE.NoStrictAnnot ()

srcUnpackednessToUnpackedness :: SrcUnpackedness -&gt; HSE.Unpackedness ()
srcUnpackednessToUnpackedness = \case
    SrcUnpack -&gt; HSE.Unpack ()
    SrcNoUnpack -&gt; HSE.NoUnpack ()
    NoSrcUnpack -&gt; HSE.NoUnpackPragma ()
#endif

typeToInstHead :: HSE.Type () -&gt; HSE.InstHead ()
typeToInstHead = \case
    HSE.TyApp () x y -&gt; HSE.IHApp () (typeToInstHead x) y
    HSE.TyCon () x -&gt; HSE.IHCon () x
    HSE.TyInfix () x (HSE.UnpromotedName () y) z -&gt; HSE.IHApp () (HSE.IHInfix () x y) z
    -- The rest happens only in ghc-prim, which are likely some magical forms.
    -- Let&apos;s skip them.
    _ -&gt; HSE.IHCon () $ HSE.Special () $ HSE.UnitCon ()

hsTypesToContext ::
    [GenLocated SrcSpanAnnA (HsType GhcPs)] -&gt;
    HSE.Context ()
hsTypesToContext = \case
    [] -&gt; HSE.CxEmpty ()
    [x] -&gt; HSE.CxSingle () $ hsTypeToAsst $ unLoc x
    xs -&gt; HSE.CxTuple () $ map (hsTypeToAsst . unLoc) xs

hsTypeToAsst :: HsType GhcPs -&gt; HSE.Asst ()
hsTypeToAsst = \case
    HsIParamTy _ name t -&gt;
        HSE.IParam () (hsIPNameToIPName $ unLoc name) (hsTypeToType $ unLoc t)
    HsParTy _ t -&gt;
        HSE.ParenA () $ hsTypeToAsst $ unLoc t
    t -&gt; case hsTypeToType t of
        HSE.TyParen () ty -&gt; HSE.ParenA () $ HSE.TypeA () ty
        ty -&gt; HSE.TypeA () ty

hsIPNameToIPName :: HsIPName -&gt; HSE.IPName ()
hsIPNameToIPName = HSE.IPDup () . unpackFS . hsIPNameFS

hsTupleSortToBoxed :: HsTupleSort -&gt; HSE.Boxed
hsTupleSortToBoxed = \case
    HsUnboxedTuple -&gt; HSE.Unboxed
    HsBoxedOrConstraintTuple -&gt; HSE.Boxed

runGhcLibParser ::
    String -&gt;
    GHC.Parser.Lexer.ParseResult (GenLocated SrcSpanAnnA (HsDecl GhcPs))
runGhcLibParser str
    | Just (str&apos;, &apos;;&apos;) &lt;- unsnoc str =
        runGhcLibParser str&apos;
runGhcLibParser str = case runGhcLibParserWithExtensions almostAllExtensions str of
    PFailed{}
        | &apos;#&apos; `elem` str -&gt; runGhcLibParserWithExtensions noUnboxed str
        | &apos;*&apos; `elem` str -&gt; runGhcLibParserWithExtensions noStarIsType str
        | &quot;pattern&quot; `isInfixOf` str -&gt; runGhcLibParserWithExtensions noPatternSynonyms str
    res -&gt; res

allExtensions :: EnumSet.EnumSet Extension
allExtensions = EnumSet.fromList enumerate

almostAllExtensions :: EnumSet.EnumSet Extension
almostAllExtensions =
    foldr
        EnumSet.delete
        allExtensions
        [ Arrows -- makes &quot;proc&quot; a keyword
        , RecursiveDo -- makes &quot;mdo&quot; and &quot;rec&quot; keywords
        , StaticPointers -- makes &quot;static&quot; a keyword
        , TransformListComp -- makes &quot;by&quot;, &quot;group&quot; and &quot;using&quot; keywords
        ]

noUnboxed :: EnumSet.EnumSet Extension
noUnboxed =
    foldr
        EnumSet.delete
        almostAllExtensions
        [ UnboxedSums
        , UnboxedTuples
        ]

noPatternSynonyms :: EnumSet.EnumSet Extension
noPatternSynonyms = EnumSet.delete PatternSynonyms almostAllExtensions

noStarIsType :: EnumSet.EnumSet Extension
noStarIsType = EnumSet.delete StarIsType almostAllExtensions

runGhcLibParserWithExtensions ::
    EnumSet.EnumSet Extension -&gt;
    String -&gt;
    GHC.Parser.Lexer.ParseResult (GenLocated SrcSpanAnnA (HsDecl GhcPs))
runGhcLibParserWithExtensions extensions str = unP parseDeclaration parseState
  where
#if MIN_VERSION_ghc_lib_parser(9,14,0)
    opts = mkParserOpts extensions emptyDiagOpts False False False False
#else
    opts = mkParserOpts extensions emptyDiagOpts [] False False False False
#endif
    dummyLocation = mkRealSrcLoc mempty 1 1
    buffer = stringToStringBuffer str
    parseState = initParserState opts buffer dummyLocation

#if !MIN_VERSION_ghc_lib_parser(9,8,0)
emptyDiagOpts :: DiagOpts
emptyDiagOpts = DiagOpts mempty mempty False False Nothing defaultSDocContext
#endif

#if MIN_VERSION_ghc_lib_parser(9,8,0)
unpackFSOrId = unpackFS
#else
unpackFSOrId = id
#endif</file><file path="src/Input/Reorder.hs">{-# LANGUAGE RecordWildCards, OverloadedStrings #-}

module Input.Reorder(reorderItems) where

import Input.Item
import Input.Settings
import Data.List.Extra
import Data.Tuple.Extra
import General.Util
import General.Str
import Distribution.Types.PackageName (mkPackageName, unPackageName)


pkgGhc :: PkgName
pkgGhc = mkPackageName &quot;ghc&quot;

packageOrderHacks :: (PkgName -&gt; Int) -&gt; PkgName -&gt; Int
-- &apos;ghc&apos; is the canonical module that both &apos;ghc-lib-parser&apos; and &apos;ghc-lib&apos; copy from, so better to pick that
-- even though ghc-lib-* are used more on Stackage (but a lot less on Hackage)
packageOrderHacks f x | x == pkgGhc = min (f x) $ min (f $ mkPackageName &quot;ghc-lib-parser&quot;) (f $ mkPackageName &quot;ghc-lib&quot;) - 1
packageOrderHacks f x = f x


-- | Reorder items so the most popular ones are first, using reverse dependencies.
--   Low numbers for the PkgName function mean the package is more popular.
reorderItems :: Settings -&gt; (PkgName -&gt; Int) -&gt; [(a, Item)] -&gt; [(a, Item)]
reorderItems Settings{..} packageOrder xs =
    concatMap snd $ sortOn ((packageOrderHacks packageOrder &amp;&amp;&amp; id) . fst) $ map rebase $ splitIPackage xs
    where
        refunc = map $ second $ \(x:xs) -&gt; x : sortOn (itemName . snd) xs
        rebase (x, xs) = (x, concatMap snd $ sortOn (((negate . f . strUnpack) &amp;&amp;&amp; id) . fst) $ refunc $ splitIModule xs)
            where f = reorderModule (unPackageName x)</file><file path="src/Input/Set.hs">{-# LANGUAGE PatternGuards, TupleSections #-}

module Input.Set(setStackage, setPlatform, setGHC) where

import Control.Applicative
import Data.List.Extra
import System.IO.Extra
import qualified Data.Set as Set
import Prelude


-- | Return information about which items are in a particular set.
setStackage :: FilePath -&gt; IO (Set.Set String)
setStackage file = Set.fromList . filter (`notElem` stackOverflow) . f . lines &lt;$&gt; readFile&apos; file
    where
        stackOverflow = [] -- [&quot;telegram-api&quot;,&quot;pinchot&quot;,&quot;gogol-dfareporting&quot;] -- see https://github.com/ndmitchell/hoogle/issues/167

        f (x:xs) | Just x &lt;- stripPrefix &quot;constraints:&quot; x =
                    map (fst . word1) $ takeWhile (&quot; &quot; `isPrefixOf`) $ (&apos; &apos;:x) : xs
                 | otherwise = f xs
        f [] = []


setPlatform :: FilePath -&gt; IO (Set.Set String)
setPlatform file = setPlatformWith file [&quot;incGHCLib&quot;,&quot;incLib&quot;]

setPlatformWith :: FilePath -&gt; [String] -&gt; IO (Set.Set String)
setPlatformWith file names = do
    src &lt;- lines &lt;$&gt; readFile&apos; file
    pure $ Set.delete &quot;bin-package-db&quot; $
        Set.fromList [read lib | &quot;,&quot;:name:lib:_ &lt;- map words src, name `elem` names]

setGHC :: FilePath -&gt; IO (Set.Set String)
setGHC file = setPlatformWith file [&quot;incGHCLib&quot;]</file><file path="src/Input/Settings.hs">{-# LANGUAGE PackageImports, RecordWildCards, PatternGuards, TemplateHaskell, CPP #-}


-- | Module for reading settings files.
module Input.Settings(
    Settings(..), loadSettings
    ) where

import Control.Exception (catch, throwIO)
import Data.List.Extra
import Data.Maybe
import &quot;template-haskell&quot; Language.Haskell.TH.Syntax (lift, runIO)
import System.FilePath
import System.IO.Error (isDoesNotExistError)
import System.IO.Extra
import qualified Data.Map.Strict as Map
import Paths_hoogle


-- | Settings values. Later settings always override earlier settings.
data Setting
    = -- | Given a Cabal tag/author rename it from the LHS to the RHS.
      --   If the RHS is blank, delete the tag.
      RenameTag String String
    | -- | Change the priority of a module. Given package name, module name, new priority.
      --   Use * for wildcard matches. All un-reordered modules are 0
      ReorderModule String String Int
    deriving Read


data Settings = Settings
    {renameTag :: String -&gt; String -- ^ Rename a cabal tag
    ,reorderModule :: String -&gt; String -&gt; Int
    }


readFileSettings :: FilePath -&gt; String -&gt; IO [Setting]
readFileSettings file backup = do
    src &lt;- readFileUTF8 file `catch` \e -&gt;
        if isDoesNotExistError e
            then pure backup
            else throwIO e
    pure $ concat $ zipWithFrom f 1 $ map trim $ lines src
    where
        f i s | null s = []
              | &quot;--&quot; `isPrefixOf` s = []
              | [(x,&quot;&quot;)] &lt;- reads s = [x]
              | otherwise = error $ file ++ &quot;:&quot; ++ show i ++ &quot;: Failure to parse, got: &quot; ++ s



-- | Fix bad names in the Cabal file.
loadSettings :: IO Settings
loadSettings = do
    dataDir &lt;- getDataDir
#ifdef PROFILE
    -- profiling and TemplateHaskell don&apos;t play well
    let backup = &quot;&quot;
#else
    let backup = $(runIO (readFileUTF8 &quot;misc/settings.txt&quot;) &gt;&gt;= lift)
#endif
    src &lt;- readFileSettings (dataDir &lt;/&gt; &quot;misc/settings.txt&quot;) backup
    pure $ createSettings src

createSettings :: [Setting] -&gt; Settings
createSettings xs = Settings{..}
    where
        renameTag = \x -&gt; fromMaybe x $ f x
            where f = literals [(a,b) | RenameTag a b &lt;- xs]

        reorderModule = \pkg -&gt; case f pkg of
                                    [] -&gt; const 0
                                    xs -&gt; let f = wildcards xs
                                          in \mod -&gt; lastDef 0 (f mod)
            where f = wildcards [(a,(b,c)) | ReorderModule a b c &lt;- xs]


---------------------------------------------------------------------
-- SPECIAL LOOKUPS

literals :: [(String, a)] -&gt; String -&gt; Maybe a
literals xs = \x -&gt; Map.lookup x mp
    where mp = Map.fromList xs

wildcards :: [(String, a)] -&gt; String -&gt; [a]
wildcards xs x = [b | (a,b) &lt;- xs, matchWildcard a x]

matchWildcard :: String -&gt; String -&gt; Bool
matchWildcard [&apos;*&apos;] ys = True -- special common case
matchWildcard (&apos;*&apos;:xs) ys = any (matchWildcard xs) $ tails ys
matchWildcard (x:xs) (y:ys) = x == y &amp;&amp; matchWildcard xs ys
matchWildcard [] [] = True
matchWildcard _ _ = False</file><file path="src/Output/Items.hs">{-# LANGUAGE TupleSections, RecordWildCards, ScopedTypeVariables, PatternGuards, DeriveDataTypeable, GADTs #-}

module Output.Items(writeItems, lookupItem, listItems) where

import Control.Monad
import Data.List.Extra
import qualified Data.ByteString as BS
import qualified Data.ByteString.Lazy.Char8 as LBS
import qualified Data.ByteString.Lazy.UTF8 as UTF8
import qualified Codec.Compression.GZip as GZip
import General.Str

import Input.Item
import General.Util
import General.Store
import General.Conduit


data Items a where Items :: Items BS.ByteString deriving Typeable


outputItem :: Target -&gt; [String]
outputItem Target{..} =
    [if null targetURL then &quot;.&quot; else targetURL
    ,maybe &quot;.&quot; (joinPair &quot; &quot;) targetPackage
    ,maybe &quot;.&quot; (joinPair &quot; &quot;) targetModule
    ,if null targetType then &quot;.&quot; else targetType
    ,targetItem] ++
    replace [&quot;&quot;] [&quot;.&quot;] (lines targetDocs)

inputItem :: [String] -&gt; Target
inputItem (url:pkg:modu:typ:self:docs) = targetExpandURL $
    Target (if url == &quot;.&quot; then &quot;&quot; else url) (f pkg) (f modu) (if typ == &quot;.&quot; then &quot;&quot; else typ) self (unlines $ replace [&quot;.&quot;] [&quot;&quot;] docs)
    where
        f &quot;.&quot; = Nothing
        f x = Just $ word1 x

-- write all the URLs, docs and enough info to pretty print it to a result
-- and replace each with an identifier (index in the space) - big reduction in memory
writeItems :: StoreWrite -&gt; (ConduitM (Maybe Target, item) (Maybe TargetId, item) IO () -&gt; IO a) -&gt; IO a
writeItems store act = act $ do
    void $ (\f -&gt; mapAccumMC f 0) $ \pos (target, item) -&gt; case target of
        Nothing -&gt; pure (pos, (Nothing, item))
        Just target -&gt; do
            let bs = LBS.toStrict $ GZip.compress $ lbstrPack $ unlines $ outputItem target
            liftIO $ do
                storeWritePart store Items $ intToBS $ BS.length bs
                storeWritePart store Items bs
            let pos2 = pos + fromIntegral (intSize + BS.length bs)
            pure (pos2, (Just $ TargetId pos, item))


listItems :: StoreRead -&gt; [Target]
listItems store = unfoldr f $ storeRead store Items
    where
        f x | BS.null x = Nothing
            | (n,x) &lt;- BS.splitAt intSize x
            , n &lt;- intFromBS n
            , (this,x) &lt;- BS.splitAt n x
            = Just (inputItem $ lines $ UTF8.toString $ GZip.decompress $ LBS.fromChunks [this], x)


lookupItem :: StoreRead -&gt; (TargetId -&gt; Target)
lookupItem store =
    let x = storeRead store Items
    in \(TargetId i) -&gt;
        let i2 = fromIntegral i
            n = intFromBS $ BS.take intSize $ BS.drop i2 x
        in inputItem $ lines $ UTF8.toString $ GZip.decompress $ LBS.fromChunks $ pure $ BS.take n $ BS.drop (i2 + intSize) x</file><file path="src/Output/Names.hs">{-# LANGUAGE ViewPatterns, TupleSections, ScopedTypeVariables, DeriveDataTypeable, ForeignFunctionInterface, GADTs #-}

module Output.Names(writeNames, searchNames) where

import Data.List.Extra
import qualified Data.ByteString.Char8 as BS
import qualified Data.ByteString.Unsafe as BS
import qualified Data.Vector.Storable as V
import General.Str
import Foreign.Ptr
import Foreign.Marshal
import Foreign.C.String
import Foreign.C.Types
import Control.Exception
import System.IO.Unsafe
import Data.Maybe

import Input.Item
import General.Util
import General.Store

foreign import ccall text_search_bound :: CString -&gt; IO CInt

foreign import ccall text_search :: CString -&gt; Ptr CString -&gt; CInt -&gt; Ptr CInt -&gt; IO CInt


data NamesSize a where NamesSize :: NamesSize Int deriving Typeable
data NamesItems a where NamesItems :: NamesItems (V.Vector TargetId) deriving Typeable
data NamesText a where NamesText :: NamesText BS.ByteString deriving Typeable

writeNames :: StoreWrite -&gt; [(Maybe TargetId, Item)] -&gt; IO ()
writeNames store xs = do
    let (ids, strs) = unzip [(i, [&apos; &apos; | isUpper1 name] ++ lower name) | (Just i, x) &lt;- xs, name &lt;- itemNamePart x]
    let b = bstr0Join $ strs ++ [&quot;&quot;,&quot;&quot;]
    bound &lt;- BS.unsafeUseAsCString b $ \ptr -&gt; text_search_bound ptr
    storeWrite store NamesSize $ fromIntegral bound
    storeWrite store NamesItems $ V.fromList ids
    storeWrite store NamesText b

itemNamePart :: Item -&gt; [String]
itemNamePart (IModule x) = [last $ splitOn &quot;.&quot; $ strUnpack x]
itemNamePart x = maybeToList $ strUnpack &lt;$&gt; itemName x

searchNames :: StoreRead -&gt; Bool -&gt; [String] -&gt; [TargetId]
-- very important to not search for [&quot; &quot;] or [] since the output buffer is too small
searchNames store exact (filter (/= &quot;&quot;) . map trim -&gt; xs) = unsafePerformIO $ do
    let vs = storeRead store NamesItems
    -- if there are no questions, we will match everything, which exceeds the result buffer
    if null xs then pure $ V.toList vs else do
        let tweak x = bstrPack $ [&apos; &apos; | isUpper1 x] ++ lower x ++ &quot;\0&quot;
        bracket (mallocArray $ storeRead store NamesSize) free $ \result -&gt;
            BS.unsafeUseAsCString (storeRead store NamesText) $ \haystack -&gt;
                withs (map (BS.unsafeUseAsCString . tweak) xs) $ \needles -&gt;
                    withArray0 nullPtr needles $ \needles -&gt; do
                        found &lt;- c_text_search haystack needles (if exact then 1 else 0) result
                        xs &lt;- peekArray (fromIntegral found) result
                        pure $ map ((vs V.!) . fromIntegral) xs

{-# NOINLINE c_text_search #-} -- for profiling
c_text_search a b c d = text_search a b c d</file><file path="src/Output/Tags.hs">{-# LANGUAGE ViewPatterns, TupleSections, ScopedTypeVariables, DeriveDataTypeable, PatternGuards, GADTs #-}

module Output.Tags(writeTags, completionTags, applyTags) where

import Data.Bifunctor
import Data.Function
import Data.List.Extra
import Data.Tuple.Extra
import Data.Maybe
import Foreign.Storable.Tuple()
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Data.Vector.Storable as V
import qualified Data.ByteString.Char8 as BS

import Input.Item
import Query
import General.Util
import General.Store
import General.Str
import Distribution.Types.PackageName (unPackageName, mkPackageName)

---------------------------------------------------------------------
-- DATA TYPE

-- matches (a,b) if i &gt;= a &amp;&amp; i &lt;= b

data Packages a where Packages :: Packages (BStr0, V.Vector (TargetId, TargetId)) deriving Typeable
    -- list of packages, sorted by popularity, lowercase, interspersed with \0
    -- for each index in PackageNames, the first is the module item, any in the bounds are in that package

data Modules a where Modules :: Modules (BStr0, V.Vector (TargetId, TargetId)) deriving Typeable
    -- list of modules, sorted by popularity, not unique, lowercase, interspersed with \0
    -- for each index in ModuleNames, the first is the module item, any in the bounds are in that module

data Categories a where Categories :: Categories (BStr0, Jagged (TargetId, TargetId)) deriving Typeable
    -- list of categories, sorted by name, interspersed with \0
    -- for each index in CategoryNames, a range of items containing a category, first item is a package

data Completions a where Completions :: Completions BStr0 deriving Typeable
    -- a list of things to complete to, interspersed with \0


writeTags :: StoreWrite -&gt; (PkgName -&gt; Bool) -&gt; (PkgName -&gt; [(String,String)]) -&gt; [(Maybe TargetId, Item)] -&gt; IO ()
writeTags store keep extra xs = do
    let splitPkg = splitIPackage xs
    let packages = addRange (== mkPackageName &quot;&quot;) splitPkg
    storeWrite store Packages (bstr0Join $ map (unPackageName . fst) packages, V.fromList $ map snd packages)

    let categories = map (bimap snd reverse) $ Map.toList $ Map.fromListWith (++)
            [(((weightTag ex, both lower ex), joinPair &quot;:&quot; ex),[rng]) | (p,rng) &lt;- packages, ex &lt;- extra p]
    storeWrite store Categories (bstr0Join $ map fst categories, jaggedFromList $ map snd categories)

    let modules = addRange strNull $ concatMap (splitIModule . snd) splitPkg
    storeWrite store Modules (bstr0Join $ map (lower . strUnpack . fst) modules, V.fromList $ map snd modules)

    storeWrite store Completions $ bstr0Join $
        takeWhile (&quot;set:&quot; `isPrefixOf`) (map fst categories) ++
        map (&quot;package:&quot;++) (sortOn lower $ map unPackageName $ nubOrd $ filter keep $ map fst packages) ++
        map (joinPair &quot;:&quot;) (sortOn (weightTag &amp;&amp;&amp; both lower) $ nubOrd [ex | (p,_) &lt;- packages, keep p, ex &lt;- extra p, fst ex /= &quot;set&quot;])
    where
        addRange :: (str -&gt; Bool) -&gt; [(str, [(Maybe TargetId,a)])] -&gt; [(str, (TargetId, TargetId))]
        addRange isNull xs = [(a, (minimum&apos; is, maximum&apos; is)) | (a,b) &lt;- xs, let is = mapMaybe fst b, not (isNull a), is /= []]

        weightTag (&quot;set&quot;,x) = fromMaybe 0.9 $ lookup x [(&quot;stackage&quot;,0.0),(&quot;haskell-platform&quot;,0.1)]
        weightTag (&quot;package&quot;,x) = 1
        weightTag (&quot;category&quot;,x) = 2
        weightTag (&quot;license&quot;,x) = 3
        weightTag _ = 4


---------------------------------------------------------------------
-- SIMPLE SELECTORS

completionTags :: StoreRead -&gt; [String]
completionTags store = map BS.unpack $ bstr0Split $ storeRead store Completions


---------------------------------------------------------------------
-- DATA TYPE, PARSE, PRINT

data Tag = IsExact | IsPackage | IsModule | EqPackage String | EqModule String | EqCategory String String deriving Eq

parseTag :: String -&gt; String -&gt; Maybe Tag
parseTag k v
    | k ~~ &quot;is&quot; = case () of
        _ | v ~~ &quot;exact&quot; -&gt; Just IsExact
          | v ~~ &quot;package&quot; -&gt; Just IsPackage
          | v ~~ &quot;module&quot; -&gt; Just IsModule
          | otherwise -&gt; Nothing
    | k ~~ &quot;package&quot; = if v == &quot;&quot; then Nothing else Just $ EqPackage v
    | k ~~ &quot;module&quot; = if v == &quot;&quot; then Nothing else Just $ EqModule v
    | v /= &quot;&quot; = Just $ EqCategory k v
    | otherwise = Nothing
    where
        -- make the assumption the first letter always disambiguates
        x ~~ lit = x /= &quot;&quot; &amp;&amp; lower x `isPrefixOf` lit

showTag :: Tag -&gt; (String, String)
showTag IsExact = (&quot;is&quot;,&quot;exact&quot;)
showTag IsPackage = (&quot;is&quot;,&quot;package&quot;)
showTag IsModule = (&quot;is&quot;,&quot;module&quot;)
showTag (EqPackage x) = (&quot;package&quot;,x)
showTag (EqModule x) = (&quot;module&quot;,x)
showTag (EqCategory k v) = (k,v)


---------------------------------------------------------------------
-- TAG SEMANTICS

-- | Given a tag, find the ranges of identifiers it covers (if it restricts the range)
-- An empty range means an empty result, while a Nothing means a search on the entire range
resolveTag :: StoreRead -&gt; Tag -&gt; (Tag, Maybe [(TargetId,TargetId)])
resolveTag store x = case x of
    IsExact -&gt; (IsExact, Nothing)
    IsPackage -&gt; (IsPackage, Just $ map (dupe . fst) $ V.toList packageIds)
    IsModule -&gt; (IsModule, Just $ map (dupe . fst) $ V.toList moduleIds)
    EqPackage orig@(BS.pack -&gt; val)
        -- look for people who are an exact prefix, sort by remaining length, if there are ties, pick the first one
        | res@(_:_) &lt;- [(BS.length x, (i,x)) | (i,x) &lt;- zipFrom 0 $ bstr0Split packageNames, val `BS.isPrefixOf` x]
            -&gt; let (i,x) = snd $ minimumBy (compare `on` fst) res in (EqPackage $ BS.unpack x, Just [packageIds V.! i])
        | otherwise -&gt; (EqPackage orig , Just [])
    EqModule x -&gt; (EqModule x, Just $ map (moduleIds V.!) $ findIndices (eqModule $ lower x) $ bstr0Split moduleNames)
    EqCategory cat val -&gt; (EqCategory cat val, Just $ concat
        [ V.toList $ jaggedAsk categoryIds i
        | i &lt;- elemIndices (BS.pack (cat ++ &quot;:&quot; ++ val)) $ bstr0Split categoryNames])
    where
        eqModule x | Just x &lt;- stripPrefix &quot;.&quot; x, Just x &lt;- stripSuffix &quot;.&quot; x = (==) (BS.pack x)
                   | Just x &lt;- stripPrefix &quot;.&quot; x = BS.isPrefixOf $ BS.pack x
                   | otherwise = let y = BS.pack x; y2 = BS.pack (&apos;.&apos;:x)
                                 in \v -&gt; y `BS.isPrefixOf` v || y2 `BS.isInfixOf` v

        (packageNames, packageIds) = storeRead store Packages
        (categoryNames, categoryIds) = storeRead store Categories
        (moduleNames, moduleIds) = storeRead store Modules


---------------------------------------------------------------------
-- TAG QUERIES

-- | Given a query produce: (refined query, is:exact, filter, enumeration)
--   You should apply the filter to other peoples results, or if you have nothing else, use the enumeration.
applyTags :: StoreRead -&gt; [Query] -&gt; ([Query], Bool, TargetId -&gt; Bool, [TargetId])
applyTags store qs = (qs2, exact, filt, searchTags store qs)
    where (qs2, exact, filt) = filterTags store qs

filterTags :: StoreRead -&gt; [Query] -&gt; ([Query], Bool, TargetId -&gt; Bool)
filterTags ts qs = (map redo qs, exact, \i -&gt; all ($ i) fs)
    where fs = map (filterTags2 ts . snd) $ groupSort $ map (scopeCategory &amp;&amp;&amp; id) $ filter isQueryScope qs
          exact = Just IsExact `elem` [parseTag a b | QueryScope True a b &lt;- qs]
          redo (QueryScope sense cat val)
              | Just (k,v) &lt;- fmap (showTag . fst . resolveTag ts) $ parseTag cat val = QueryScope sense k v
              | otherwise = QueryNone $ [&apos;-&apos; | not sense] ++ cat ++ &quot;:&quot; ++ val
          redo q = q


filterTags2 ts qs = \i -&gt; not (negq i) &amp;&amp; (noPosRestrict || posq i)
    where (posq,negq) = both inRanges (pos,neg)
          (pos, neg) = both (concatMap snd) $ partition fst xs
          xs = catMaybes restrictions
          noPosRestrict = all pred restrictions
          restrictions = map getRestriction qs
          pred Nothing = True
          pred (Just (sense, _)) = not sense
          getRestriction :: Query -&gt; Maybe (Bool,[(TargetId, TargetId)])
          getRestriction (QueryScope sense cat val) = do
            tag &lt;- parseTag cat val
            ranges &lt;- snd $ resolveTag ts tag
            pure (sense, ranges)


-- | Given a search which has no type or string in it, run the query on the tag bits.
--   Using for things like IsModule, EqCategory etc.
searchTags :: StoreRead -&gt; [Query] -&gt; [TargetId]
searchTags ts qs
    | x:xs &lt;- [map fst $ maybe [] (fromMaybe [] . snd . resolveTag ts) $ parseTag cat val | QueryScope True cat val &lt;- qs]
    = if null xs then x else filter (`Set.member` foldl1&apos; Set.intersection (map Set.fromList xs)) x
searchTags ts _ = maybe [] (map fst) $ snd $ resolveTag ts IsPackage</file><file path="src/Output/Types.hs">{-# LANGUAGE BangPatterns, DeriveDataTypeable, DeriveFunctor, GADTs,
             GeneralizedNewtypeDeriving, LambdaCase, RecordWildCards,
             ScopedTypeVariables, TupleSections, ViewPatterns #-}

module Output.Types(writeTypes, searchTypes, searchFingerprintsDebug) where

{-
Approach:
Each signature is stored, along with a fingerprint
A quick search finds the most promising 100 fingerprints
A slow search ranks the 100 items, excluding some
-}

import Control.Applicative
import Control.Monad.Extra
import Control.Monad.ST
import Control.Monad.Trans.Class
import Control.Monad.Trans.State.Strict
import Data.Binary hiding (get, put)
import qualified Data.ByteString.Char8 as BS
import Data.Data
import Data.Generics.Uniplate.Data
import Data.List.Extra
import qualified Data.Map.Strict as Map
import Data.Maybe
import qualified Data.Set as Set
import Data.STRef
import Data.Tuple.Extra
import qualified Data.Vector.Storable as V
import qualified Data.Vector.Storable.Mutable as VM
import Foreign.Storable
import Numeric.Extra
import Prelude
import System.FilePath
import System.IO.Extra
import Safe

import General.IString
import General.Store
import General.Str
import General.Util
import Input.Item


writeTypes :: StoreWrite -&gt; Maybe FilePath -&gt; [(Maybe TargetId, Item)] -&gt; IO ()
writeTypes store debug xs = do
    let debugger ext body = whenJust debug $ \file -&gt; writeFileUTF8 (file &lt;.&gt; ext) body
    inst &lt;- pure $ Map.fromListWith (+) [(fromIString x,1) | (_, IInstance (Sig _ [TCon x _])) &lt;- xs]
    xs &lt;- writeDuplicates store [(i, fromIString &lt;$&gt; t) | (Just i, ISignature t) &lt;- xs]
    names &lt;- writeNames store debugger inst xs
    xs &lt;- pure $ map (lookupNames names (error &quot;Unknown name in writeTypes&quot;)) xs
    writeFingerprints store xs
    writeSignatures store xs

searchTypes :: StoreRead -&gt; Sig String -&gt; [TargetId]
searchTypes store q =
    take nMatches (concat [ search fps qry&apos; | variantClass &lt;- variants
                                            , fpSig &lt;- case headErr variantClass qry of
                                                          (f:_) -&gt; [f]
                                                          []    -&gt; []
                                            , let fps = bestByFingerprint db nMatches fpSig
                                            , variant &lt;- variantClass
                                            , qry&apos; &lt;- variant qry
                                            ])
    where
        nMatches = 100
        qry = lookupNames names name0 (strPack &lt;$&gt; q) -- map unknown fields to name0, i.e. _
        names = readNames store
        search fps sig = concatMap (expandDuplicates $ readDuplicates store)
                         $ searchTypeMatch fps getSig arrow nMatches sig
        db  = zip (readSignatureIndex store)
                  (V.toList $ storeRead store TypesFingerprints :: [Fingerprint])
        getSig = readSignatureAt store
        arrow = lookupCtor store names &quot;-&gt;&quot;

        -- Different variations on the search query. Each variation is run in turn until we&apos;ve gathered
        -- 100 hits or run out of variations to try.
        -- As an optimization, these are grouped by variants that have the same fingerprint, saving
        -- redundant scans through the fingerprint data.
        variants = [ [ pure, permuted ],
                     [ partial, partial &gt;=&gt; permuted ] ]

        -- Permute the arguments of a two-argument query.
        permuted qq = case sigTy qq of
            [a1, a2, r] -&gt; [ qq { sigTy = [a2, a1, r] } ]
            _           -&gt; []

        -- Add a `Maybe` to the query&apos;s result type.
        partial  qq = case sigTy qq of
            []  -&gt; []
            tys -&gt; [ qq { sigTy = init tys ++ [TCon maybeCtor [last tys]] } ]

        maybeCtor = lookupCtor store names &quot;Maybe&quot;

lookupCtor :: StoreRead -&gt; Names -&gt; String -&gt; Name
lookupCtor store names c =
    case sigTy (lookupNames names name0 s) of
        [TCon n _] -&gt; n
        _          -&gt; name0
    where
      s = strPack &lt;$&gt; Sig { sigCtx = [], sigTy = [TCon c []] }

searchFingerprintsDebug :: StoreRead -&gt; (String, Sig String) -&gt; [(String, Sig String)] -&gt; [String]
searchFingerprintsDebug store query answers = intercalate [&quot;&quot;] $
    f False &quot;Query&quot; query : zipWithFrom (\i -&gt; f True (&quot;Answer &quot; ++ show i)) 1 answers
    where
        qsig = lookupNames names name0 $ strPack &lt;$&gt; snd query
        names = readNames store

        f match name (raw, sig) =
            [name ++ &quot;: &quot; ++ raw
            ,&quot;Sig String: &quot; ++ prettySig sig
            ,&quot;Sig Name: &quot; ++ prettySig (fmap prettyName sn)
            ,&quot;Fingerprint: &quot; ++ prettyFingerprint fp] ++
            if not match then [] else
            [&quot;Cost: &quot; ++ maybe &quot;X, no match&quot; show (matchFingerprint qsig fp)
            ,&quot;Explain: &quot; ++ showExplain (matchFingerprintDebug qsig fp)]
            where
                sn = lookupNames names name0 $ strPack &lt;$&gt; sig
                fp = toFingerprint sn

                showExplain = intercalate &quot;, &quot; . map g . sortOn (either (const minBound) (negate . snd))
                g (Left s) = &quot;X &quot; ++ s
                g (Right (s, x)) = show x ++ &quot; &quot; ++ s


---------------------------------------------------------------------
-- NAME/CTOR INFORMATION

data TypesNames a where TypesNames :: TypesNames (BStr0, V.Vector Name) deriving Typeable

-- At around 7000 packages, Word16 becomes insufficient
-- because there are more than 2^16 Names, so we use Word32.
type NameWord = Word32

-- Must be a unique Name per String.
-- First 0-99 are variables, rest are constructors.
-- More popular type constructors have higher numbers.
-- There are currently about 14K names, so about 25% of the bit patterns are taken
newtype Name = Name NameWord deriving (Eq,Ord,Show,Data,Typeable,Storable,Binary)

name0 = Name 0 -- use to represent _

isCon, isVar :: Name -&gt; Bool
isVar (Name x) = x &lt; 100
isCon = not . isVar

prettyName :: Name -&gt; String
prettyName x@(Name i)
    | x == name0 = &quot;_&quot;
    | isVar x = &quot;v&quot; ++ show i
    | otherwise = &quot;C&quot; ++ show i


-- | Give a name a popularity, where 0 is least popular, 1 is most popular
popularityName :: Name -&gt; Double
popularityName (Name n) | isVar $ Name n = error &quot;Can&apos;t call popularityName on a Var&quot;
                        | otherwise = fromIntegral (n - 100) / fromIntegral (maxBound - 100 :: NameWord)

newtype Names = Names {lookupName :: Str -&gt; Maybe Name}

lookupNames :: Names -&gt; Name -&gt; Sig Str -&gt; Sig Name
lookupNames Names{..} def (Sig ctx typ) = Sig (map f ctx) (map g typ)
    where
        vars = nubOrd $ strPack &quot;_&quot; : [x | Ctx _ x &lt;- ctx] ++ [x | TVar x _ &lt;- universeBi typ]
        var x = Name $ min 99 $ fromIntegral $ fromMaybe (error &quot;lookupNames&quot;) $ elemIndex x vars
        con = fromMaybe def . lookupName

        f (Ctx a b) = Ctx (con $ strCons &apos;~&apos; a) (var b)
        g (TCon x xs) = TCon (con x) $ map g xs
        g (TVar x xs) = TVar (var x) $ map g xs


writeNames :: StoreWrite -&gt; (String -&gt; String -&gt; IO ()) -&gt; Map.Map Str Int -&gt; [Sig Str] -&gt; IO Names
writeNames store debug inst xs = do
    let sigNames (Sig ctx typ) = nubOrd [strCons &apos;~&apos; x | Ctx x _ &lt;- ctx] ++ nubOrd [x | TCon x _ &lt;- universeBi typ]

    -- want to rank highly instances that have a lot of types, and a lot of definitions
    -- eg Eq is used and defined a lot. Constructor is used in 3 places but defined a lot.
    let freq :: Map.Map Str Int = -- how many times each identifier occurs
            Map.unionWith (\typ sig -&gt; sig + min sig typ) (Map.mapKeysMonotonic (strCons &apos;~&apos;) inst) $
            Map.fromListWith (+) $ map (,1::Int) $ concatMap sigNames xs
    let names = spreadNames $ Map.toList freq
    debug &quot;names&quot; $ unlines [strUnpack s ++ &quot; = &quot; ++ show n ++ &quot; (&quot; ++ show (freq Map.! s) ++ &quot; uses)&quot; | (s,n) &lt;- names]
    names &lt;- pure $ sortOn fst names
    storeWrite store TypesNames (bstr0Join $ map (strUnpack . fst) names, V.fromList $ map snd names)
    let mp2 = Map.fromAscList names
    pure $ Names $ \x -&gt; Map.lookup x mp2


-- | Given a list of names, spread them out uniquely over the range [Name 100 .. Name maxBound]
--   Aim for something with a count of p to be at position (p / pmax) linear interp over the range
spreadNames :: [(a, Int)] -&gt; [(a, Name)]
spreadNames [] = []
spreadNames (sortOn (negate . snd) -&gt; xs@((_,limit):_)) = check $ f (99 + fromIntegral (length xs)) maxBound xs
    where
        check xs | all (isCon . snd) xs &amp;&amp; length (nubOrd $ map snd xs) == length xs = xs
                 | otherwise = error $ &quot;Invalid spreadNames, length=&quot; ++ show (length xs)

        -- I can only assign values between mn and mx inclusive
        f :: NameWord -&gt; NameWord -&gt; [(a, Int)] -&gt; [(a, Name)]
        f !mn !mx [] = []
        f mn mx ((a,i):xs) = (a, Name real) : f (mn-1) (real-1) xs
            where real = fromIntegral $ max mn $ min mx ideal
                  ideal = mn + floor (fromIntegral (min commonNameThreshold i) * fromIntegral (mx - mn) / fromIntegral (min commonNameThreshold limit))

-- WARNING: Magic constant.
-- Beyond this count names don&apos;t accumulate extra points for being common.
-- Ensures that things like Bool (4523 uses) ranks much higher than ShakeOptions (24 uses) by not having
-- [] (10237 uses) skew the curve too much and use up all the available bits of discrimination.
commonNameThreshold = 1024

readNames :: StoreRead -&gt; Names
readNames store = Names $ \x -&gt; Map.lookup (bstrPack $ strUnpack x) mp
    where mp = Map.fromAscList $ zip (bstr0Split s) $ V.toList n
          (s, n) = storeRead store TypesNames


---------------------------------------------------------------------
-- DUPLICATION INFORMATION

data TypesDuplicates a where TypesDuplicates :: TypesDuplicates (Jagged TargetId) deriving Typeable

newtype Duplicates = Duplicates {expandDuplicates :: Int -&gt; [TargetId]}

-- writeDuplicates xs == nub (map snd xs)
    -- all duplicates are removed, order of first element is preserved
-- (i,x) &lt;- zip [0..] (writeDuplicates xs); expandDuplicates i == map fst (filter ((==) x . snd) xs)
    -- given the result at position i, expandDuplicates gives the TargetId&apos;s related to it

writeDuplicates :: Ord a =&gt; StoreWrite -&gt; [(TargetId, Sig a)] -&gt; IO [Sig a]
writeDuplicates store xs = do
    -- s=signature, t=targetid, p=popularity (incoing index), i=index (outgoing index)
    xs &lt;- pure $ map (second snd) $ sortOn (fst . snd) $ Map.toList $
        Map.fromListWith (\(x1,x2) (y1,y2) -&gt; (, x2 ++ y2) $! min x1 y1)
                         [(s,(p,[t])) | (p,(t,s)) &lt;- zipFrom (0::Int) xs]
    -- give a list of TargetId&apos;s at each index
    storeWrite store TypesDuplicates $ jaggedFromList $ map (reverse . snd) xs
    pure $ map fst xs

readDuplicates :: StoreRead -&gt; Duplicates
readDuplicates store = Duplicates $ V.toList . ask
    where ask = jaggedAsk $ storeRead store TypesDuplicates


---------------------------------------------------------------------
-- FINGERPRINT INFORMATION

data TypesFingerprints a where TypesFingerprints :: TypesFingerprints (V.Vector Fingerprint) deriving Typeable

data Fingerprint = Fingerprint
    {fpRare1 :: {-# UNPACK #-} !Name -- Most rare ctor, or 0 if no rare stuff
    ,fpRare2 :: {-# UNPACK #-} !Name -- 2nd rare ctor
    ,fpRare3 :: {-# UNPACK #-} !Name -- 3rd rare ctor
    ,fpArity :: {-# UNPACK #-} !Word8 -- Artiy, where 0 = CAF
    ,fpTerms :: {-# UNPACK #-} !Word8 -- Number of terms (where 255 = 255 and above)
    } deriving (Eq,Show,Typeable)

prettyFingerprint :: Fingerprint -&gt; String
prettyFingerprint Fingerprint{..} =
    &quot;arity=&quot; ++ show fpArity ++ &quot;, terms=&quot; ++ show fpTerms ++
    &quot;, rarity=&quot; ++ unwords (map prettyName [fpRare1, fpRare2, fpRare3])


{-# INLINE fpRaresFold #-}
fpRaresFold :: (b -&gt; b -&gt; b) -&gt; (Name -&gt; b) -&gt; Fingerprint -&gt; b
fpRaresFold g f Fingerprint{..} = f fpRare1 `g` f fpRare2 `g` f fpRare3

instance Storable Fingerprint where
    sizeOf _ = 4 * sizeOf name0
    alignment _ = 4
    peekByteOff ptr i = Fingerprint
        &lt;$&gt; peekByteOff ptr (i+0) &lt;*&gt; peekByteOff ptr (i+1*w) &lt;*&gt; peekByteOff ptr (i+2*w)
        &lt;*&gt; peekByteOff ptr (i+3*w) &lt;*&gt; peekByteOff ptr (i+3*w + 1)
        where w = sizeOf name0
    pokeByteOff ptr i Fingerprint{..} = do
        pokeByteOff ptr (i+0) fpRare1 &gt;&gt; pokeByteOff ptr (i+1*w) fpRare2 &gt;&gt; pokeByteOff ptr (i+2*w) fpRare3
        pokeByteOff ptr (i+3*w) fpArity &gt;&gt; pokeByteOff ptr (i+3*w + 1) fpTerms
        where w = sizeOf name0

toFingerprint :: Sig Name -&gt; Fingerprint
toFingerprint sig = Fingerprint{..}
    where fpRare1:fpRare2:fpRare3:_ = sort (nubOrd $ filter isCon $ universeBi sig) ++ [name0,name0,name0]
          fpArity = fromIntegral $ min 255 $ max 0 $ pred $ length $ sigTy sig
          fpTerms = fromIntegral $ min 255 $ length (universeBi sig :: [Name])

writeFingerprints :: StoreWrite -&gt; [Sig Name] -&gt; IO ()
writeFingerprints store xs = storeWrite store TypesFingerprints $ V.fromList $ map toFingerprint xs

data MatchFingerprint a ma = MatchFingerprint
    {mfpAdd :: a -&gt; a -&gt; a
    ,mfpAddM :: ma -&gt; ma -&gt; ma
    ,mfpJust :: a -&gt; ma
    ,mfpCost :: String -&gt; Int -&gt; a
    ,mfpMiss :: String -&gt; ma
    }

matchFingerprint :: Sig Name -&gt; Fingerprint -&gt; Maybe Int
matchFingerprint = matchFingerprintEx MatchFingerprint{..}
    where
        mfpAdd = (+)
        mfpAddM = liftM2 (+)
        mfpJust = Just
        mfpCost _ x = x
        mfpMiss _ = Nothing

matchFingerprintDebug :: Sig Name -&gt; Fingerprint -&gt; [Either String (String, Int)]
matchFingerprintDebug = matchFingerprintEx MatchFingerprint{..}
    where
        mfpAdd = (++)
        mfpAddM = (++)
        mfpJust = id
        mfpCost s x = [Right (s,x)]
        mfpMiss s = [Left s]


{-# INLINE matchFingerprintEx #-}
matchFingerprintEx :: forall a ma . MatchFingerprint a ma -&gt; Sig Name -&gt; Fingerprint -&gt; ma -- lower is better
matchFingerprintEx MatchFingerprint{..} sig@(toFingerprint -&gt; target) =
    \candidate -&gt; arity (fpArity candidate) `mfpAddM` terms (fpTerms candidate) `mfpAddM` rarity candidate
    where
        -- CAFs must match perfectly, otherwise too many is better than too few
        arity | ta == 0 = \ca -&gt; if ca == 0 then mfpJust $ mfpCost &quot;arity equal&quot; 0 else mfpMiss &quot;arity different and query a CAF&quot; -- searching for a CAF
              | otherwise = \ca -&gt; case fromIntegral ca - fromIntegral ta of
                    _ | ca == 0 -&gt; mfpMiss &quot;arity different and answer a CAF&quot; -- searching for a CAF
                    0  -&gt; mfpJust $ mfpCost &quot;arity equal&quot; 0 -- perfect match
                    -1 -&gt; mfpJust $ mfpCost &quot;arity 1 to remove&quot; 1000 -- not using something the user carefully wrote
                    n | n &gt; 0 &amp;&amp; allowMore -&gt; mfpJust $ mfpCost (&quot;arity &quot; ++ show n ++ &quot; to add with wildcard&quot;) $ 300 * n -- user will have to make up a lot, but they said _ in their search
                    1  -&gt; mfpJust $ mfpCost &quot;arity 1 to add&quot; 300  -- user will have to make up an extra param
                    2  -&gt; mfpJust $ mfpCost &quot;arity 2 to add&quot;  900  -- user will have to make up two params
                    _ -&gt; mfpMiss &quot;&quot;
            where
                ta = fpArity target
                allowMore = TVar name0 [] `elem` sigTy sig

        -- missing terms are a bit worse than invented terms, but it&apos;s fairly balanced, clip at large numbers
        terms = \ct -&gt; case fromIntegral ct - fromIntegral tt of
                n | abs n &gt; 20 -&gt; mfpMiss $ &quot;terms &quot; ++ show n ++ &quot; different&quot; -- too different
                  | n == 0 -&gt; mfpJust $ mfpCost &quot;terms equal&quot; 0
                  | n &gt; 0 -&gt; mfpJust $ mfpCost (&quot;terms &quot; ++ show n ++ &quot; to add&quot;) $ n * 10 -- candidate has more terms
                  | otherwise -&gt; mfpJust $ mfpCost (&quot;terms &quot; ++ show (-n) ++ &quot; to remove&quot;) $ abs n * 12 -- candidate has less terms
            where
                tt = fpTerms target

        -- given two fingerprints, you have three sets:
        -- Those in common; those in one but not two; those in two but not one
        -- those that are different
        rarity = \cr -&gt; let tr = target in mfpJust $
                differences 5000 400 tr cr `mfpAdd` -- searched for T but its not in the candidate, bad if rare, not great if common
                differences 1000  50 cr tr          -- T is in the candidate but I didn&apos;t search for it, bad if rare, OK if common
            where
                fpRaresElem :: Name -&gt; Fingerprint -&gt; Bool
                fpRaresElem !x = fpRaresFold (||) (== x)

                differences :: Double -&gt; Double -&gt; Fingerprint -&gt; Fingerprint -&gt; a
                differences !rare !common !want !have = fpRaresFold mfpAdd f want
                    where f n | fpRaresElem n have = mfpCost (&quot;term in common &quot; ++ prettyName n) 0
                              | n == name0 = mfpCost &quot;term _ missing&quot; 0 -- will pay the cost the other way around
                              | otherwise = let p = popularityName n in mfpCost (&quot;term &quot; ++ prettyName n ++ &quot; (&quot; ++ showDP 2 p ++ &quot;) missing&quot;) $
                                            floor $ (p*common) + ((1-p)*rare)


---------------------------------------------------------------------
-- SIGNATURES

data TypesSigPositions a where TypesSigPositions :: TypesSigPositions (V.Vector Word32) deriving Typeable
data TypesSigData a where TypesSigData :: TypesSigData BS.ByteString deriving Typeable

writeSignatures :: StoreWrite -&gt; [Sig Name] -&gt; IO ()
writeSignatures store xs = do
    v &lt;- VM.new $ length xs
    forM_ (zipFrom 0 xs) $ \(i,x) -&gt; do
        let b = encodeBS x
        storeWritePart store TypesSigData b
        VM.write v i $ fromIntegral $ BS.length b
    v &lt;- V.freeze v
    storeWrite store TypesSigPositions v

type SigLoc = (Word32, Word32)

readSignatureIndex :: StoreRead -&gt; [SigLoc] -- (offset,size) pairs for each field
readSignatureIndex store = zip offsets (V.toList sizes)
  where sizes   = storeRead store TypesSigPositions
        offsets = V.toList $ V.prescanl&apos; (+) 0 sizes

readSignatureAt :: StoreRead -&gt; SigLoc -&gt; Sig Name
readSignatureAt store (offset, size) = decodeBS (BS.take (fromIntegral size)
                                                 $ snd
                                                 $ BS.splitAt (fromIntegral offset) bs)
  where
    bs = storeRead store TypesSigData

---------------------------------------------------------------------
-- TYPE SEARCH

searchTypeMatch :: [ (Int, (Int, SigLoc, Fingerprint)) ]
                -&gt; (SigLoc -&gt; Sig Name)
                -&gt; Name
                -&gt; Int
                -&gt; Sig Name
                -&gt; [Int]
searchTypeMatch possibilities getSig arrow n sig =
    map snd $ takeSortOn fst n
      [ (500 * v + fv, i) | (fv, (i, sigIdx, f)) &lt;- possibilities
                          , v  &lt;- maybeToList (matchType arrow sig $ getSig sigIdx)]

bestByFingerprint :: [(SigLoc, Fingerprint)] -&gt; Int -&gt; Sig Name -&gt; [ (Int, (Int, SigLoc, Fingerprint)) ]
bestByFingerprint db n sig =
  takeSortOn fst (max 5000 n)
    [ (fv, (i, sigIdx, f)) | (i, (sigIdx, f)) &lt;- zipFrom 0 db
                           , fv &lt;- maybeToList (matchFp f) ]
  where
    matchFp = matchFingerprint sig

matchType :: Name -&gt; Sig Name -&gt; Sig Name -&gt; Maybe Int
matchType arr qry ans = unWork &lt;$&gt; lhs `matches` rhs
    where
      lhs = (toTyp arr qry, sigCtx qry)
      rhs = (toTyp arr ans, sigCtx ans)

-- Check if two types-with-context match, returning the amount of work
-- needed to create the match.
matches :: (Typ Name, [Ctx Name]) -&gt; (Typ Name, [Ctx Name]) -&gt; Maybe Work
matches (lhs, lctx) (rhs, rctx) = runST $ evalStateT (getWork go) (Work 0)
  where
    go :: forall s. StateT Work (ST s) Bool
    go = do
        -- Try to unify the answer type with the query type.
        (qry, qryC) &lt;- lift (refTyp True  lhs lctx)
        (ans, ansC) &lt;- lift (refTyp False rhs rctx)
        unifyTyp qry ans &gt;&gt;= \case
            False -&gt; pure False
            True  -&gt; do
                -- Normalize constraints
                let normalize (Ctx c a) = lift (Ctx &lt;$&gt; getName c &lt;*&gt; getName a)
                qryNCs &lt;- Set.fromList &lt;$&gt; (mapM normalize qryC)
                ansNCs &lt;- Set.fromList &lt;$&gt; (mapM normalize ansC)

                nqry &lt;- lift $ normalizeTy qry
                nans &lt;- lift $ normalizeTy ans

                -- Discharge constraints; remove any answer-constraint that is also a query-constraint,
                -- and then remove any remaining answer-constraint that is constraining a concrete type.
                -- TODO: keep constrained concrete types but weight them differently if they correspond
                --       to a known instance (e.g. free if we know the instance, rather expensive otherwise).
                let addl = filter isAbstract (Set.toList $ ansNCs `Set.difference` qryNCs)
                    isAbstract (Ctx c a) = isVar a

                workDelta (Work (3 * length addl))

                pure True

    getWork action = action &gt;&gt;= \case
        True  -&gt; Just &lt;$&gt; get
        False -&gt; pure Nothing

    normalizeTy = \case
        TyVar n tys -&gt; TyVar &lt;$&gt; getName n &lt;*&gt; mapM normalizeTy tys
        TyCon n tys -&gt; TyCon &lt;$&gt; getName n &lt;*&gt; mapM normalizeTy tys
        TyFun args retn -&gt; TyFun &lt;$&gt; mapM normalizeTy args &lt;*&gt; normalizeTy retn


-- A slight variation on &apos;Ty&apos;, with a special term for functions.
data Typ n
    = TyFun [Typ n] (Typ n)
    | TyCon n [Typ n]
    | TyVar n [Typ n]
  deriving (Eq, Ord, Functor)

-- Rebuild a little bit of recursion-schemes machinery for Typ.
data TypF n t
    = TyFunF [t] t
    | TyConF n [t]
    | TyVarF n [t]
  deriving (Eq, Ord, Functor)

unroll :: Typ n -&gt; TypF n (Typ n)
unroll = \case
    TyFun args retn -&gt; TyFunF args retn
    TyCon n tys     -&gt; TyConF n tys
    TyVar n tys     -&gt; TyVarF n tys

foldTy :: (TypF n a -&gt; a) -&gt; Typ n -&gt; a
foldTy phi = phi . fmap (foldTy phi) . unroll

instance Show n =&gt; Show (Typ n) where
    show = foldTy $ \case
        TyFunF typs res -&gt; &quot;&lt;&quot; ++ intercalate &quot;, &quot; typs ++ &quot;; &quot; ++ res ++ &quot;&gt;&quot;
        TyConF n args -&gt; unwords (show n : args)
        TyVarF n args -&gt; unwords (show n : args)

-- Convert a Sig to a Typ.
toTyp :: Name -&gt; Sig Name -&gt; Typ Name
toTyp arrow Sig{..} = case sigTy of
    [] -&gt; error &quot;no types?&quot;
    tys -&gt; let args = init tys
               retn = last tys
           in TyFun (map toTy args) (toTy retn)
  where
    toTy = \case
      TCon n []   | n == arrow -&gt; TyCon n [] -- empty function type?!
      TCon n tys | n == arrow -&gt; TyFun (map toTy (init tys)) (toTy $ last tys)
      TCon n tys -&gt; TyCon n (map toTy tys)
      TVar n tys -&gt; TyVar n (map toTy tys)


---------------------------------------------------------------------
-- UNIFICATION

-- A union-find data structure for names

type NameRef s = STRef s (NameInfo s)

data NameInfo s =
    NameInfo { niParent :: !(Maybe (NameRef s))
             , niRank   :: !Int
             , niName   :: !Name
             , niFree   :: !Bool
             }
  deriving Eq

-- Find the name of the equivalence class&apos;s (current) representative.
getName :: NameRef s -&gt; ST s Name
getName ref = do
    rep &lt;- findRep ref
    niName &lt;$&gt; readSTRef rep

-- Create a new name reference from a name. @fixed == True@ means
-- that the reference cannot be unified with any other fixed refs.
newNameInfo :: Bool -&gt; Name -&gt; ST s (STRef s (NameInfo s))
newNameInfo fixed n = newSTRef $
  NameInfo { niParent = Nothing
           , niRank   = 0
           , niName   = n
           , niFree   = not fixed &amp;&amp; isVar n
           }

-- The &quot;find&quot; part of union-find, with path compression.
findRep :: NameRef s -&gt; ST s (NameRef s)
findRep ref = do
    ni &lt;- readSTRef ref
    case niParent ni of
        Nothing -&gt; pure ref
        Just p  -&gt; do
            root &lt;- findRep p
            writeSTRef ref (ni { niParent = Just root })
            pure root

-- The &quot;union&quot; part of union-find, with union-by-rank.
-- Each unification is given a cost of 1 work unit.
unifyName :: NameRef s -&gt; NameRef s -&gt; StateT Work (ST s) Bool
unifyName lhs rhs = do
    lhs&apos; &lt;- lift $ findRep lhs
    rhs&apos; &lt;- lift $ findRep rhs
    lInfo &lt;- lift $ readSTRef lhs&apos;
    rInfo &lt;- lift $ readSTRef rhs&apos;
    let lFree = niFree lInfo
        rFree = niFree rInfo
        lName = niName lInfo
        rName = niName rInfo
    let ok = lFree || rFree || lName == rName
    when (ok &amp;&amp; lInfo /= rInfo) $ do
        -- Union by rank, except prefer concrete names over type variables.
        workDelta (Work 1)
        let lRank = niRank lInfo
            rRank = niRank rInfo
        let (root, child) = if not lFree || lRank &lt;= rRank
                            then (lhs&apos;, rhs&apos;)
                            else (rhs&apos;, lhs&apos;)
        lift $ modifySTRef&apos; child (\n -&gt; n { niParent = Just root })
        when (lRank == rRank) $ lift $ modifySTRef&apos; root (\n -&gt; n { niRank = lRank + 1 })

    pure ok

-- Allocate new references for each name that appears in the type and context.
refTyp :: Bool -&gt; Typ Name -&gt; [Ctx Name] -&gt; ST s (Typ (NameRef s), [Ctx (NameRef s)])
refTyp fixed t cs =
    evalStateT go Map.empty
  where
    go = do
        ty  &lt;- mkRefs t
        ctx &lt;- forM cs $ \(Ctx c a) -&gt; Ctx &lt;$&gt; getRef c &lt;*&gt; getRef a
        pure (ty, ctx)

    mkRefs = foldTy $ \case
        TyVarF n args    -&gt; TyVar &lt;$&gt; getRef n &lt;*&gt; sequence args
        TyConF n args    -&gt; TyCon &lt;$&gt; getRef n &lt;*&gt; sequence args
        TyFunF args retn -&gt; TyFun &lt;$&gt; sequence args &lt;*&gt; retn

    getRef n = do
        known &lt;- get
        case Map.lookup n known of
            Just ref -&gt; pure ref
            Nothing  -&gt; do
                ref &lt;- lift (newNameInfo fixed n)
                put (Map.insert n ref known)
                pure ref

-- Unify two types.
unifyTyp :: Typ (NameRef s) -&gt; Typ (NameRef s) -&gt; StateT Work (ST s) Bool
unifyTyp lhs rhs = case (lhs, rhs) of
    (TyCon n tys, TyVar n&apos; tys&apos;) | length tys == length tys&apos; -&gt; do
            ok &lt;- unifyName n n&apos;
            if not ok
              then pure False
              else and &lt;$&gt; zipWithM unifyTyp tys tys&apos;

    (TyCon n tys, TyCon n&apos; tys&apos;) | length tys == length tys&apos; -&gt; do
            ok &lt;- unifyName n n&apos;
            if not ok
              then pure False
              else and &lt;$&gt; zipWithM unifyTyp tys tys&apos;

    (TyVar n tys, TyVar n&apos; tys&apos;) | length tys == length tys&apos; -&gt; do
            ok &lt;- unifyName n n&apos;
            if not ok
              then pure False
              else and &lt;$&gt; zipWithM unifyTyp tys tys&apos;

    (TyFun args ret, TyFun args&apos; ret&apos;) | length args == length args&apos; -&gt; do
            ok &lt;- unifyTyp ret ret&apos;
            if not ok
              then pure False
              else and &lt;$&gt; zipWithM unifyTyp args args&apos;

    _ -&gt; pure False

-- The total cost of a unification operation.
newtype Work = Work Int

unWork :: Work -&gt; Int
unWork (Work w) = w

workDelta :: Monad m =&gt; Work -&gt; StateT Work m ()
workDelta (Work dw) = modify&apos; (\(Work w) -&gt; Work (w + dw))</file><file path="src/Hoogle.hs">-- | High level Hoogle API
module Hoogle(
    Database, withDatabase, searchDatabase, defaultDatabaseLocation,
    Target(..), URL,
    hoogle,
    targetInfo,
    targetResultDisplay
    ) where

import Control.DeepSeq (NFData)

import Query
import Input.Item
import General.Util
import General.Store

import Action.CmdLine
import Action.Generate
import Action.Search
import Action.Server
import Action.Test


-- | Database containing Hoogle search data.
newtype Database = Database StoreRead

-- | Load a database from a file.
withDatabase :: NFData a =&gt; FilePath -&gt; (Database -&gt; IO a) -&gt; IO a
withDatabase file act = storeReadFile file $ act . Database

-- | The default location of a database
defaultDatabaseLocation :: IO FilePath
defaultDatabaseLocation = defaultDatabaseLang Haskell

-- | Search a database, given a query string, produces a list of results.
searchDatabase :: Database -&gt; String -&gt; [Target]
searchDatabase (Database db) query = snd $ search db $ parseQuery query


-- | Run a command line Hoogle operation.
hoogle :: [String] -&gt; IO ()
hoogle args = do
    args &lt;- getCmdLine args
    case args of
        Search{} -&gt; actionSearch args
        Generate{} -&gt; actionGenerate args
        Server{} -&gt; actionServer args
        Test{} -&gt; actionTest args
        Replay{} -&gt; actionReplay args</file><file path="src/Main.hs">module Main(main) where

import System.Environment
import System.IO
import Hoogle


main :: IO ()
main = do
    hSetEncoding stdout utf8
    hoogle =&lt;&lt; getArgs</file><file path="src/Paths.hs">module Paths_hoogle where

import Data.Version.Extra

version :: Version
version = makeVersion [0,0]

getDataDir :: IO FilePath
getDataDir = pure &quot;.&quot;</file><file path="src/Query.hs">{-# LANGUAGE PatternGuards, ViewPatterns, RecordWildCards #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -O0 #-} -- otherwise it takes a lot of memory to compile on the haskell.org server

module Query(
    Query(..), isQueryName, isQueryType, isQueryScope,
    parseQuery, renderQuery,
    query_test
    ) where

import Data.List
import Language.Haskell.Exts
import Data.Char
import Text.Blaze
import qualified Text.Blaze.XHtml5 as H
import Data.List.Extra
import Data.Generics.Uniplate.Data
import General.Util
import Data.Maybe
import Data.Monoid
import Control.Applicative
import Prelude

---------------------------------------------------------------------
-- DATA TYPE

data Query
    = QueryName {fromQueryName :: String}
    | QueryType {fromQueryType :: Type ()}
    | QueryScope {scopeInclude :: Bool, scopeCategory :: String, scopeValue :: String}
    | QueryNone String -- part of the query that is ignored
      deriving (Show,Eq)

isQueryName, isQueryType, isQueryScope :: Query -&gt; Bool
isQueryName QueryName{} = True; isQueryName _ = False
isQueryType QueryType{} = True; isQueryType _ = False
isQueryScope QueryScope{} = True; isQueryScope _ = False

renderQuery :: [Query] -&gt; Markup
renderQuery [] = H.i &quot;No query&quot;
renderQuery xs = do
    string $ unwords $
        [x | QueryName x &lt;- xs] ++
        [&quot;:: &quot; ++ pretty x | QueryType x &lt;- xs] ++
        [[&apos;-&apos; | not scopeInclude] ++ scopeCategory ++ &quot;:&quot; ++ scopeValue | QueryScope{..} &lt;- xs]
    mconcat [&quot; &quot; &lt;&gt; H.del (string x) | QueryNone x &lt;- xs]


---------------------------------------------------------------------
-- PARSER

parseQuery :: String -&gt; [Query]
parseQuery x = map QueryName nam ++ map QueryType (maybeToList typ) ++ scp
    where
        (scp,rest) = scope_ $ lexer x
        (nam,typ) = divide rest


openBrackets = [&quot;(#&quot;,&quot;[:&quot;,&quot;(&quot;,&quot;[&quot;]
shutBrackets = [&quot;#)&quot;,&quot;:]&quot;,&quot;)&quot;,&quot;]&quot;]

isBracket x = x `elem` (openBrackets ++ shutBrackets)
isBracketPair x = x `elem` zipWith (++) openBrackets shutBrackets

isSym x = ((isSymbol x || isPunctuation x) &amp;&amp; x `notElem` special) || x `elem` ascSymbol
    where special = &quot;(),;[]`{}\&quot;&apos;&quot; :: String
          ascSymbol = &quot;!#$%&amp;*+./&lt;=&gt;?@\\^|-~&quot; :: String

isSyms xs | isBracket xs || isBracketPair xs = False
isSyms (x:xs) = isSym x
isSyms [] = False

-- | Split into small lexical chunks.
--
-- &gt; &quot;Data.Map.(!)&quot; ==&gt; [&quot;Data&quot;,&quot;.&quot;,&quot;Map&quot;,&quot;.&quot;,&quot;(&quot;,&quot;!&quot;,&quot;)&quot;]
lexer :: String -&gt; [String]
lexer (&apos;(&apos;:&apos;,&apos;:xs) | (a,&apos;)&apos;:b) &lt;- span (== &apos;,&apos;) xs = (&quot;(,&quot; ++ a ++ &quot;)&quot;) : lexer b
lexer x | Just s &lt;- (bs !!) &lt;$&gt; findIndex (`isPrefixOf` x) bs = s : lexer (drop (length s) x)
    where bs = zipWith (++) openBrackets shutBrackets ++ openBrackets ++ shutBrackets
lexer (x:xs)
    | isSpace x = &quot; &quot; : lexer (trimStart xs)
    | isAlpha x || x == &apos;_&apos; =
        let (a,b) = span (\x -&gt; isAlphaNum x || x `elem` (&quot;_&apos;#-&quot; :: String)) xs
            (a1,a2) = spanEnd (== &apos;-&apos;) a
        in (x:a1) : lexer (a2 ++ b)
    | isSym x = let (a,b) = span isSym xs in (x:a) : lexer b
    | x == &apos;,&apos; = &quot;,&quot; : lexer xs
    | otherwise = lexer xs -- drop invalid bits
lexer [] = []


-- | Find and extract the scope annotations.
--
-- &gt; +package
-- &gt; +module
-- &gt; name.bar
-- &gt; name.++ name.(++) (name.++)
-- &gt; +foo -foo
-- &gt; +scope:foo -scope:foo scope:foo
scope_ :: [String] -&gt; ([Query], [String])
scope_ xs = case xs of
    (readPM -&gt; Just pm):(readCat -&gt; Just cat):&quot;:&quot;:(readMod -&gt; Just (mod,rest)) -&gt; add pm cat mod rest
    (readPM -&gt; Just pm):(readCat -&gt; Just cat):&quot;:-&quot;:(readMod -&gt; Just (mod,rest)) -&gt; add False cat mod rest
    (readPM -&gt; Just pm):(readMod -&gt; Just (mod,rest)) -&gt; add_ pm mod rest
    (readCat -&gt; Just cat):&quot;:&quot;:(readMod -&gt; Just (mod,rest)) -&gt; add True cat mod rest
    (readCat -&gt; Just cat):&quot;:.&quot;:(readMod -&gt; Just (mod,rest)) -&gt; add True cat (&apos;.&apos;:mod) rest
    (readCat -&gt; Just cat):&quot;:-&quot;:(readMod -&gt; Just (mod,rest)) -&gt; add False cat mod rest
    (readCat -&gt; Just cat):&quot;:-.&quot;:(readMod -&gt; Just (mod,rest)) -&gt; add False cat (&apos;.&apos;:mod) rest
    &quot;(&quot;:(readDots -&gt; Just (scp,x:&quot;)&quot;:rest)) -&gt; out [&quot;(&quot;,x,&quot;)&quot;] $ add_ True scp rest
    (readDots -&gt; Just (scp,rest)) -&gt; add_ True scp rest
    &quot;(&quot;:&quot;.&quot;:(readDots -&gt; Just (scp,x:&quot;)&quot;:rest)) -&gt; out [&quot;(&quot;,x,&quot;)&quot;] $ add_ True (&apos;.&apos;:scp) rest
    &quot;.&quot;:(readDots -&gt; Just (scp,rest)) -&gt; add_ True (&apos;.&apos;:scp) rest
    x:xs -&gt; out [x] $ scope_ xs
    [] -&gt; ([], [])
    where
        out xs (a,b) = (a,xs++b)
        add a b c rest = let (x,y) = scope_ rest in (QueryScope a b c : x, y)
        add_ a c rest = add a b c rest
            where b = if &apos;.&apos; `elem` c || any isUpper (take 1 c) then &quot;module&quot; else &quot;package&quot;

        readPM x = case x of &quot;+&quot; -&gt; Just True; &quot;-&quot; -&gt; Just False; _ -&gt; Nothing

        readCat x | isAlpha1 x = Just x
                  | otherwise = Nothing

        readMod (x:xs) | isAlpha1 x = Just $ case xs of
            &quot;.&quot;:ys | Just (a,b) &lt;- readMod ys -&gt; (x ++ &quot;.&quot; ++ a, b)
            &quot;.&quot;:[] -&gt; (x ++ &quot;.&quot;,[])
            &quot;.&quot;:&quot; &quot;:ys -&gt; (x ++ &quot;.&quot;,&quot; &quot;:ys)
            _ -&gt; (x,xs)
        readMod _ = Nothing

        readDots (x:xs) | isAlpha1 x = case xs of
            &quot;.&quot;:ys | Just (a,b) &lt;- readDots ys -&gt; Just (x ++ &quot;.&quot; ++ a, b)
            (&apos;.&apos;:y):ys -&gt; Just (x, [y | y /= &quot;&quot;] ++ ys)
            _ -&gt; Nothing
        readDots _ = Nothing


-- | If everything is a name, or everything is a symbol, then you only have names.
divide :: [String] -&gt; ([String], Maybe (Type ()))
divide xs | all isAlpha1 ns = (ns, Nothing)
          | all isSyms ns = (ns, Nothing)
          | length ns == 1 = (ns, Nothing)
          | otherwise = case break (== &quot;::&quot;) xs of
                (nam, _:rest) -&gt; (names_ nam, typeSig_ rest)
                _ -&gt; ([], typeSig_ xs)
    where ns = names_ xs


-- | Ignore brackets around symbols, and try to deal with tuple names.
names_ :: [String] -&gt; [String]
names_ (&quot;(&quot;:x:&quot;)&quot;:xs) = [x | x /= &quot; &quot;] ++ names_ xs
names_ [&quot;(&quot;,x] = [x]
names_ (x:xs) = [x | x /= &quot; &quot;] ++ names_ xs
names_ [] = []

typeSig_ :: [String] -&gt; Maybe (Type ())
typeSig_ xs = case parseTypeWithMode parseMode $ unwords $ fixup $ filter (not . all isSpace) xs of
    ParseOk x -&gt; Just $ transformBi (\v -&gt; if v == Ident () &quot;__&quot; then Ident () &quot;_&quot; else v) $ fmap (const ()) x
    _ -&gt; Nothing
    where
        fixup = underscore . closeBracket . completeFunc . completeArrow

        completeArrow (unsnoc -&gt; Just (a,b)) | b `elem` [&quot;-&quot;,&quot;=&quot;] = snoc a (b ++ &quot;&gt;&quot;)
        completeArrow x = x

        completeFunc (unsnoc -&gt; Just (a,b)) | b `elem` [&quot;-&gt;&quot;,&quot;=&gt;&quot;] = a ++ [b,&quot;_&quot;]
        completeFunc x = x

        closeBracket xs = xs ++ foldl f [] xs
            where f stack x | Just c &lt;- lookup x (zip openBrackets shutBrackets) = c:stack
                  f (s:tack) x | x == s = tack
                  f stack x = stack

        underscore = replace [&quot;_&quot;] [&quot;__&quot;]


query_test :: IO ()
query_test = testing &quot;Query.parseQuery&quot; $ do
    let want s p (bad,q) = ([&quot;missing &quot; ++ s | not $ any p q], filter (not . p) q)
        wantEq v = want (show v) (== v)
        name = wantEq . QueryName
        scope b c v = wantEq $ QueryScope b c v
        typ = wantEq . QueryType . fmap (const ()) . fromParseResult . parseTypeWithMode parseMode
        typpp x = want (&quot;type &quot; ++ x) (\v -&gt; case v of QueryType s -&gt; pretty s == x; _ -&gt; False)
    let infixl 0 ===
        a === f | bad@(_:_) &lt;- fst $ f ([], q) = error $ show (a,q,bad :: [String])
                | otherwise = putChar &apos;.&apos;
            where q = parseQuery a

    &quot;&quot; === id
    &quot;map&quot; === name &quot;map&quot;
    &quot;#&quot; === name &quot;#&quot;
    &quot;c#&quot; === name &quot;c#&quot;
    &quot;-&quot; === name &quot;-&quot;
    &quot;/&quot; === name &quot;/&quot;
    &quot;-&gt;&quot; === name &quot;-&gt;&quot;
    &quot;foldl&apos;&quot; === name &quot;foldl&apos;&quot;
    &quot;fold&apos;l&quot; === name &quot;fold&apos;l&quot;
    &quot;Int#&quot; === name &quot;Int#&quot;
    &quot;concat map&quot; === name &quot;concat&quot; . name &quot;map&quot;
    &quot;a -&gt; b&quot; === typ &quot;a -&gt; b&quot;
    &quot;a-&gt;b&quot; === typ &quot;a -&gt; b&quot;
    &quot;(a b)&quot; === typ &quot;(a b)&quot;
    &quot;map :: a -&gt; b&quot; === typ &quot;a -&gt; b&quot;
    &quot;+Data.Map map&quot; === scope True &quot;module&quot; &quot;Data.Map&quot; . name &quot;map&quot;
    &quot;a -&gt; b package:foo&quot; === scope True &quot;package&quot; &quot;foo&quot; . typ &quot;a -&gt; b&quot;
    &quot;a -&gt; b package:foo-bar&quot; === scope True &quot;package&quot; &quot;foo-bar&quot; . typ &quot;a -&gt; b&quot;
    &quot;Data.Map.map&quot; === scope True &quot;module&quot; &quot;Data.Map&quot; . name &quot;map&quot;
    &quot;[a]&quot; === typ &quot;[a]&quot;
    &quot;++&quot; === name &quot;++&quot;
    &quot;(++)&quot; === name &quot;++&quot;
    &quot;:+:&quot; === name &quot;:+:&quot;
    &quot;bytestring-cvs +hackage&quot; === scope True &quot;package&quot; &quot;hackage&quot; . name &quot;bytestring-cvs&quot;
    &quot;m =&gt; c&quot; === typ &quot;m =&gt; c&quot;
    &quot;[b ()&quot; === typ &quot;[b ()]&quot;
    &quot;[b (&quot; === typ &quot;[b ()]&quot;
    &quot;_ -&gt; a&quot; === typpp &quot;_ -&gt; a&quot;
    &quot;(a -&gt; b) -&gt;&quot; === typpp &quot;(a -&gt; b) -&gt; _&quot;
    &quot;(a -&gt; b) -&quot; === typpp &quot;(a -&gt; b) -&gt; _&quot;
    &quot;Monad m =&gt; &quot; === typpp &quot;Monad m =&gt; _&quot;
    &quot;map is:exact&quot; === name &quot;map&quot; . scope True &quot;is&quot; &quot;exact&quot;
    &quot;sort set:hackage&quot; === name &quot;sort&quot; . scope True &quot;set&quot; &quot;hackage&quot;
    &quot;sort -set:hackage&quot; === name &quot;sort&quot; . scope False &quot;set&quot; &quot;hackage&quot;
    &quot;sort set:-hackage&quot; === name &quot;sort&quot; . scope False &quot;set&quot; &quot;hackage&quot;
    &quot;sort -set:-hackage&quot; === name &quot;sort&quot; . scope False &quot;set&quot; &quot;hackage&quot;
    &quot;package:bytestring-csv&quot; === scope True &quot;package&quot; &quot;bytestring-csv&quot;
    &quot;(&gt;&gt;=)&quot; === name &quot;&gt;&gt;=&quot;
    &quot;(&gt;&gt;=&quot; === name &quot;&gt;&gt;=&quot;
    &quot;&gt;&gt;=&quot; === name &quot;&gt;&gt;=&quot;
    &quot;Control.Monad.mplus&quot; === name &quot;mplus&quot; . scope True &quot;module&quot; &quot;Control.Monad&quot;
    &quot;Control.Monad.&gt;&gt;=&quot; === name &quot;&gt;&gt;=&quot; . scope True &quot;module&quot; &quot;Control.Monad&quot;
    &quot;Control.Monad.(&gt;&gt;=)&quot; === name &quot;&gt;&gt;=&quot; . scope True &quot;module&quot; &quot;Control.Monad&quot;
    &quot;(Control.Monad.&gt;&gt;=)&quot; === name &quot;&gt;&gt;=&quot; . scope True &quot;module&quot; &quot;Control.Monad&quot;
    &quot;Control.Monad.(&gt;&gt;=&quot; === name &quot;&gt;&gt;=&quot; . scope True &quot;module&quot; &quot;Control.Monad&quot;
    &quot;(Control.Monad.&gt;&gt;=&quot; === name &quot;&gt;&gt;=&quot; . scope True &quot;module&quot; &quot;Control.Monad&quot;
    &quot;foo.bar&quot; === name &quot;bar&quot; . scope True &quot;package&quot; &quot;foo&quot;
    &quot;insert module:.Map&quot; === name &quot;insert&quot; . scope True &quot;module&quot; &quot;.Map&quot;
    &quot;insert module:Map.&quot; === name &quot;insert&quot; . scope True &quot;module&quot; &quot;Map.&quot;
    &quot;insert module:.Map.&quot; === name &quot;insert&quot; . scope True &quot;module&quot; &quot;.Map.&quot;
    &quot;.Map.insert&quot; === name &quot;insert&quot; . scope True &quot;module&quot; &quot;.Map&quot;
    &quot;.Map.&quot; === scope True &quot;module&quot; &quot;.Map&quot;
--  FIXME: &quot;.Map&quot; === scope True &quot;module&quot; &quot;.Map&quot; -- probably should work, but really needs to rewrite a fair bit
    &quot;(.Monad.&gt;&gt;=&quot; === name &quot;&gt;&gt;=&quot; . scope True &quot;module&quot; &quot;.Monad&quot;
--  FIXME: &quot;author:Taylor-M.-Hedberg&quot; === scope True &quot;author&quot; &quot;Taylor-M.-Hedberg&quot;
    &quot;author:Bryan-O&apos;Sullivan&quot; === scope True &quot;author&quot; &quot;Bryan-O&apos;Sullivan&quot;
    &quot;\8801&quot; === name &quot;\8801&quot;
    &quot;( )&quot; === id -- FIXME: Should probably be ()</file><file path=".ghci">:set -Wunused-binds -Wunused-imports -Worphans
:set -isrc
:set -hide-package=ghc-lib-parser
:load Main src/Paths.hs

:def test \xs -&gt; return $ &quot;:main test &quot; ++ xs

:{
:def opt \xs -&gt; return $ unlines
        [&quot;:!mkdir dist\\obj\\o2&quot;
        ,&quot;:!ghc -O2 -fno-state-hack -hide-package=ghc-lib-parser -isrc --make src/Paths.hs Main -threaded -outputdir dist/obj/o2 -o dist/obj/o2/main -rtsopts cbits/text_search.o&quot;
        ,&quot;:!dist\\obj\\o2\\main +RTS -T -N2 -RTS &quot; ++ xs]
:}
:{
:def opt1 \xs -&gt; return $ unlines
        [&quot;:!mkdir dist\\obj\\o1&quot;
        ,&quot;:!ghc -O1 -fno-state-hack -isrc --make src/Paths.hs Main -threaded -outputdir dist/obj/o1 -o dist/obj/o1/main -rtsopts cbits/text_search.o&quot;
        ,&quot;:!dist\\obj\\o1\\main +RTS -T -N2 -RTS &quot; ++ xs]
:}
:{
:def opt0 \xs -&gt; return $ unlines
        [&quot;:!mkdir dist\\obj\\o0&quot;
        ,&quot;:!ghc -O0 -fno-state-hack -isrc --make src/Paths.hs Main -threaded -outputdir dist/obj/o0 -o dist/obj/o0/main -rtsopts cbits/text_search.o&quot;
        ,&quot;:!dist\\obj\\o0\\main +RTS -T -N2 -RTS &quot; ++ xs]
:}
:{
:def time_ \xs -&gt; return $ unlines
        [&quot;:!mkdir dist\\obj\\prof&quot;
        ,&quot;:!ghc -prof -rtsopts -fprof-auto -fprof-cafs -O2 -fno-state-hack -isrc -DPROFILE --make src/Paths.hs Main -outputdir dist/obj/prof -o dist/obj/prof/main cbits/text_search.o&quot;
        ,&quot;:!dist\\obj\\prof\\main +RTS -P -T -RTS &quot; ++ xs]
:}
:{
:def time \xs -&gt; return $ unlines
        [&quot;:time_ &quot; ++ xs
        ,&quot;:!start main.prof&quot;]
:}
:{
:def space \xs -&gt; return $ unlines
        [&quot;:!mkdir dist\\obj\\prof&quot;
        ,&quot;:!ghc -fno-state-hack -prof -rtsopts -fprof-auto -fprof-cafs -isrc -DPROFILE --make src/Paths.hs Main -outputdir dist/obj/prof -o dist/obj/prof/main cbits/text_search.o &amp;&amp; &quot; ++
         &quot;dist\\obj\\prof\\main +RTS -xt -L1000 -h -T -RTS &quot; ++ xs ++ &quot; &amp;&amp; &quot; ++
         &quot;hp2pretty main.hp&quot;]
:}</file><file path=".gitignore">/obj/
/dist/
/dist-newstyle/
log.txt
*.o
*.prof
/.stack-work/
/issues/</file><file path=".hlint.yaml"># HLint configuration file
# https://github.com/ndmitchell/hlint
##########################

# This file contains a template configuration file, which is typically
# placed as .hlint.yaml in the root of your project


# Warnings currently triggered by your code
- ignore: {name: &quot;Use camelCase&quot;}
- ignore: {name: &quot;Use fewer imports&quot;}
- ignore: {name: &quot;Use module export list&quot;}
- ignore: {name: &quot;Use list literal pattern&quot;}
- ignore: {name: &quot;Use void&quot;}
- ignore: {name: &quot;Redundant pure&quot;}
- ignore: {name: &quot;Redundant do&quot;}
- ignore: {name: &quot;Move brackets to avoid $&quot;}
- ignore: {name: &quot;Unused LANGUAGE pragma&quot;}
- ignore: {name: &quot;Use let&quot;}
- ignore: {name: &quot;Use /=&quot;}
- ignore: {name: &quot;Use when&quot;}
- ignore: {name: &quot;Eta reduce&quot;}
- ignore: {name: &quot;Use foldl&quot;}
- ignore: {name: &quot;Evaluate&quot;}
- ignore: {name: &quot;Use &lt;$&gt;&quot;}
- ignore: {name: &quot;Avoid lambda&quot;}
- ignore: {name: &quot;Avoid lambda using `infix`&quot;}
- ignore: {name: &quot;Redundant bracket&quot;}
- ignore: {name: &quot;Use lambda-case&quot;}


# Specify additional command line arguments
#
# - arguments: [--color, --cpp-simple, -XQuasiQuotes]


# Control which extensions/flags/modules/functions can be used
#
# - extensions:
#   - default: false # all extension are banned by default
#   - name: [PatternGuards, ViewPatterns] # only these listed extensions can be used
#   - {name: CPP, within: CrossPlatform} # CPP can only be used in a given module
#
# - flags:
#   - {name: -w, within: []} # -w is allowed nowhere
#
# - modules:
#   - {name: [Data.Set, Data.HashSet], as: Set} # if you import Data.Set qualified, it must be as &apos;Set&apos;
#   - {name: Control.Arrow, within: []} # Certain modules are banned entirely
#
# - functions:
#   - {name: unsafePerformIO, within: []} # unsafePerformIO can only appear in no modules


# Add custom hints for this project
#
# Will suggest replacing &quot;wibbleMany [myvar]&quot; with &quot;wibbleOne myvar&quot;
# - error: {lhs: &quot;wibbleMany [x]&quot;, rhs: wibbleOne x}


# Turn on hints that are off by default
#
# Ban &quot;module X(module X) where&quot;, to require a real export list
# - warn: {name: Use explicit module export list}
#
# Replace a $ b $ c with a . b $ c
# - group: {name: dollar, enabled: true}
#
# Generalise map to fmap, ++ to &lt;&gt;
# - group: {name: generalise, enabled: true}


# Ignore some builtin hints
# - ignore: {name: Use let}
# - ignore: {name: Use const, within: SpecialModule} # Only within certain modules


# Define some custom infix operators
# - fixity: infixr 3 ~^#^~


# To generate a suitable file for HLint do:
# $ hlint --default &gt; .hlint.yaml</file><file path=".stylish-haskell.yaml"># stylish-haskell configuration file
# ==================================

# The stylish-haskell tool is mainly configured by specifying steps. These steps
# are a list, so they have an order, and one specific step may appear more than
# once (if needed). Each file is processed by these steps in the given order.
steps:
  # Convert some ASCII sequences to their Unicode equivalents. This is disabled
  # by default.
  # - unicode_syntax:
  #     # In order to make this work, we also need to insert the UnicodeSyntax
  #     # language pragma. If this flag is set to true, we insert it when it&apos;s
  #     # not already present. You may want to disable it if you configure
  #     # language extensions using some other method than pragmas. Default:
  #     # true.
  #     add_language_pragma: true

  # Align the right hand side of some elements.  This is quite conservative
  # and only applies to statements where each element occupies a single
  # line.
  - simple_align:
      cases: true
      top_level_patterns: false
      records: false

  # Import cleanup
  - imports:
      # There are different ways we can align names and lists.
      #
      # - global: Align the import names and import list throughout the entire
      #   file.
      #
      # - file: Like global, but don&apos;t add padding when there are no qualified
      #   imports in the file.
      #
      # - group: Only align the imports per group (a group is formed by adjacent
      #   import lines).
      #
      # - none: Do not perform any alignment.
      #
      # Default: global.
      align: none

      # The following options affect only import list alignment.
      #
      # List align has following options:
      #
      # - after_alias: Import list is aligned with end of import including
      #   &apos;as&apos; and &apos;hiding&apos; keywords.
      #
      #   &gt; import qualified Data.List      as List (concat, foldl, foldr, head,
      #   &gt;                                          init, last, length)
      #
      # - with_alias: Import list is aligned with start of alias or hiding.
      #
      #   &gt; import qualified Data.List      as List (concat, foldl, foldr, head,
      #   &gt;                                 init, last, length)
      #
      # - with_module_name: Import list is aligned `list_padding` spaces after
      #   the module name.
      #
      #   &gt; import qualified Data.List      as List (concat, foldl, foldr, head,
      #                          init, last, length)
      #
      #   This is mainly intended for use with `pad_module_names: false`.
      #
      #   &gt; import qualified Data.List as List (concat, foldl, foldr, head,
      #                          init, last, length, scanl, scanr, take, drop,
      #                          sort, nub)
      #
      # - new_line: Import list starts always on new line.
      #
      #   &gt; import qualified Data.List      as List
      #   &gt;     (concat, foldl, foldr, head, init, last, length)
      #
      # Default: after_alias
      list_align: after_alias

      # Right-pad the module names to align imports in a group:
      #
      # - true: a little more readable
      #
      #   &gt; import qualified Data.List       as List (concat, foldl, foldr,
      #   &gt;                                           init, last, length)
      #   &gt; import qualified Data.List.Extra as List (concat, foldl, foldr,
      #   &gt;                                           init, last, length)
      #
      # - false: diff-safe
      #
      #   &gt; import qualified Data.List as List (concat, foldl, foldr, init,
      #   &gt;                                     last, length)
      #   &gt; import qualified Data.List.Extra as List (concat, foldl, foldr,
      #   &gt;                                           init, last, length)
      #
      # Default: true
      pad_module_names: true

      # Long list align style takes effect when import is too long. This is
      # determined by &apos;columns&apos; setting.
      #
      # - inline: This option will put as much specs on same line as possible.
      #
      # - new_line: Import list will start on new line.
      #
      # - new_line_multiline: Import list will start on new line when it&apos;s
      #   short enough to fit to single line. Otherwise it&apos;ll be multiline.
      #
      # - multiline: One line per import list entry.
      #   Type with constructor list acts like single import.
      #
      #   &gt; import qualified Data.Map as M
      #   &gt;     ( empty
      #   &gt;     , singleton
      #   &gt;     , ...
      #   &gt;     , delete
      #   &gt;     )
      #
      # Default: inline
      long_list_align: inline

      # Align empty list (importing instances)
      #
      # Empty list align has following options
      #
      # - inherit: inherit list_align setting
      #
      # - right_after: () is right after the module name:
      #
      #   &gt; import Vector.Instances ()
      #
      # Default: inherit
      empty_list_align: inherit

      # List padding determines indentation of import list on lines after import.
      # This option affects &apos;long_list_align&apos;.
      #
      # - &lt;integer&gt;: constant value
      #
      # - module_name: align under start of module name.
      #   Useful for &apos;file&apos; and &apos;group&apos; align settings.
      list_padding: 4

      # Separate lists option affects formatting of import list for type
      # or class. The only difference is single space between type and list
      # of constructors, selectors and class functions.
      #
      # - true: There is single space between Foldable type and list of it&apos;s
      #   functions.
      #
      #   &gt; import Data.Foldable (Foldable (fold, foldl, foldMap))
      #
      # - false: There is no space between Foldable type and list of it&apos;s
      #   functions.
      #
      #   &gt; import Data.Foldable (Foldable(fold, foldl, foldMap))
      #
      # Default: true
      separate_lists: true

      # Space surround option affects formatting of import lists on a single
      # line. The only difference is single space after the initial
      # parenthesis and a single space before the terminal parenthesis.
      #
      # - true: There is single space associated with the enclosing
      #   parenthesis.
      #
      #   &gt; import Data.Foo ( foo )
      #
      # - false: There is no space associated with the enclosing parenthesis
      #
      #   &gt; import Data.Foo (foo)
      #
      # Default: false
      space_surround: false

  # Language pragmas
  - language_pragmas:
      # We can generate different styles of language pragma lists.
      #
      # - vertical: Vertical-spaced language pragmas, one per line.
      #
      # - compact: A more compact style.
      #
      # - compact_line: Similar to compact, but wrap each line with
      #   `{-#LANGUAGE #-}&apos;.
      #
      # Default: vertical.
      style: compact

      # Align affects alignment of closing pragma brackets.
      #
      # - true: Brackets are aligned in same column.
      #
      # - false: Brackets are not aligned together. There is only one space
      #   between actual import and closing bracket.
      #
      # Default: true
      align: true

      # stylish-haskell can detect redundancy of some language pragmas. If this
      # is set to true, it will remove those redundant pragmas. Default: true.
      remove_redundant: true

  # Replace tabs by spaces. This is disabled by default.
  # - tabs:
  #     # Number of spaces to use for each tab. Default: 8, as specified by the
  #     # Haskell report.
  #     spaces: 8

  # Remove trailing whitespace
  - trailing_whitespace: {}

  # Squash multiple spaces between the left and right hand sides of some
  # elements into single spaces. Basically, this undoes the effect of
  # simple_align but is a bit less conservative.
  # - squash: {}

# A common setting is the number of columns (parts of) code will be wrapped
# to. Different steps take this into account. Default: 80.
columns: 80

# By default, line endings are converted according to the OS. You can override
# preferred format here.
#
# - native: Native newline format. CRLF on Windows, LF on other OSes.
#
# - lf: Convert to LF (&quot;\n&quot;).
#
# - crlf: Convert to CRLF (&quot;\r\n&quot;).
#
# Default: native.
newline: native

# Sometimes, language extensions are specified in a cabal file or from the
# command line instead of using language pragmas in the file. stylish-haskell
# needs to be aware of these, so it can parse the file correctly.
#
# No language extensions are enabled by default.
# language_extensions:
  # - TemplateHaskell
  # - QuasiQuotes</file><file path=".weeder.yaml">- message:
  - name: Weeds exported
  # Constructors, for completeness
  - identifier: [IAlias, IName]

- message:
  - name: Redundant build-depends entry
  # Only required for GHC 7.8 and below
  - depends: old-locale</file><file path="CHANGES.txt">Changelog for Hoogle (* = API change, @ = database format change)

    #411, switched to xdg directory and deprecated legacy location
    Require and support crypton-connection &gt;= 0.4.1
5.0.18.4, released 2024-01-14
    Don&apos;t test on GHC 9.2 or earlier
    Fix up the output of /stats to account for API changes
    #380, move results before left anchors in tab focus order
5.0.18.3, released 2021-12-24
    Compatibility with aeson-2.0
5.0.18.2, released 2021-09-01
    Compatibility with extra-1.7.10
    #370, add --jsonl to produce JSON on separate lines
5.0.18.1, released 2020-12-27
    #365, add flag to disable network tests
5.0.18, released 2020-07-19
    #356, make server --haddock work better
@   #339, support enough names to index all of Hackage
    #353, remove leading latex comments
    #351, partially fixed ghc-pkg output parsing for GHC 8.8
5.0.17.15, released 2020-02-15
    #342, have --local flag generate a set with the directory name
    Consider packages in Stackage Nightly and LTS part of Stackage
    #338, add format=text to strip HTML from the JSON
5.0.17.14, released 2020-01-08
    #334, allow haskell-src-exts-1.23
    #333, disable Aelve Codesearch links
5.0.17.13, released 2019-12-07
    #331, make --count work with --json
    #332, support ?q= as well as ?hoogle= (since it used to be q)
    #330, work with more browsers when JavaScript is disabled
5.0.17.12, released 2019-11-02
    Allow haskell-src-exts-1.22
    #324, make unicode search work more
    #323, fix escaping in packages list (on the left)
5.0.17.11, released 2019-08-23
    #318, allow --json to get results JSON from the command line
5.0.17.10, released 2019-08-02
    #314, fix bad URL trying to access package on Hoogle with --local
    #311, fix an overflow with weight computations
    Fix up the /log page to avoid raising CSP errors
    Avoid raising error when you see a bad URL
    Make errors from the server be code 400 rather than 500
5.0.17.9, released 2019-05-30
    #306, fix a potential directory traversal bug
    #305, add a flag to disable security headers
5.0.17.8, released 2019-05-14
    #299, add some security-improving headers
    #298, use Blaze for constructing most HTML
5.0.17.7, released 2019-05-10
    Fix an XSS vulnerability, reported by @alexanderGugel
    #297, make Uses for packages point at reverse deps
    #261, add support for pattern synonyms
5.0.17.6, released 2019-03-27
    #291, optimise the log parsing (5x speedup)
    #289, change to use autofocus attribute
    Add --links flag to integrate with https://codesearch.aelve.com/
    Remove warning about type search
5.0.17.5, released 2019-01-27
*   #285, remove accidental API break in 5.0.17.4
    Lots of improvements in type search
5.0.17.4, released 2018-12-10
*   #285, change targetPackage/Module to be opaque
    Require haskell-src-exts-1.21
    #271, added FromJSON instance for Target
    #253, adds JSON pagination from query parameters
    Make sure &lt;h1&gt; works well in doc snippets
    #251, make sure transformers is more popular than mtl
    Require network-uri &gt;= 2.6, don&apos;t require network
5.0.17.3, released 2018-04-17
    Require extra-1.6.6
    Fix the reported memory sizes
5.0.17.2, released 2018-03-16
    Remove support for GHC 7.10
    Require conduit-1.3.0
    #245, add support for GHC 8.4
5.0.17.1, released 2018-01-27
    #238, only identify the database by the first three version components
    #236, in --local mode replace file:// links in Haddock pages
5.0.17, released 2018-01-17
    Add lower bounds for time and bytestring
    #234, allow http-conduit-0.15
5.0.16, released 2018-01-03
    #232, allow haskell-src-exts-1.18-1.20
5.0.15, released 2017-12-12
    Allow haskell-src-exts-1.20
5.0.14, released 2017-11-28
    #228, add --datadir for overriding data directory on servers
    #223, don&apos;t break on foldl&apos;
    #222, make sure all packages appear in the search
5.0.13, released 2017-07-30
    #219, treat the query &quot;a-&gt;b&quot; the same as &quot;a -&gt; b&quot;
    #215, if a specified module/package is missing, give no results
    #220, start on port 8080 by default
    Rely on the fact ghc API is now on Hackage
    #217, fix the mode tag propagating to child links
5.0.12, released 2017-05-06
    #210, expose targetInfo and targetSearchDisplay
5.0.11, released 2017-05-02
    #209, add a defaultDatabaseLocation function
5.0.10, released 2017-04-17
    #205, change how the link URL is computed
    #206, put newer versions of a package first
5.0.9, released 2017-01-16
    #202, add --haddock functionality
5.0.8, released 2016-12-29
    #194, make --local work regardless of code page
5.0.7, released 2016-12-27
    #200, make sure the content-type is set properly
5.0.6, released 2016-11-30
    #196, make --local look for .cabal files as well
    Fix up Frege documentation generation
5.0.5, released 2016-11-24
    #193, support multiple --local flags
    #195, add --home flag to server mode
    Allow haskell-src-exts-1.19
5.0.4, released 2016-09-11
    #184, use file URLs for local docs
    #183, make --local look for .txt files recursively
5.0.3, released 2016-08-28
    #181, use the proper network constraints
    Avoid deprecated Aeson modules
5.0.2, released 2016-07-25
    Move to haskell-src-exts-1.18
5.0.1, released 2016-07-12
    #178, support the --link argument
    #178, add module names to results on the command line
    #177, require containers 0.5 or above
5.0, released 2016-06-24
    #172, make sure --local links work on Linux
    #116, store data files in getAppUserDataDirectory by default
    G472, be robust to corrupt Hoogle files
    G521, make sure it works with inverted color preferences
    Rewrite from scratch
4.2.38, released 2015-01-28
    #96, allow certicate verification failures
    #95, allow a higher version of Cabal on older GHCs
4.2.37, released 2015-01-13
    #94, GHC 7.10 support
4.2.36, released 2014-10-12
    #85, add support for missing type constructors
4.2.35, released 2014-09-15
    Allow haskell-src-exts-1.16
4.2.34, released 2014-07-09
    Add defaultDatabaseLocation
4.2.33, released 2014-06-15
    Allow WAI-3.0
4.2.32, released 2014-04-14
    Allow haskell-src-exts-1.15
4.2.31, released 2014-04-03
    #61, support conduit-1.1
4.2.30, released 2014-03-23
    #57, support QuickCheck-2.7
4.2.29, released 2014-02-23
    #55, if reading as UTF8 fails, explicitly try Latin1
    Add QuickCheck as a dependency
    Change createDatabase to also save the file
    Disable rank feature
    Remove running a hoogle query without converting the database
    Ignore packages without documentation to hoogle data
4.2.28, released 2014-01-03
    Upgrade to shake-0.11
    #49, update &quot;hoogle data&quot; to be incremental
4.2.27, released 2014-01-01
    Rewrite how &quot;hoogle data&quot; works
    #45, if you are building all, also depend on default
    #47, switch to using Shake to build the recipes
    Add a dependency on Shake
4.2.26, released 2013-12-10
    Fix omission of the Test file
4.2.25, released 2013-12-09
    Fix timestamps in .tar.gz dist file
4.2.24, released 2013-12-08
    Allow WAI 2.0
    Fix the Keyword generator
4.2.23, released 2013-09-29
    Improvements to Haddock conversion
4.2.22, released 2013-09-29
    Download Hoogle data from the old Hackage server
4.2.21, released 2013-09-01
    #25, make the tarball pass the tests
    #26, GHC 7.8 compatibility
    Ensure alias resolution is bottom-up and recursive
4.2.20, released 2013-08-25
    #619, do not depend on unix on Windows
4.2.19, released 2013-08-20
    Fix version bounds
4.2.18, released 2013-08-20
    Allow bytestring-0.9
4.2.17, released 2013-08-20
    Upgrade to haskell-src-exts-1.14
    Visual redesign
    Require bytestring-0.10 or above, due to NFData instances
    Add NFData instance to Database
4.2.16, released 2013-02-21
    Remove lots of explicit upper bounds
4.2.15, released 2013-01-29
    Allow http-types-0.8
    Allow case-insensitive-1.0
    Support --local for GHC docs
    #568, rewrite Haddock links in --local
4.2.14, released 2012-11-06
    Switch license from GPL to BSD3
    GHC 7.6 fixes
    ##4, Allow Cabal-1.16.*
4.2.13, released 2012-08-18
    Allow cmdargs-0.10.*
4.2.12, released 2012-07-15
    Allow conduit-0.5, wai-1.3 and warp-1.3
    Upgrade to http-types-0.7.*
    In embedded mode, don&apos;t hijack the URL bar or title
    Upgrade to jQuery 1.7.2
    #89, add a format=json output mode
    #476, update the URL as you type
    Improve iPhone support
    Update the copyright year in the footer
    Double the speed of hoogle server responses
4.2.11, released 2012-04-05
    Allow transformers-0.3
    Allow conduit-0.4, wai-1.2 and warp-1.2
    Allow haskell-src-exts-1.12 and 1.13
4.2.10, released 2012-03-04
    #533, be paranoid when parsing Cabal files
4.2.9, released 2012-03-01
    Upgrade to WAI-1.1 and Warp-1.1
    #525, don&apos;t rely on a redirect to find files
    Allow Cabal-1.14
4.2.8, released 2011-11-27
    Allow cmdargs-0.9
    Fix setting the global read flags and unsetting them properly
    Allow case-insensitive-0.4.*
    Make data --local have a good default on Linux
    Make server --local work on Windows
    #407, rewrite OpenSearch plugin to work regardless of the server
4.2.7, released 2011-09-03
    Allow cmdargs-0.8
4.2.6, released 2011-08-12
    Permit GHC 7.2
    Allow case-insensitive-0.3.*
    Fix bug when searching for toString in the embed mode
    Make --redownload work on the tarballs
4.2.5, released 2011-06-12
    Fix hyperlinks to symbols (i.e. &amp;&amp;) in Haddock
4.2.4, released 2011-05-26
    #434, use either wget or curl to download the files
    Allow haskell-src-exts 1.11.*
    Upgrade to cmdargs==0.7.*
4.2.3, released 2011-05-01
    Generate database for ghc internals
    Give an error if the database is the wrong version
    Add -fno-cse, to make cmdargs work (was losing args annotations)
4.2.2, released 2011-04-25
    Upgrade to WAI==0.4.* and Warp==0.4.*
    Allow parsec 3, since various people have reported it works
    Default module URL&apos;s correctly when not on Hackage
    #417, use proper Haddock parsing for package descriptions
    Make sure https: links work through the web mode
    Rewrite the binary defer layer, cleaner and slightly faster
    Eliminate escaping problems when entering &quot;&apos;s in the search
    Some work on #375, add links to the library page
    Add --template to override the templates at runtime
    Add --dynamic flag to server mode, include update stamps
    Upgrade wai and warp, adds an exception handler
    #82, rewrite showing document snippets, better expand/collapse
    Support &lt;em&gt; tags in Haddock output (as well as &lt;i&gt;)
    Make package matching case insensitive
    #372, add features to improve module name search
    Make module name searching case insensitive
4.2.1, released 2011-01-26
    Fix for pattern match failure when searching for &quot;to&quot;
    Fix for not sending text/html when serving local files
    Eliminate the --nostdin flag, now unnecessary
    Change to use WAI/Warp instead of HTTP and custom server
    Fix a bug, didn&apos;t ever show Waiting... on the real website
    Make embed work in IE8
4.2, released 2011-01-23
    Make the CGI interface send the right number of newlines
    Accept prefix and suffix web parameters
    Eliminate isBlankQuery, make Query a Monoid
    Make Query abstract, add queryPackages/querySetPackage
    Rename querySuggestions/queryCompletions by dropping the query
    Add mode=embed support
    Add some log analysis features
    Ignore some whitespace in the input file
    Work around a cabal bug, include jquery.cookie.js
    Add ?version=xxx to .css and .js, to make it auto refresh
4.1.5, released 2011-01-16
    #399, rehabilitate mode=suggest
    Stop mode=suggest failing entirely, now cleanly gives no answers
    Combine --web and --webmode
    Complete the command line flag help
    #327, ensure utf8 is found
    #187, ensure LT is found
    Use the Hoogle tarball direct from Hackage
    #54, rework packages, entries and keywords
    #87, make all database files lowercase
    Various javascript/ajax enhancements
4.1.4, released 2011-01-15
    Running data on Posix sets all files to global read/execute
    Relax haskell-src-exts to allow 1.10.1
    Rework the web page display further
4.1.3, released 2011-01-09
    Read and write all database files in UTF8
    #391, add tar -xzf when extracting from the tarball
    Change search results display, packages/modules on separate line
    Exclude haskellN* from the platform, they are in base
    Add --nostdin to server mode, to support running with nohup
    Loosen dependencies for tagsoup (typo&apos;d it before)
4.1.2, released 2010-12-19
    Loosen dependencies for tagsoup and HTTP (but not parsec)
    Avoid self circular dependencies
4.1.1, released 2010-12-18
    #195, include all the necessary resources to run as a server
    When in server mode, be more robust to errors
4.1, released 2010-12-18
    #320, make sure system is found
    #146, preserve forall&apos;s in everywhere
    #186, switch to using haskell-src-exts to parse input files
    #249, make sure you find MonadWriter
    #235, make sure you find forall
    #309, make sure there are links for keywords
    #78, add --link flag
    #59, operators look nicer, and have blue brackets round them
    #352, can now parse ( # ) as a function name in the input
    #280, searching for &quot;~ +keyword&quot; should find keyword
    #116, fix links for types/classes
    #83, all searching for package-name
    #94, allow textbases to be used automatically
    #92, short flags are now handled by cmdargs, so work
    #51, test mode now does what test and testfile did
    #66, turn Hoogle into a library
    Add --server flag, to run as a server
4.0.7, released 2009-07-19
    Start of changelog</file><file path="ghci.bat">ghci.exe cbits\text_search.o %*</file><file path="hoogle.cabal">cabal-version:      1.18
build-type:         Simple
name:               hoogle
version:            5.0.19.0
license:            BSD3
license-file:       LICENSE
category:           Development
author:             Neil Mitchell &lt;ndmitchell@gmail.com&gt;
maintainer:         Neil Mitchell &lt;ndmitchell@gmail.com&gt;
copyright:          Neil Mitchell 2004-2026
synopsis:           Haskell API Search
description:
    Hoogle is a Haskell API search engine, which allows you to
    search many standard Haskell libraries by either function name,
    or by approximate type signature.
homepage:           https://hoogle.haskell.org/
bug-reports:        https://github.com/ndmitchell/hoogle/issues
tested-with:        GHC==9.8, GHC==9.6, GHC==9.4
extra-doc-files:
    README.md
    CHANGES.txt
extra-source-files:
    cbits/*.h
    cbits/*.c
data-files:
    misc/sample-data/henry.txt
    misc/sample-data/emily-1.11/emily.txt
    misc/sample-data/emily-1.2/emily.txt
    misc/settings.txt
    html/*.js
    html/*.png
    html/*.css
    html/*.xml
    html/*.html
    html/plugin/*.css
    html/plugin/*.js
    html/plugin/*.png

source-repository head
    type:     git
    location: https://github.com/ndmitchell/hoogle.git

library
    hs-source-dirs:     src
    default-language:   Haskell2010

    build-depends:
        QuickCheck,
        aeson &gt;= 2,
        ansi-terminal,
        base &gt;= 4 &amp;&amp; &lt; 5,
        blaze-html,
        blaze-markup,
        binary,
        bytestring &gt;= 0.10.2.0,
        Cabal-syntax &gt;= 3.8,
        cmdargs,
        conduit &gt;= 1.3.0,
        conduit-extra &gt;= 1.2.3.2,
        containers &gt;= 0.5,
        crypton-connection &gt;= 0.4.1,
        data-default-class,
        deepseq,
        directory,
        extra &gt;= 1.6.6,
        filepath,
        ghc-lib-parser &gt;= 9.6.5 &amp;&amp; &lt; 9.16,
        hackage-revdeps &gt;= 0.3 &amp;&amp; &lt; 0.4,
        old-locale,
        hashable,
        haskell-src-exts &gt;= 1.22 &amp;&amp; &lt; 1.24,
        http-conduit &gt;= 2.3,
        http-types,
        js-flot,
        js-jquery,
        mmap,
        process-extras,
        resourcet,
        safe &gt;= 0.3.20,
        storable-tuple,
        tar,
        template-haskell,
        temporary,
        text &gt;= 2,
        time &gt;= 1.5,
        transformers,
        uniplate,
        utf8-string &gt;= 0.3.1,
        vector,
        wai,
        wai-logger,
        warp,
        warp-tls &gt;= 3.4.2,
        zlib

    c-sources:        cbits/text_search.c
    include-dirs:     cbits
    includes:         include.h
    install-includes: include.h
    cc-options:       -std=c99

    ghc-options:      -fno-state-hack
    if impl(ghc &lt; 8.0)
        build-depends: semigroups &gt;= 0.18

    exposed-modules:
        Hoogle

    other-modules:
        Paths_hoogle
        Action.CmdLine
        Action.Generate
        Action.Search
        Action.Server
        Action.Test
        Input.Cabal
        Input.Download
        Input.Haddock
        Input.Item
        Input.ParseDecl
        Input.Reorder
        Input.Set
        Input.Settings
        Output.Items
        Output.Names
        Output.Tags
        Output.Types
        Query
        General.Conduit
        General.IString
        General.Log
        General.Store
        General.Str
        General.Template
        General.Timing
        General.Util
        General.Web


executable hoogle
    main-is:            src/Main.hs
    default-language:   Haskell2010
    ghc-options:        -threaded -rtsopts

    build-depends:
        base &gt;= 4 &amp;&amp; &lt; 5,
        hoogle</file><file path="LICENSE">Copyright Neil Mitchell 2004-2026.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Neil Mitchell nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</file><file path="PULL_REQUEST_TEMPLATE.md">Thanks for the pull request!

By raising this pull request you confirm you are licensing your contribution under all licenses that apply to this project (see LICENSE) and that you have no patents covering your contribution.

If you care, my PR preferences are at https://github.com/ndmitchell/neil#contributions, but they&apos;re all guidelines, and I&apos;m not too fussy - you don&apos;t have to read them.</file><file path="README.md"># Hoogle [![Hackage version](https://img.shields.io/hackage/v/hoogle.svg?label=Hackage)](https://hackage.haskell.org/package/hoogle) [![Stackage version](https://www.stackage.org/package/hoogle/badge/nightly?label=Stackage)](https://www.stackage.org/package/hoogle) [![Build status](https://img.shields.io/github/actions/workflow/status/ndmitchell/hoogle/ci.yml?branch=master)](https://github.com/ndmitchell/hoogle/actions)

Hoogle is a Haskell API search engine, which allows you to search many standard Haskell libraries by either function name, or by approximate type signature. The online version can be found at https://hoogle.haskell.org/ and searches [Stackage](https://www.stackage.org/).

* **Online version:** https://hoogle.haskell.org/
* **Hackage page:** https://hackage.haskell.org/package/hoogle
* **Source code:** https://github.com/ndmitchell/hoogle
* **Bug tracker:** https://github.com/ndmitchell/hoogle/issues

## Hoogle Use

Hoogle can be used in several ways:

* **Online**, with the web interface at https://hoogle.haskell.org/
* **In [IRC](https://wiki.haskell.org/IRC_channel)**, using the [Lambdabot](https://wiki.haskell.org/Lambdabot) plugin with `@hoogle` and `@hoogle+`
* **From `emacs`**, by means of [`engine-mode`](https://github.com/hrs/engine-mode)
* **[Installed locally](./docs/Install.md)**, with either a command line or in a browser
* **[As a developer](./docs/API.md)**, through Haskell or JSON APIs.

# Searches

## Searching

Here are some example searches:

* `map` searches as text, finding `map`, `concatMap`, `mapM`
* `con map` searches for the text &quot;map&quot; and &quot;con&quot; finding `concatMap`, but not `map`
* `a -&gt; a` searches by type, finding `id :: a -&gt; a`
* `a` searches for the text &quot;a&quot;
* `:: a` searches for the type &quot;a&quot;
* `id :: a -&gt; a` searches for the text &quot;id&quot; and the type &quot;a -&gt; a&quot;


## Scope

By default, searches look at the [Haskell Platform](https://www.haskell.org/platform/) and [Haskell keywords](https://wiki.haskell.org/Keywords). However, all [Stackage](https://stackage.org) packages are available to search. As some examples:

* `mode +cmdargs` searches only the &quot;cmdargs&quot; package
* `file -base` searches the Haskell Platform, excluding the &quot;base&quot; package
* `mode +platform +cmdargs` searches both the Haskell Platform and the &quot;cmdargs&quot; package
* `count +missingh` searches only the &quot;MissingH&quot; package - all packages are written in lower-case

With the set of packages you are searching, you can also restrict the set of modules searched:

* `file -System` excludes results from modules such as `System.IO`, `System.FilePath.Windows` and `Distribution.System`
* `fold +Data.Map` finds results in the `Data.Map` module


# Integration

## Command Line Version

To invoke Hoogle type:

    $ hoogle &quot;[a] -&gt; [b]&quot;

Note the quotes, otherwise you will redirect the output to the file [b].

To ensure you have data files for the Hackage modules, you will first need to
type:

    $ hoogle generate

Which will download and build Hoogle databases.

## Command Line UI

There is a terminal/curses based UI available through [`cabal install bhoogle`](https://hackage.haskell.org/package/bhoogle).

## Chrome Integration

**As a keyword search:** With a keyword search you can type `h map` directly into the location bar to perform a Hoogle search. Go to the [Hoogle website](https://hoogle.haskell.org/) in Chrome, right-click in the Hoogle search field and select &quot;Add as a search engine...&quot;. Give it a keyword such as &quot;h&quot;.

## Firefox Integration

**From the search bar:** Go to the [Hoogle website](https://hoogle.haskell.org/) in Firefox and click on the `` symbol at the right of the URL bar, and select the &quot;Add Search Engine&quot; option. Click the hoogle logo at the bottom of the completion dropdown when searching to perform a Hoogle search.

**As a keyword search:** With a keyword search you can type `h map` directly into the location bar to perform a Hoogle search. Go to the [Hoogle website](https://hoogle.haskell.org/) in Firefox, right-click in the Hoogle search field and select &quot;Add a Keyword for this Search...&quot;. Given it a keyword such as &quot;h&quot;.

## Others

* [Doc Browser](https://github.com/qwfy/doc-browser)

### The Source Code

    $ git clone https://github.com/ndmitchell/hoogle.git

Contributions are most welcome. Hoogle is written in Haskell 98 + Heirarchical Modules, I do not wish to change this. Other than that, I&apos;m pretty flexible about most aspects of Hoogle. The [issue tracker](https://github.com/ndmitchell/hoogle/issues) has many outstanding tasks, but please contact me if you have thoughts on doing something major to Hoogle, so I can give some advice.

# Background

Hoogle work is licensed under the [BSD-3-Clause license](https://github.com/ndmitchell/hoogle/blob/master/LICENSE).

## Theoretical Foundations

A lot of related work was done by Rittri [1] and Runciman [2] in the late 80&apos;s. Since then Di Cosmo [3] has produced a book on type isomorphisms. Unfortunately the implementations that accompanied the earlier works were for functional languages that have since become less popular.

1. [Mikael Rittri, Using Types as Search Keys in Function Libraries](https://doi.org/10.1145/99370.99384). Proceedings of the fourth international conference on Functional Programming languages and Computer Architecture: 174-183, June 1989.
2. [Colin Runciman and Ian Toyn, Retrieving reusable software components by polymorphic type](https://doi.org/10.1145/99370.99383). Journal of Functional Programming 1 (2): 191-211, April 1991.
3. [Roberto Di Cosmo, Isomorphisms of types: from lambda-calculus to information retrieval and language design](https://doi.org/10.1145/270563.571468). Birkhauser, 1995. ISBN-0-8176-3763-X

I have given several presentations on type searching all available from [my home page](https://ndmitchell.com/).

## Project Structure

The folders in the repository, and their meaning are:

cbits             - C implementation of the text search used by hoogle

docs              - documention on hoogle

html              - resources for hoogle&apos;s web front-end (html, css, javascript, images, etc.)

misc              - scripts, logos, sample data, etc.

src               - haskell source code

## Similar Tools

I was unaware of any similar tools before starting development, and no other tool has really influenced this tool (except the first on this list). Some related tools are:

* [Google](https://www.google.com/), the leader in online search
* [Hayoo](https://hackage.haskell.org/package/Hayoo), similar to Hoogle, but with less focus on type search
* [Krugle](https://www.krugle.com/), search code, but no Haskell :(
* [Cloogle](https://cloogle.org), for the [Clean](https://clean.cs.ru.nl/Clean) language


## Acknowledgements

All code is all &amp;copy; [Neil Mitchell](https://ndmitchell.com/), 2004-present. The initial version was done over my summer holiday, and further work was done during my PhD. During Summer 2008 I was funded to full-time on Hoogle by [Google Summer of Code](https://summerofcode.withgoogle.com/) with the [haskell.org](https://www.haskell.org/) mentoring organisation. Since then I have been working on Hoogle in my spare time. Various people have given lots of useful ideas, including my PhD supervisor [Colin Runciman](https://www-users.cs.york.ac.uk/~colin/), and various members of the [Plasma group](https://www.cs.york.ac.uk/plasma/wiki/). In addition, the following people have also contributed code or significant debugging work:

* Thomas &quot;Bob&quot; Davie
* Don Stewart
* Thomas Jager
* [Gaal Yahas](https://gaal.livejournal.com/)
* Mike Dodds
* Niklas Broberg
* Esa Ilari Vuokko
* Udo Stenzel
* [Henk-Jan van Tuyl](https://github.com/HJvT)
* Gwern Branwen
* Tillmann Rendel
* David Waern
* Ganesh Sittampalam
* Duncan Coutts
* Peter Collingbourne
* Andrea Vezzosi
* Ian Lynagh
* [Alfredo Di Napoli](http://www.alfredodinapoli.com)

In previous versions, all the data was taken from [Zvon&apos;s Haskell Guide](http://www.zvon.org/other/haskell/Outputglobal/). Thanks to their open and friendly policy of allowing the data to be reused, this project became possible. More recent versions use the Hierarchical Libraries as distributed with GHC, and databases generated by Haddock.

# Interesting links

* https://atom.io/packages/haskell-hoogle
* https://hackage.haskell.org/package/hoogle-index</file><file path="Setup.hs">import Distribution.Simple
main = defaultMain</file><file path="todo.txt">TODO

Rename set:stackage to /everything/, should be distinct
set:stackage really does restrict to the packages in stackage.
Everything includes all the package names on hackage.

hackage.catch - a package that I don&apos;t index?

Add support for @name annotations in Haddock .txt files
Required to support the Mu compiler flags

Add ghc-flags and keywords into the normal run



ghc-pkg field * haddock-html


haddock-html: C:\Users\1323649\AppData\Local\Programs\stack\i386-windows\ghc-7.1
0.2\lib/../doc/html/libraries/binary-0.7.5.0
haddock-html: C:\Users\1323649\AppData\Local\Programs\stack\i386-windows\ghc-7.1
0.2\lib/../doc/html/libraries/bin-package-db-0.0.0.0
haddock-html: C:\Users\1323649\AppData\Local\Programs\stack\i386-windows\ghc-7.1
0.2\lib/../doc/html/libraries/base-4.8.1.0
haddock-html: C:\Users\1323649\AppData\Local\Programs\stack\i386-windows\ghc-7.1
0.2\lib/../doc/html/libraries/array-0.5.1.0


--local=True
--local=False
[no --local]


--local

--local=false

--local=true -- only use things locally, found with ghc-pkg field
--local=blend -- use metadata remotely, blend with local signatures
--local=false -- only use remote things

Available both during generate (which data to put in the database) and during 


haskell:foo/Module.Name.function

New URL scheme.



Before beta:

* Implement type search

After beta:

* Rename Input to Generate, Output to Search, and move some out from Action to Search.All
* Implement the Generate design
* Add a Hoogle API</file><file path="todo2.txt">Refinement on type search

Each preprocessor can contribute a negative weight


rarity returns either Nothing or a score

arity returns either Nothing or a score


* **LHS only:** _[Alias follow]_ `type X = Y` provides a rewrite `X ~&gt; Y`.
* **LHS only:** _[Instance subtype]_ `instance C X` provides a rewrite `X ~&gt; forall z . C z`.
* **RHS only:** _[Context delete]_ `C x =&gt; y ~&gt; y`.
* **Both:** _[Special]_ `Maybe a ~&gt; a` can be applied, along with a few other special rules.

from a RHS, can follow away


TypeQ -&gt; TypeA -&gt; Maybe Score
-- nothing is stop now
-- just is a good value
-- pass around [(Double,String)]

refine by arity -- what is the arity, use a single byte
refine by rarity -- how many times the rarist thing occurs
refine by names
refine by matching

9110 distinct names, 97K worth of names
need to give each an id (2 bytes) and a rarity (2 bytes) to each constructor

ByteString in order (so I can find a set matching only one at a time), plus an array of (Word16:id, Word16:rarity)

arity for each function

rarity for each function

names for each function

aliases
instances


for a given type, what can i reduce it to via aliases, what can i reduce it to via instances

types are stored with a type lambda....

type T a = T2 a a

FilePath := String
T1 := \x -&gt; T2 x String x

[] := Foldable a =&gt; a -- Foldable instance
[] := \a -&gt; Eq a =&gt; a -- Eq instance

how rare it is, index into bytestring of packed reductions


[], not very rare, index into list of reducers

ctor :-&gt; (rarity, [reductions])
function :-&gt; (arity, rarity, body)
search -&gt; (arity, body, ctorinfo)

first check arity

then check rarity

then check names

then try and match the body

don&apos;t worry about kind mismatches


(Maybe a) -&gt; Bool

give a weight between an argument and something else

at the end, sum the mismatched variables


2 byte encodings
open bracket

Signature is:

-- context, list of arguments
[(Ctor, Var)] [Bracketed (Var|Ctor)]

Word16





constraints are namespaced into a different universe


Way to map constructor names to ranks

pack things like Just into that table? No, have Just be very special
have kind errors pretty much ignored</file></files></repomix>